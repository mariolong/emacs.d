#+TITLE: Emacs Configuration
#+AUTHOR: Mario Long
#+EMAIL: mariolong5782@gmail.com
#+STARTUP: overview showstars
#+BABEL: :cache yes
#+OPTIONS: ^:nil toc:2
#+LANGUAGE: zh-TW
#+DATE: 2018-06-25 17:42:36 UTC+08:00
#+TODO: TODO(t) WAITING(w) MAYBE(m) BLOG(b) | DONE(d) CANCELED(c)

* Preface

以 org-mode 寫 emacs 設定檔，彷彿在寫一篇華麗的文章，在訴說著一個逐步
成長的故事，每一段程式都是一個感動。

* Testing this configuration

執行 ~makeinit.sh~ 產生 ~init.el~
#+BEGIN_SRC sh :tangle no
./makeinit.sh
#+END_SRC

* Initialization
** Use lexical binding

#+BEGIN_SRC emacs-lisp :padline no
  ;; -*- lexical-binding: t -*-
#+END_SRC

** load prefer newer

#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

** cleanup screen
*** no menu bar, no tool bar, no scroll bar

Press <F10> to show menu

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

*** fullscreen

#+begin_src emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+end_src

*** inhibit startup message

#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+end_src

*** clean message of redefinition

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

*** my scratch message

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message ";;今天又是美好的一天\n")
#+END_SRC

** Font settings

眼睛不好了，把字型放大些，最重要的是設定中文字型和表情符號。
123456789012345678901234567890123456789012345678901234567890

error: Fontset `tty' does not exist
solution: http://www.cnblogs.com/aqing1987/p/4464106.html

#+begin_src emacs-lisp
  (defun set-font-for-chinese ()
    (set-face-attribute 'default nil
                        :family "Source Code Pro" :height 180)
    (set-face-attribute 'variable-pitch nil
                        :family "Sans" :height 200 :weight 'regular)

    (dolist (charset '(kana han cjk-misc bopomofo))
      (set-fontset-font (frame-parameter nil 'font) charset
                        (font-spec :family "Source Han Sans" :size 28)))

    (set-fontset-font (frame-parameter nil 'font) 'symbol
                      (font-spec :family "Symbola" :size 32)))

  (add-to-list 'after-make-frame-functions
               (lambda (new-frame)
                 (select-frame new-frame)
                 (if window-system
                     (set-font-for-chinese))))

  (when window-system
    (set-font-for-chinese))
#+end_src

** Define user's directory variables

#+BEGIN_SRC emacs-lisp
  (defconst user-emacs-directory (file-name-directory (or load-file-name (buffer-file-name))))
  (defconst user-emacs-init-org (expand-file-name "emacs-init.org" user-emacs-directory))
  (defconst emacs-init-el (expand-file-name "init.el" user-emacs-directory))
  (defconst user-secret-file (expand-file-name "personal.el" user-emacs-directory))
  ;; (defconst org-gcal-file-schedule (expand-file-name "gschedule.org" user-emacs-directory))

  (defconst user-cache-directory
    (file-name-as-directory (expand-file-name ".cache" user-emacs-directory))
    "My emacs storage area for persistent files.")

  (setq org-directory "~/Dropbox/GTD")
  (setq org-default-notes-file (expand-file-name "myGTD.org" org-directory)
        org-default-inbox-file (expand-file-name "myGTD.org" org-directory)
        org-my-notes-file (expand-file-name "notes.org" org-directory)
        org-my-food-file (expand-file-name "food.org" org-directory)
        )
#+END_SRC

** Create temporary file directory if it is not exist

#+BEGIN_SRC emacs-lisp
  (set-default 'temporary-file-directory (expand-file-name "tmp" user-emacs-directory))
  (unless (file-exists-p temporary-file-directory)
    (make-directory temporary-file-directory))
#+END_SRC

** Add .emacs.d/lisp to load path

NOTE: Don't use like xxx.el as directory name.

#+BEGIN_SRC emacs-lisp
(let* ((lisp-dir '("lisp/" "themes/")))
  (dolist (lisp-path lisp-dir)
    (when (not (file-exists-p lisp-path))
      (make-directory (concat user-emacs-directory lisp-path) t))
    (let* ((load-dir (concat user-emacs-directory lisp-path))
	   (default-directory load-dir))
      (setq load-path
	    (append
	     (let ((load-path (copy-sequence load-path)))
	       (append
		(copy-sequence (normal-top-level-add-to-load-path '(".")))
		(normal-top-level-add-subdirs-to-load-path)))
	     load-path)))))
#+END_SRC

** Package Management
*** Initialize =package=

用 =package.el= 要先加來源庫。

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

  (package-initialize)
#+END_SRC

*** Install ~use-package~

Switch to use-package form req-package.

*error message: (error "Package ‘dired-’ is unavailable")*

Use =:ensure nil= to override =use-package-always-ensure=.
You need to do this for any non-package.el packag

#+BEGIN_SRC emacs-lisp
  (if (not (package-installed-p 'use-package))
      (progn
        (package-refresh-contents)
        (package-install 'use-package)))

  (require 'use-package)
  (setq use-package-always-defer t)
  (setq use-package-always-ensure t)
#+END_SRC

*** Install ~quelpa-use-package~

[[https://github.com/quelpa/quelpa-use-package][GitHub - quelpa/quelpa-use-package]]

#+BEGIN_SRC emacs-lisp
  (use-package quelpa-use-package
    :init
    (require 'quelpa-use-package))
#+END_SRC

*** Paradox

Project for modernizing Emacs' Package Menu.
With package ratings, usage statistics, customizability, and more.

[[https://github.com/Malabarba/paradox][GitHub - Malabarba/paradox: Project for modernizing Emacs' Package Menu.]]

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :config
      (setq paradox-execute-asynchronously t))
#+END_SRC

** Tangle init.org when it saved

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled."
    (interactive)
    (require 'async)
    (let ((buffer-name "async-make-init.el"))
      (when (equal (buffer-file-name) user-emacs-init-org)
        (message "Begin re-generate init.el")
        (async-start-process buffer-name "sh"
                             '(lambda (result)
                                (message "Re-Generate init.el finish." result))
                             (expand-file-name "makeinit.sh" user-emacs-directory)))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* Configurations
** Appearance
*** Theme

#+begin_src emacs-lisp
(use-package color-theme-sanityinc-tomorrow
    :init
      (load-theme 'sanityinc-tomorrow-night :no-confirm))
#+end_src

*** spaceline

[[https://github.com/TheBB/spaceline][GitHub - TheBB/spaceline: Powerline theme from Spacemacs]]

#+BEGIN_SRC emacs-lisp
  (use-package spaceline-config
    :ensure spaceline
    :commands spaceline-spacemacs-theme
    :init
    (setq-default powerline-default-separator 'wave
                  spaceline-minor-modes-separator ""
                  spaceline-workspace-numbers-unicode t
                  spaceline-window-numbers-unicode t)
    (spaceline-spacemacs-theme)
    )
#+END_SRC

*** Change cursor color according to mode

#+BEGIN_SRC emacs-lisp
  (defvar hcz-set-cursor-color-color "")
  (defvar hcz-set-cursor-color-buffer "")
  (defun hcz-set-cursor-color-according-to-mode ()
    "change cursor color according to some minor modes."
    ;; set-cursor-color is somewhat costly, so we only call it when needed:
    (let ((color
           (if buffer-read-only "white"
             (if overwrite-mode "#5599aa"
               "#f99157"))))
      (unless (and
               (string= color hcz-set-cursor-color-color)
               (string= (buffer-name) hcz-set-cursor-color-buffer))
        (set-cursor-color (setq hcz-set-cursor-color-color color))
        (setq hcz-set-cursor-color-buffer (buffer-name)))))

  (add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+END_SRC

*** fringe

改得細一點，預設值是 8 pixel

#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)
#+END_SRC

*** beacon

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :diminish ""
    :init
    (beacon-mode 1))
#+END_SRC

*** Line Numbers

from 26.1, using ~(setq display-line-numbers 'relative)~ to display line number.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook
            '(lambda ()
               (setq display-line-numbers 'relative)))
#+END_SRC

*** Highlight FIXME, TODO in program mode

#+BEGIN_SRC emacs-lisp
  (defun font-lock-comment-annotations ()
    "Highlight a bunch of well known comment annotations.
  This functions should be added to the hooks of major modes for programming."

    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))

  (add-hook 'prog-mode-hook 'font-lock-comment-annotations)
#+END_SRC

*** 將滑鼠游標移至右上角

#+BEGIN_SRC emacs-lisp
  (mouse-avoidance-mode 'banish)
#+END_SRC

*** Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

** Chinese setup
*** don't use input-method via C-\
#+BEGIN_SRC emacs-lisp
  (unbind-key "C-\\")
#+END_SRC

*** pangu-spacing

自動在中英文字間加入空白，以利 123 閱讀

#+BEGIN_SRC emacs-lisp
  (use-package pangu-spacing
    :diminish ""
    :init
    (global-pangu-spacing-mode 1)

    :config
    ;; disable pangu-space in some modes
    (dolist (mm '(wdired-mode dired-mode eww-mode elfeed-search-mode elfeed-show-mode))
      (add-to-list 'pangu-spacing-inhibit-mode-alist mm))

    ;; Always insert `real' space
    (dolist (mm '(markdown-mode-hook rst-mode-hook org-mode-hook))
      (add-hook mm '(lambda()
                      (set (make-local-variable 'pangu-spacing-real-insert-separtor) t)))))
#+END_SRC

*** fcitx

進入 normal mode 時，自動切換至英文輸入模式

#+BEGIN_SRC emacs-lisp
  (use-package fcitx
    :init (fcitx-aggressive-setup))
#+END_SRC

** Basic settings
*** Set prefer coding to utf-8

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq system-time-locale "en_US" )
#+END_SRC
*** use noflet no defer
#+BEGIN_SRC emacs-lisp
  (use-package noflet
    :defer 0)
#+END_SRC

*** Don't ask me when close emacs with process is running

#+BEGIN_SRC emacs-lisp
  (require 'noflet)
  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (noflet ((process-list ())) ad-do-it))
#+END_SRC

*** Don't ask me when kill process buffer

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

*** Delete trailing whitespace before save buffer

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** set tab width

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
  (defvaralias 'c-basic-offset 'tab-width)
  (setq sh-basic-offset 4)
#+END_SRC

*** ethan-wspace

Takes care of trailing whitespaces (removal, highlighting)
[[https://github.com/glasserc/ethan-wspace][GitHub - glasserc/ethan-wspace: the definitive emacs customizations for people who are OCD about whitespace]]

#+BEGIN_SRC emacs-lisp
  (use-package ethan-wspace
    :diminish "🄣"
    :init
    (global-ethan-wspace-mode 1)
    :config
    (progn
      ;; Turn off `mode-require-final-newline' since ethan-wspace
      ;; supersedes `require-final-newline'.
      (setq mode-require-final-newline nil)

      ;; Prevent etha-wspace touch my TAB on makefile mode
      (add-hook 'makefile-mode-hook
                '(lambda()
                   (setq ethan-wspace-errors (remove 'tabs ethan-wspace-errors))))

      ;; Ignore no trailing newline error
      (setq-default ethan-wspace-errors (remove 'no-nl-eof ethan-wspace-errors))))
#+END_SRC

*** Default truncate lines
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

*** Bell off
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

*** Shorten answer
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Show keystrokes in progress
#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

*** Remove text in active region if inserting text
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Subword mode

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
  (diminish 'subword-mode)
#+END_SRC

*** Clipboard

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
        select-enable-primary t)
#+END_SRC

*** Add the system clipboard to the Emacs kill-ring

http://pragmaticemacs.com/emacs/add-the-system-clipboard-to-the-emacs-kill-ring/

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

*** no backup file

#+begin_src emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+end_src

** Utilities
*** text scale adjust

~C-+~ 進入文字大小調整模式
用 +, -, 0 調整

#+BEGIN_SRC emacs-lisp
  (setq-default text-scale-mode-step 1.1)
  (bind-key "C-+" 'text-scale-adjust)
#+END_SRC

*** opencc-buffer

#+BEGIN_SRC emacs-lisp
  (defun opencc-buffer ()
    "Convert chinese from simplified to variants and phrases of Taiwan"
    (interactive)
    (set-buffer-file-coding-system 'utf-8-unix)

    (let ((opencc-conv-temp-file (temporary-file-name "opencc.tmp" )))
      (let ((str-for-opencc (buffer-substring-no-properties (point-max) 1)))
        (with-temp-file opencc-conv-temp-file
          (insert str-for-opencc "\n")))

      (let ((current-point (point))
            (result (shell-command-to-string
                     (concat "opencc -c s2twp.json -i " opencc-conv-temp-file))))

        (erase-buffer)
        (insert result)
        (goto-char current-point))))

  (bind-key "C-c fo" 'opencc-buffer)

#+END_SRC

*** TODO opencc-region

#+BEGIN_SRC emacs-lisp :tangle no
(defun opencc-region ())
#+END_SRC

*** TODO sdcv

*copyright issue*

ref: http://lifegoo.pluskid.org/wiki/EmacsStardict.html

#+BEGIN_SRC emacs-lisp :tangle no
  (bind-key "C-c s" 'kid-sdcv-to-buffer)

  (defun kid-sdcv-to-buffer ()
    (interactive)
    (let ((word (if mark-active
                    (buffer-substring-no-properties (region-beginning) (region-end))
		  (current-word nil t))))
      (setq word (read-string (format "Search the dictionary for (default %s): " word)
                              nil nil word))

      (set-buffer (get-buffer-create "*sdcv*"))
      (buffer-disable-undo)
      (erase-buffer)

      (let ((process (start-process-shell-command "sdcv" "*sdcv*" "sdcv" "-n" word)))
	(set-process-sentinel
	 process
	 (lambda (process signal)
           (when (memq (process-status process) '(exit signal))
             (unless (string= (buffer-name) "*sdcv*")
               (setq kid-sdcv-window-configuration (current-window-configuration))
               (switch-to-buffer-other-window "*sdcv*")
               (local-set-key (kbd "d") 'kid-sdcv-to-buffer)
               (local-set-key (kbd "q") (lambda ()
                                          (interactive)
                                          (bury-buffer)
                                          (unless (null (cdr (window-list))) ; only one window
                                            (delete-window)))))
             (goto-char (point-min))))))))
#+END_SRC

*** moedict 萌典

#+BEGIN_SRC emacs-lisp
  (use-package moedict
    :quelpa (moedict :fetcher github :repo "kuanyui/moedict.el")
    :ensure helm
    :ensure esqlite
    :bind ("C-c m" . moedict)
    :config
    (setq browse-url-chromium-program "google-chrome-stable"))
#+END_SRC

**** TODO using moedict by ivy

#+BEGIN_SRC emacs-lisp :tangle no
:noweb-ref moedict-config
  (defun counsel-moedict ()
    "moedict"
(interactive)
(let ((initial-input (word-at-point)))
      (ivy-read moedict-prompt
		'(lambda (x) (counsel-moedict-function x))
		:initial-input initial-input
		:dynamic-collection t
		:action #'moedict-lookup-and-show-in-buffer
		)))

  (defun counsel-moedict-function (&optional string)
    (if (null string)
	(setq string ""))
    (or (unless (string= "" string)
	  (moedict-get-candidates-list string))
	(list nil)))
#+END_SRC

*** epub reader

[[https://github.com/wasamasa/nov.el][GitHub - wasamasa/nov.el: Major mode for reading EPUBs in Emacs]]

Open the EPUB file with C-x C-f ~/novels/novel.epub, scroll with ~SPC~
and switch chapters with ~n~ and ~p~. More keybinds can be looked up
with ~F1 m~.

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :mode "\\.epub\\'"
    :bind (:map nov-mode-map
                ("j" . next-line)
                ("k" . previous-line)
                ("d" . scroll-up-command)
                ("e" . scroll-down-command)
                ("u" . scroll-down-command)))
#+END_SRC

*** pdf-tools

- 如果出現「No executable ‘epdfinfo’ found」錯誤訊息，則執行一次 =M-x pdf-tools-install= 即可。
- 如果出現「lib... not found」，則 uninstall pdf-tools 後 re-install，再執行 =M-x pdf-tools-install= 。

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :bind (:map pdf-view-mode-map
		("j" . pdf-view-next-line-or-next-page)
		("k" . pdf-view-previous-line-or-previous-page)
		("e" . pdf-view-scroll-down-or-previous-page)
		("u" . pdf-view-scroll-down-or-previous-page)
		("d" . pdf-view-scroll-up-or-next-page)
		("H" . pdf-view-next-page)
		("L" . pdf-view-previous-page)
		("=" . pdf-view-fit-width-to-window)
		("-" . pdf-view-shrink)
		("+" . pdf-view-enlarge))
    :commands (pdf-view-mode)
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
      (setq pdf-view-continuous t)
      ))
#+END_SRC

*** TODO Send file to kindle by wpub
**** utility for async send file by wpub

#+BEGIN_SRC emacs-lisp
  (defun async-wpub (url &optional file-type opencc)
    (let* ((cmd-opencc (if opencc (if (y-or-n-p "Convert to Traditional Chinese?") "-o" "") ""))
	   (cmd-type (if file-type (format "-f %s" file-type) ""))
	   (cmd-wpub (if url (format "wpub %s %s '%s'" cmd-opencc cmd-type url) nil)))

      (if cmd-wpub
	  (progn
	    (message "%s" cmd-wpub)
	    (start-file-process-shell-command "async-wpub"
					      "*async-wpub*"
					      cmd-wpub)))))
#+END_SRC

**** send org-mode file to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun org-to-kindle ()
    "Send current buffer to kindle via wpub.py"

    (interactive)

    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (let ((wpub-temp-file (temporary-file-name (buffer-name)))
                (str (buffer-substring-no-properties (point-max) 1)))

            (with-temp-file wpub-temp-file
              (insert str "\n"))

            (async-wpub wpub-temp-file "org")))

      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

**** send html file to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun html-file-to-kindle (fname)
    (async-wpub fname "html" t))

#+END_SRC

**** send url to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun url-to-kindle (url)
    (if url
        (async-wpub url nil t)
      (message "url: %s" url)))
#+END_SRC

**** eww url to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle ()
    "send the content of current url to kindle via wpub"

    (interactive)
    (url-to-kindle (eww-current-url))
    )
#+END_SRC

**** eww send current page kindle

#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle-directly ()
    (interactive)

    (let ((fname (eww-temp-file-name-html (eww-current-url))))
      (eww-make-temp-file-source fname)
      (html-file-to-kindle fname)))
#+END_SRC

***** write eww source to temp file

#+BEGIN_SRC emacs-lisp
  (defun eww-temp-file-name-html (fname)
    (temporary-file-name  (concat (md5 fname) ".html")))

  (defun eww-make-temp-file-source (temp-file-name)
    (let ((source (eww-current-source)))
      (with-temp-file temp-file-name
    (insert (string-as-multibyte source)))))
#+END_SRC

**** elfeed send page to kindle

#+BEGIN_SRC emacs-lisp

  (defun elfeed-search-to-kindle ()
    "send current content to kindle"

    (interactive)
    (url-to-kindle (get-elfeed-search-url)))

  (defun elfeed-show-to-kindle ()
    "send current content to kindle"

    (interactive)
    (url-to-kindle (get-elfeed-show-url)))

#+END_SRC

**** send url or org to kindle

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c ok" 'send-url-or-org-to-kindle)
  (require 'eww)
  (defun send-url-or-org-to-kindle ()
    "Send content of current buffer to kindle"
    (interactive)
    (cond
     ((not (eq (eww-current-url) nil)) (eww-to-kindle-directly))
     ((eq (current-buffer-mode) 'org-mode) (org-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-search-mode) (elfeed-search-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-show-mode) (elfeed-show-to-kindle))
     (t (message "%s" "Can't send this page to kindle."))))
#+END_SRC

**** send url-at-point to kindle

#+BEGIN_SRC emacs-lisp
  (defun send-url-to-kindle-at-point ()
    "send contents in url-at-point to kindle"

    (interactive)

    (let ((url (get-text-property (point) 'shr-url)))
      (if url
          (url-to-kindle (get-text-property (point) 'shr-url))
        (message "%s" url)
        )))
#+END_SRC
*** TODO Using pandoc to convert org, markdown file
**** get major mode of current buffer

#+BEGIN_SRC emacs-lisp
  (defun current-buffer-mode ()
    "Return the major-mode associated with current buffer."

    (with-current-buffer (buffer-name)
      major-mode))
#+END_SRC

**** convert org-mode to pdf via pandoc
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c op" 'org-to-pdf)

  (defun org-to-pdf ()
    "Conver org to pdf and open the pdf file."

    (interactive)
    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (let* ((pdf-name (concat (file-name-sans-extension buffer-file-name) ".pdf")))

            (message "convert to %s" (file-name-nondirectory pdf-name))

            (let* ((latex-engin "xelatex")
                   (template "/home/mario/.pandoc/default.latex")
                   (result (shell-command
                            (format "pandoc %s --latex-engine %s --template %s -s -o %s"
                                    buffer-file-name
                                    latex-engin
                                    template
                                    pdf-name
                                    ))))
              (if (eq result 0)
                  (find-file pdf-name)
                (message result)))
            ))
      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

**** convert markdown to orgmode via pandoc

#+BEGIN_SRC emacs-lisp
  (defun md-to-org ()
    "Convert markdown to org for edit. Especially for evernote/geeknote."

    (interactive)
    (if (eq (current-buffer-mode) 'markdown-mode)
        (let* ((default-directory "/mnt/lvm-data/Documents/")
               (md-buffer-name (buffer-name))
               (md-file-name (buffer-file-name))
               (md-org-buffer (find-file (read-file-name "" default-directory)))
               (md-org-file-name (buffer-file-name)))

          (if (not (file-exists-p md-org-file-name))
              (progn
                (shell-command (format "pandoc -f markdown -t org -o %s %s"
                                       md-org-file-name
                                       md-file-name))
                (revert-buffer nil t)
                (goto-char (point-min))
                (insert "#+TITLE:\n")
                (save-buffer)
                (kill-buffer md-buffer-name))
            (message "%s is already exist." md-org-file-name)))
      (message "Current buffer must be 'markdown-mode'!")))
#+END_SRC

**** save buffer as org-mode and bind key as "C-c oo"

 bind key "C-c oo" to write current page of eww as orgmode
 or markdown to org.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c oo" 'write-buffer-as-orgmode)

  (defun write-buffer-as-orgmode ()
  (interactive)
    (cond
     ((eq (current-buffer-mode) 'markdown-mode) (md-to-org))
     ((eq (current-buffer-mode) 'eww-mode) (eww-to-org))
     (t (message "Current mode must be markdown or eww"))))
#+END_SRC
*** string/starts-with and ends-with

EmacsWiki: Elisp Cookbook
https://www.emacswiki.org/emacs/ElispCookbook

#+BEGIN_SRC emacs-lisp
  (defun string/starts-with (string prefix)
    "Return t if STRING starts with prefix."
    (and (string-match (rx-to-string `(: bos ,prefix) t)
               string)
     t))

  (defun string/ends-with (string suffix)
    "Return t if STRING ends with SUFFIX."
    (and (string-match (rx-to-string `(: ,suffix eos) t)
               string)
     t))
#+END_SRC

*** return temporary file name
#+BEGIN_SRC emacs-lisp
  (defun temporary-file-name (fname)
    (expand-file-name fname temporary-file-directory))
#+END_SRC
* Operation system
** File System Management
*** Dired: the most powerfull file management tool

Ref:
- https://github.com/lunaryorn/.emacs.d/blob/master/init.el
- http://kuanyui.github.io/2014/06/21/dired-tutorial-and-essential-configs/
- http://pragmaticemacs.com/category/dired/

We recently looked at replacing text in buffers.
Using dired, it is possible to do this in many files in a directory.
Start dired and mark files as described here.
Then use Q to run query-replace on all marked files.

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
		("s" . my/counsel-dired-sort)
		("f" . dired-find-name-in-current-directory)
		("\)" . dired-omit-and-remember))
    :config
    <<dired-config>>)
#+END_SRC
**** usefull keybinding

***** copy file name

- w selected file name
- M-0 w 絶對路徑

**** Dired tries to guess a default target directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-dwim-target t)
#+END_SRC

**** Revert on re-visiting

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-auto-revert-buffer t)
#+END_SRC

**** -F marks links with @

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-ls-F-marks-symlinks t)
#+END_SRC

**** set dired listing switches

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  ;; dired-listing-switches "-alh"
  (setq dired-listing-switches "--group-directories-first -alh")
  ;; dired-listing-switches "-lFaGh1v --group-directories-first"
#+END_SRC

**** Don't ask me question when recursively copy/delete file(s)

always: 表示永不詢問。
top: 表示同一批檔案只詢問一次。

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-recursive-copies  'always
	dired-recursive-deletes 'top)
#+END_SRC

**** sorting current directoy

會先問你要根據什麼屬性排序，而且紀錄下排序狀態，不會跨 buffer 就不見了。

#+BEGIN_SRC emacs-lisp
  (defconst sorting-action '(("name" "")
			     ("size" "S")
			     ("extension" "X")
			     ("access time" "ut")
			     ("modified time" "t")
			     ("status change time" "ct")))

  (defun sort-dir (sort-item)
    (dired-sort-other
     (concat dired-listing-switches
	     (car (cdr (assoc sort-item sorting-action))))))

  (defun my/counsel-dired-sort ()
    (interactive)

    (let ((sort-cmd (mapcar 'car sorting-action))
	  (sort-dir (lambda (sort-item)
		      (dired-sort-other
		       (concat dired-listing-switches
			       (car (cdr (assoc sort-item sorting-action))))))))

      (ivy-read "sort by" sort-cmd
		:preselect "name"
		:initial-input "^"
		:action #'sort-dir)))
#+END_SRC

**** dired omit mode enhancement

;; Dired Omit 加強:
;; 簡單來說，這個能夠紀錄下目前的「隱藏狀態」，所以當你按
;; C-x M-o 隱藏以.為開頭的檔案後，即使到了不同目錄下，以.開頭的檔案
;; 依舊是處於隱藏狀態，直到你重新按 C-x M-o 為止。

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
(setq dired-omit-files "^\\...+$")

(defvar v-dired-omit t
  "If dired-omit-mode enabled by default. Don't setq me.")

(defun dired-omit-and-remember ()
  "This function is a small enhancement for `dired-omit-mode', which will
        \"remember\" omit state across Dired buffers."

  (interactive)
  (setq v-dired-omit (not v-dired-omit))
  (dired-omit-auto-apply)
  (revert-buffer))

(defun dired-omit-auto-apply ()
  (setq dired-omit-mode v-dired-omit))

(add-hook 'dired-mode-hook 'dired-omit-auto-apply)
#+END_SRC

**** recursively find files under current directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
(defun dired-find-name-in-current-directory ()
  (interactive)
  (find-name-dired default-directory
                   (format "*%s*" (read-from-minibuffer "Pattern: ")))
  (set-buffer-multibyte t))
(setq find-name-arg "-iname")
(setq find-ls-option '("-print0 | xargs -0 ls -ald" . ""))
#+END_SRC

**** TODO dired-rainbow

#+BEGIN_SRC emacs-lisp :tangle no
:noweb-ref dired-config
(use-package dired-rainbow
    :commands dired-rainbow-define dired-rainbow-define-chmod
    :init
    (dired-rainbow-define dotfiles "gray" "\\..*")

    (dired-rainbow-define web "#4e9a06" ("htm" "html" "xhtml" "xml" "xaml" "css" "js"
                                         "json" "asp" "aspx" "haml" "php" "jsp" "ts"
                                         "coffee" "scss" "less" "phtml"))
    (dired-rainbow-define prog "yellow3" ("el" "l" "ml" "py" "rb" "pl" "pm" "c"
                                          "cpp" "cxx" "c++" "h" "hpp" "hxx" "h++"
                                          "m" "cs" "mk" "make" "swift" "go" "java"
                                          "asm" "robot" "yml" "yaml" "rake" "lua"))
    (dired-rainbow-define sh "green yellow" ("sh" "bash" "zsh" "fish" "csh" "ksh"
                                             "awk" "ps1" "psm1" "psd1" "bat" "cmd"))
    (dired-rainbow-define text "yellow green" ("txt" "md" "org" "ini" "conf" "rc"
                                               "vim" "vimrc" "exrc"))
    (dired-rainbow-define doc "spring green" ("doc" "docx" "ppt" "pptx" "xls" "xlsx"
                                              "csv" "rtf" "wps" "pdf" "texi" "tex"
                                              "odt" "ott" "odp" "otp" "ods" "ots"
                                              "odg" "otg"))
    (dired-rainbow-define misc "gray50" ("DS_Store" "projectile" "cache" "elc"
                                         "dat" "meta"))
    (dired-rainbow-define media "#ce5c00" ("mp3" "mp4" "MP3" "MP4" "wav" "wma"
                                           "wmv" "mov" "3gp" "avi" "mpg" "mkv"
                                           "flv" "ogg" "rm" "rmvb"))
    (dired-rainbow-define picture "purple3" ("bmp" "jpg" "jpeg" "gif" "png" "tiff"
                                             "ico" "svg" "psd" "pcd" "raw" "exif"
                                             "BMP" "JPG" "PNG"))
    (dired-rainbow-define archive "saddle brown" ("zip" "tar" "gz" "tgz" "7z" "rar"
                                                  "gzip" "xz" "001" "ace" "bz2" "lz"
                                                  "lzma" "bzip2" "cab" "jar" "iso"))

    ;; boring regexp due to lack of imagination
    (dired-rainbow-define log (:inherit default :italic t) ".*\\.log")

    ;; highlight executable files, but not directories
    (dired-rainbow-define-chmod executable-unix "green" "-[rw-]+x.*"))
#+END_SRC

*** dired+

#+BEGIN_SRC sh
yaourt -S unzip unrar
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package highlight
    :quelpa (:fetcher url :url "https://www.emacswiki.org/emacs/download/highlight.el")
    )

  (use-package dired+
    :quelpa (:fetcher github :repo "emacsmirror/dired-plus")
    :init
    (diredp-toggle-find-file-reuse-dir 1)
    (setq dired-recursive-deletes 'always)

    (dolist (file `(("unrar x" "rar")
                    ("aegisub-3.2" "ass" "srt")
                    ("mediainfo"  "ogm" "avi" "mpg" "rmvb" "rm" "flv" "wmv" "mkv" "mp4" "m4v" "webm" "mp3")
                    ("mpv -playlist" "list" "pls")
                    ("kindlegen" "epub")
                    ("kmail" "mobi")
                    ("feh -F --auto-rotate *" "gif" "jpeg" "jpg" "tif" "png")
                    ("google-chrome-stable" "xml" "xhtml" "html" "htm" "mht")
                    ))
      (add-to-list 'dired-guess-shell-alist-default
                   (list (concat "\\." (regexp-opt (cdr file) t) "$")
                         (car file)))))
#+END_SRC

*** openwith

[[https://github.com/emacsmirror/openwith][GitHub - emacsmirror/openwith: Open files with external programs]]

#+BEGIN_SRC emacs-lisp
  (use-package openwith
    :init
    (openwith-mode t)
    (setq openwith-associations
          (list
           (list (openwith-make-extension-regexp '("flac" "mp3" "wav" "aiff" "m4a" "aac"))
                 "mpv" '(file))
           (list (openwith-make-extension-regexp '("avi" "flv" "mov" "mp4" "rmvb" "m2ts" "webm"
                                                   "mpeg" "mpg" "ogg" "wmv" "mkv"))
                 "mpv" '(file)))
          ))
#+END_SRC

*** dired-async

[[https://github.com/jwiegley/emacs-async][GitHub - jwiegley/emacs-async: Simple library for asynchronous processing in Emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package async
    :init
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1)
    (async-bytecomp-package-mode 1)
    (setq async-bytecomp-allowed-packages '(all)))
#+END_SRC

*** peep-dired

dired preview on other window

#+BEGIN_SRC emacs-lisp
  (use-package peep-dired
    :bind (:map dired-mode-map
                ("P" . peep-dired))
    :config
    (setq peep-dired-enable-on-directories t)
    (add-to-list 'peep-dired-ignored-extensions "m2ts"))
#+END_SRC

*** Making directories on the fly

SOURCE: http://mbork.pl/2016-07-25_Making_directories_on_the_fly

#+BEGIN_SRC emacs-lisp
  (defun make-parent-directory ()
    "Make sure the directory of `buffer-file-name' exists."
    (make-directory (file-name-directory buffer-file-name) t))

  (add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC

*** narrow dired to match filter binding to "/"

SOURCE: http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/

/: enter filter mode
q: exit filter mode

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC

*** Edit current buffer as root

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fR" 'edit-current-file-as-root)
  (defun edit-current-file-as-root ()
    "Edit the file that is associated with the current buffer as root"
    (interactive)
    (if (buffer-file-name)
        (progn
          (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
          (find-file file))
      (message "Current buffer does not have an associated file.")))
#+END_SRC

*** Delete current buffer file

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fD" 'delete-current-buffer-file)
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+END_SRC

*** Rename current Buffer and file

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fr"  'rename-current-buffer-file)
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
#+END_SRC

*** Clone current Buffer and file

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fc"  'clone-file-and-open)
  (defun clone-file-and-open (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+END_SRC

*** Add executable attribute to file

Actually this command is the same as =chmod +x= but it doesn't use any shell
command, it use emacs's logior function to change file attribute.

I only make =owener= can has executable permission, not change it for gourp or
others user.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fx" 'set-file-executable)
  (defun set-file-executable()
    "Add executable permissions on current file."

    (interactive)
    (when (buffer-file-name)
      (set-file-modes buffer-file-name
                      (logior (file-modes buffer-file-name) #o100))
      (message (concat "Made " buffer-file-name " executable"))))
#+END_SRC

*** Open recent directory with dired by ivy

Use fasd to open directory in current window.

#+BEGIN_SRC emacs-lisp
  (defun counsel-goto-recent-directory ()
    "Open recent directory with dired"
    (interactive)
    (unless recentf-mode (recentf-mode 1))
    (let ((collection
           (delete-dups
            (append (mapcar 'file-name-directory recentf-list)
                    ;; fasd history
                    (if (executable-find "fasd")
                        (split-string (shell-command-to-string "fasd -ld") "\n" t))))))
      (ivy-read "directories:" collection :action 'dired)))

  (bind-key "C-x C-\\" 'counsel-goto-recent-directory)
#+END_SRC

*** Open recent directory with dired in other window

Use fasd to open directory in another window and switch cursor to new
window.

if there are two panel already, then don't open the other window.
Just switch to another window and open target directory.

#+BEGIN_SRC emacs-lisp
  (defun counsel-goto-recent-directory-other-window ()
    "goto recnet directory other window."
    (interactive)
    (let ((old-buffer-name (buffer-name))
          (new-directory-name (counsel-goto-recent-directory)))
      (message "open recent dir old:%s new:%s" old-buffer-name new-directory-name)
      (if (eq (count-windows) 1)
          (split-window-right))

      (switch-to-buffer old-buffer-name)
      (other-window 1)
      (find-file new-directory-name)))
#+END_SRC

*** open usually files by hotkey

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fs" 'switch-to-scratch-buffer)
  (bind-key "C-c fi" 'find-file-init-org)
  (bind-key "C-c fm" 'find-file-message)

  (defun find-file-message ()
    (interactive)
    (find-file-or-buffer "*Messages*"))

  (defun find-file-init-org ()
    (interactive)
    (find-file user-emacs-init-org))
#+END_SRC

*** find-file usually files by ivy

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c ff" 'find-file-usually-files)
  (defun find-file-usually-files ()
    "open usually using files."
    (interactive)
    ;; (require 'org)
    (require 'elfeed-org)
    (let ((usually-files (list user-emacs-init-org
                               org-default-inbox-file
                               ;; org-default-notes-file
                               "*Messages*"
                               "*scratch*")))

      (ivy-read "find file:" usually-files
                :action #'find-file-or-buffer)))

  (defun find-file-or-buffer (file-or-buffer-name)
    (cond
     ((string= file-or-buffer-name "*scratch*")
      (switch-to-scratch-buffer))
     ((get-buffer file-or-buffer-name)
      (switch-to-buffer file-or-buffer-name))
     ((file-exists-p file-or-buffer-name)
      (find-file file-or-buffer-name))
     (t
      (message "Not found %s" file-or-buffer-name))))
#+END_SRC

*** save-place

自動記錄每一個檔案，cursor 所在的位置。
下次再開啟這個檔案時，cursor 會自動回到上次的地方。

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (progn
      (setq save-place-file (expand-file-name "places" user-cache-directory))
      (save-place-mode 1)))
#+end_src

*** recentf

Recentf is a minor mode that builds a list of recently opened files.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :init
  (progn
    (setq recentf-save-file (expand-file-name "recentf" user-cache-directory))
    (recentf-mode 1)
  :config
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 10)))
#+end_src

*** dired
**** TODO Dired bookmarks

are especially handy if you use Bookmark+
<2016-12-01 Thu 18:16>

**** TODO dired hacks                                            :READING:

ranger copy/paste files

https://github.com/Fuco1/dired-hacks
<2017-08-02 三 09:51>

**** TODO ibuffer/dired binding consistent

<2017-08-11 Fri 20:26:37>

**** TODO dired color theme monika?

**** TODO Using Emacs 38 - dired http://cestlaz.github.io/posts/using-emacs-38-dired/

** Buffer Management                                                :buffer:
*** ibuffer

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package ibuffer
    :bind (("C-x C-b" . ibuffer)
           :map ibuffer-mode-map
           ("c" . kill-all-buffer-but-ibuffer))
    :config
    <<ibuffer-config>>)
#+END_SRC

**** turn off ibuffer-show-empty-filter-groups

ref: [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][Tips for using Emacs Ibuffer]]

Turning off ibuffer-show-empty-filter-groups is particularly useful,
because the empty filter groups can really clutter things up.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ibuffer-config
  (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

**** ibuffer-auto-mode

ref: [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][Tips for using Emacs Ibuffer]]

ibuffer-auto-mode is a minor mode that automatically keeps the buffer
list up to date. I turn it on in my ibuffer-mode-hook:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ibuffer-config
  (add-hook 'ibuffer-mode-hook
            '(lambda ()
               (ibuffer-auto-mode 1)))
#+END_SRC

*** ibuffer-vc

[[https://github.com/purcell/ibuffer-vc][GitHub - purcell/ibuffer-vc: Let Emacs' ibuffer-mode group files by git project etc., and show file state]]

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :init
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode
                            'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))

    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  filename-and-process))))
#+END_SRC

*** persistent-scratch

ref: [[http://pragmaticemacs.com/emacs/a-persistent-scratch-buffer/][A persistent scratch buffer | Pragmatic Emacs]]

#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :init
  (persistent-scratch-setup-default))
#+END_SRC

*** Show current buffer-file information

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fn" 'my/file-info)

  (defun my/file-info ()
    "Show current buffer information."
    (interactive)
    (if (buffer-file-name (current-buffer))
        (progn
          (let* ((file-name (buffer-file-name (current-buffer)))
                 (f-attr (file-attributes file-name))
                 (f-size (nth 7 f-attr))
                 (f-mode (nth 8 f-attr))
                 (mes1 (format "file path: %s\n" file-name))
                 (mes2 (format "file size: %s byte\n" f-size))
                 (mes3 (format "file type: %s\n" f-mode))
                 (mes4 (count-words--message "this file" (point-min) (point-max)))
                 (mess (concat mes1 mes2 mes3 mes4)))
            (message "%s" mess)))
      nil))
#+END_SRC

*** set buffer to utf-8-unix

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fu" 'buffer-to-utf-8-unix)

  (defun buffer-to-utf-8-unix()
    (interactive)
    (set-buffer-file-coding-system 'utf-8-unix))
#+END_SRC

*** cycle revert buffer decoding

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fa" 'my/cycle-revert-buffer-decoding)

  (defun my/cycle-revert-buffer-decoding ()
    (interactive)

    (let* ((decoders [utf-8 gb18030 big5 gbk])
	   (index-before
	    (if (get 'my/cycle-revert-buffer-decoding 'state)
		(get 'my/cycle-revert-buffer-decoding 'state)
	      0))
	   (index-after (% (+ index-before 1) (length decoders)))
	   (next-decoder (aref decoders index-after)))
      (message "%s %s" decoders next-decoder)
      (put 'my/cycle-revert-buffer-decoding 'state index-after)
      (revert-buffer-with-coding-system next-decoder)))
#+END_SRC

*** revert-buffer

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fv" 'revert-buffer)

  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*"))
#+END_SRC

*** set unique buffer name

Add parts of each file's directory to the buffer name if not unique

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :ensure nil
  :init
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

*** TODO Next/Previous User Buffer

http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html
<2016-06-19 日 16:23>

**** TODO cycle switch buffer in current project/directory or user buffer.

<2017-02-04 六 18:10>
*** Switch to previous buffer

#+BEGIN_SRC emacs-lisp
  (bind-key "M-o" 'mode-line-other-buffer)
#+END_SRC

*** Save files and exit (current file or emacs)

#+begin_src emacs-lisp
  (bind-key "C-x k" 'kill-this-buffer)
  (bind-key "C-x C-c" 'save-buffers-kill-emacs)
#+END_SRC

*** Create and switch to *scratch*

#+BEGIN_SRC emacs-lisp
  (defun switch-to-scratch-buffer ()
    "switch buffer to scratch if not exist then create new one"
    (interactive)
    (unless (get-buffer "*scratch*")
      (with-current-buffer (get-buffer-create "*scratch*")
        (insert initial-scratch-message)
        (lisp-interaction-mode)))
    (switch-to-buffer "*scratch*"))
#+END_SRC

** Window Management                                                :window:
*** eyebrowse

default keybindings

+ M-x eyebrowse-mode  -- toggle eyebrowse mode
+ C-x C-w 0..9 -- switch to workspace 0..9
+ C-x C-w '    -- switch to last workspace
+ C-x C-w "    -- close current workspace
+ C-x C-w .    -- switch to workspace N via ivy
+ C-x C-w ,    -- rename workspace
+ C-x C-w </>  -- switch to previous/next workspace

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
:bind ("C-x C-w" . eyebrowse-mode))
#+END_SRC

*** winner-mode

Undo/redo window configuration with C-c <left>/<right>

#+BEGIN_SRC emacs-lisp
(use-package winner)
#+END_SRC

*** ace-window

[[https://github.com/abo-abo/ace-window][GitHub - abo-abo/ace-window: Quickly switch windows in Emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("C-x o" . ace-window)
    :init
    (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 2.0))))))
#+END_SRC

*** swap-windows

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x x" 'z/swap-windows)
  (defun z/swap-windows ()
    "swap windows"
    (interactive)
    (ace-swap-window)
    (aw-flip-window))
#+END_SRC

*** Minibuffer                                                 :minibuffer:

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package minibuffer
  :ensure nil
  :config
  <<minibuffer-config>>)
#+END_SRC

**** Make cursor in minibufer use bar shape

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))
#+END_SRC

**** Some helper function to let me insert quick in minibuffer

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config

  (defun my/minibuffer-insert (p)
    (kill-line 0) (insert p))

  (defun my/minibuffer-switch-to-ramdisk ()
    "Insert ramdisk path according to system type"
    (interactive)
    (my/minibuffer-insert user-ramdisk-directory))

  (defun my/minibuffer-switch-to-home ()
    "Insert $HOME path."
    (interactive)
    (my/minibuffer-insert (file-name-as-directory (getenv "HOME"))))

  (defun my/minibuffer-switch-to-rootdir ()
    "Insert / path."
    (interactive)
    (my/minibuffer-insert "/"))

  (defun my/minibuffer-switch-to-tramp ()
    "Insert /ssh:."
    (interactive)
    (my/minibuffer-insert "/ssh:"))

  (defun my/minibuffer-switch-to-vm ()
    "Insert /ssh:vm:."
    (interactive)
    (my/minibuffer-insert "/ssh:vm:"))

  (defun my/minibuffer-switch-to-cluster ()
    "Insert /ssh:cluster:."
    (interactive)
    (my/minibuffer-insert "/ssh:cluster:"))
#+END_SRC

**** Save history of minibuffer :tangle no :noweb-ref minibuffer-config

When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.  When Savehist mode is enabled
for the first time in an Emacs session, it loads the previous
minibuffer history from ‘savehist-file’.

#+BEGIN_SRC emacs-lisp  :tangle no :noweb-ref minibuffer-config
  (use-package savehist
    :init
    (setq savehist-file (expand-file-name "savehist.dat" user-cache-directory))
    (savehist-mode 1))
#+END_SRC

**** Setup Keybindings                                        :keybinding:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (bind-keys :map minibuffer-local-map
             ("C-w" . backward-kill-word)
             ("M-p" . previous-history-element)
             ("M-n" . next-history-element)
             ("C-g" . minibuffer-keyboard-quit)
             ("M-t" . my/minibuffer-switch-to-ramdisk)
             ("M-h" . my/minibuffer-switch-to-home)
             ("M-/" . my/minibuffer-switch-to-rootdir)
             ("M-s" . my/minibuffer-switch-to-tramp)
             ("M-v" . my/minibuffer-switch-to-vm)
             ("M-c" . my/minibuffer-switch-to-cluster))
#+END_SRC

**** Save minibuffer history

When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (savehist-mode 1)
  (setq history-length 1000)
#+END_SRC

*** popwin

popwin for undo-tree and multi-term only

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    ;; :init
    ;; (setq helm-popwin
    ;; '(("*Flycheck errors*" :height 10)
    ;; ("*Helm Find Files*" :height 0.3)
    ;; ("^\*helm.+\*$" :regexp t :height 15)))
    :config
    (popwin-mode 1)
    (push '(" *undo-tree*" :width 0.2 :position right) popwin:special-display-config))
#+END_SRC

** call external terminal

call external terminal and cd to working directory of current buffer.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x t" '(lambda()
                       (interactive)
                       (call-process "xterm" nil 0 nil
                                     "-e"
                                     "export SHELL=/usr/bin/fish; export XTERM_SHELL=$SHELL; fish")))
#+END_SRC

** reload emacs' "init.el"

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fR" 'reload-emacs)

  (defun reload-emacs ()
    "reload my emacs settings"
    (interactive)
    (load-file emacs-init-el)
    (delete-other-windows))
#+END_SRC

** Evaluate buffer until error occured

#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
    "Evaluate emacs buffer until error occured."
    (interactive)
    (goto-char (point-min))
    (while t (eval (read (current-buffer)))))
#+END_SRC

** keybinding of delete frame

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x w" 'delete-frame)
#+END_SRC

* Text editing
** Bindings

| key             | function                                     |
|-----------------+----------------------------------------------|
| C-k             | kill to end of line                          |
| C-<backspace>   | kill-line-backward                           |
| C-S-<backspace> | crux-kill-whole-line                         |
| <backspace>     | hungry-delete-backward                       |
| C-d, <del>      | hungry-delete-forward                        |
| M-d             | kill-word                                    |
| M-<del>         | backward-kill-word                           |
| M-k             | sp-backward-kill-sexp                        |
| C-M-k           | sp-kill-sexp                                 |
|-----------------+----------------------------------------------|
| C-c d           | duplicate-current-line-or-region             |
| C-c M-d         | duplicate-and-comment-current-line-or-region |
|-----------------+----------------------------------------------|
| <Home>, C-a     | begin-of-line                                |
| C-M-f           | sp-forword-sexp                              |
| C-M-b           | sp-backward-sexp                             |
| C-M-n           | sp-next-sexp                                 |
| C-M-p           | sp-previous-sexp                             |
| C-M-u           | backward-up-list                             |
| C-M-d           | forward-list                                 |
*** discover-my-major

[[https://github.com/steckerhalter/discover-my-major][discover-my-major]] make you discover key bindings and their meaning for the
current Emacs major mode.

GitHub: https://github.com/steckerhalter/discover-my-major

#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-m" . discover-my-mode)))
#+END_SRC
*** Which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish ""
    :init
    (progn
      (setq which-key-idle-delay 0.5)
      (which-key-mode)
      (which-key-setup-side-window-bottom)
      (setq which-key-side-window-max-width 0.25)))
#+END_SRC
*** Unbind keys

#+BEGIN_SRC emacs-lisp
  (unbind-key "C-z")
  (unbind-key "C-x C-z")
  (unbind-key "C-x m")
#+END_SRC
** crux

[[https://github.com/bbatsov/crux#keybindings][GitHub - bbatsov/crux: A Collection of Ridiculously Useful eXtensions for Emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind (("C-x 4 t" . crux-transpose-windows)
	   ("C-<backspace>" . crux-kill-line-backwards)
	   ("C-c d" . crux-duplicate-current-line-or-region)
	   ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)
	   ([remap move-beginning-of-line] . crux-move-beginning-of-line)
	   ([remap kill-whole-line] . crux-kill-whole-line)
	   ))
#+END_SRC

** binding of <del>

總是記不住，C-del，M-del 的區別，乾脆用位子記，ctrl 向左刪，Alt 向右刪。

#+BEGIN_SRC emacs-lisp
  (bind-key "C-<delete>" 'backward-kill-word)
  (bind-key "M-<delete>" 'kill-word)
#+END_SRC

** Parentheses

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis)
  (bind-key "C-S-d" 'delete-pair)
#+END_SRC

** smartparens

[[https://github.com/Fuco1/smartparens][GitHub - Fuco1/smartparens: Minor mode for Emacs that deals with parens pairs and tries to be smart about it.]]

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish "⒫"
    :init
    (require 'smartparens-config)
    (smartparens-global-mode 1))
#+END_SRC

** TODO copying lines without selecting them

[[http://emacs-fu.blogspot.com/2009/11/copying-lines-without-selecting-them.html?m=1][emacs-fu: copying lines without selecting them]]

** turn on electric-pair-mode

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)

  (defmacro epm/add-mode-pairs (hook pairs)
    `(add-hook ,hook
               (lambda ()
                 (setq-local electric-pair-pairs (append electric-pair-pairs ,pairs))
                 (setq-local electric-pair-text-pairs electric-pair-pairs))))

  (epm/add-mode-pairs 'python-mode-hook '((?\' . ?\')))
  (epm/add-mode-pairs 'web-mode-hook '((?\' . ?\')))
  (epm/add-mode-pairs 'org-mode-hook '((?/ . ?/) (?= . ?=) (?~ . ?~) (?* . ?*) (?+ . ?+) (?_ . ?_)))
#+END_SRC

** turn off electric-quote-~ in emacs 25.1 and newer

#+BEGIN_SRC emacs-lisp
  (electric-quote-mode -1)
#+END_SRC

** hungry-delete

#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :diminish ""
    :init
    (global-hungry-delete-mode 1))
#+END_SRC

** move-text

用 M-up, M-down 移動當行或 region

[[https://github.com/emacsfodder/move-text][GitHub - emacsfodder/move-text: move current line or region up or down]]

#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :commands (move-text-default-bindings)
    :init
    (move-text-default-bindings))
#+END_SRC

** shift region left/right

ref: http://stackoverflow.com/questions/3156450/shift-a-region-or-line-in-emacs

#+BEGIN_SRC emacs-lisp
  (defun shift-text (distance)
    (if (use-region-p)
	(let ((mark (mark)))
          (save-excursion
            (indent-rigidly (region-beginning)
                            (region-end)
                            distance)
            (push-mark mark t t)
            (setq deactivate-mark nil)))
      (indent-rigidly (line-beginning-position)
		      (line-end-position)
		      distance)))

  (defun shift-right (count)
    "Shift text or region right."

    (interactive "p")
    (shift-text count))

  (defun shift-left (count)
    "shift text or region left."

    (interactive "p")
    (shift-text (- count)))

  (bind-key "C-x r <right>" 'shift-right)
  (bind-key "C-x r <left>" 'shift-left)
#+END_SRC

** undo-tree

用 M-x undo-tree-visualize (C-x u) 看 undo-tree，很直覺。

- undo-tree: ~C-x u~
- undo: ~C-_~
- redo: ~C-?~

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
      (global-undo-tree-mode)
    :config
      (setq undo-tree-history-directory-alist
	    `(("." . ,(file-name-as-directory (expand-file-name "undo-tree" user-cache-directory)))))
      (setq undo-tree-auto-save-history t))
#+END_SRC

** expand-region

+ M-= 擴充
+ 以 =, -, 0 調整大小
+ =M-SPC= 設定 mark

[[https://github.com/magnars/expand-region.el][GitHub - magnars/expand-region.el: Emacs extension to increase selected region by semantic units.]]

#+BEGIN_SRC emacs-lisp
  (bind-key "M-SPC" 'set-mark-command)
  (use-package expand-region
    :bind ("M-=" . er/expand-region))
#+END_SRC

** narrow or widen dwim

ref: [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim · Endless Parentheses]]

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
         ((ignore-errors (org-narrow-to-block) t))
         (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; (define-key endless/toggle-map "n"
  ;; #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing
  ;; keymap, that's how much I like this command. Only
  ;; copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
        nil)))
#+END_SRC

** iedit

[[https://github.com/victorhge/iedit][iedit]] let you edit multiple regions in the same way simultaneously.

Normal scenario of Iedit mode is like:

1) Highlight certain contents - by press C-; (The default key binding)
   All occurrences of a symbol, string or a rectangle in the buffer or
   a region may be highlighted corresponding to current mark, point and
   prefix argument.  Refer to the document of `iedit-mode’ for
   details.

2) Edit one of the occurrences The change is applied to other
   occurrences simultaneously.

3) Finish - by pressing C-; again

co-work with 'narrow or widen dwim' as above.

important keybindings:
- M-;       :: toggle selection
- C-'       :: toggle unmatched lines visible
- Tab/S-Tab :: goto next/prev occurrence
- M-R       :: replace
- M-H       :: narrow down to function
- M-I       :: narrow down to line
- M-{/}     :: expands the search region upwards/downwards by line
- C-h b     :: help keybindings

#+BEGIN_QUOTE
  =:demand== Prevent deferred loading in all cases.
  Make sure the package is loaded at startup
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :defer 0
    :init
    (custom-set-faces
     '(iedit-occurrence ((t (:inherit isearch))))))
#+END_SRC

** multi-cursor

ref: http://emacsrocks.com/e13.html

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ))
#+END_SRC

** ivy

看起來比 helm 好看些，輕量且快速。

useful keybindings:

+ M-i :: ivy-insert-current
+ M-j :: ivy-yank-word (word)
+ M-n :: ivy-next-history-element (symbol)
+ M-. :: ivy-next-history-element on ivy-minibuffer-map
+ C-M-n/p :: 上下移動選單中的遊標，檔案內容會跳到相對應的位置。

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ""
    :bind
    (("C-c C-r" . ivy-resume)
     :map ivy-minibuffer-map
     ("M-." . ivy-next-history-element))
    :init
    (progn
      (ivy-mode 1)
    :config
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (setq completion-in-region-function 'ivy-completion-in-region)))
#+END_SRC

** swiper

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind ("C-s" . swiper))
#+END_SRC

** counsel

使用以下流程，可以同時修改 project 中，多個檔案的相同文字。

1. C-x g   : counsel-rg
2. C-c C-o : counsel-occur
3. C-x C-q : edit buffer with wgrep
4. iedit   : multi edit
5. C-c C-c : exit wgrep

先安裝 ripgrep

#+BEGIN_SRC sh
yaourt -S ripgrep
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure
    :ensure wgrep
    :ensure rg
    :bind (("M-y" . counsel-yank-pop)
           ("M-x" . counsel-M-x)
           ("C-x f" . counsel-recentf)
           ("C-x l" . counsel-locate)
           ("C-x g" . counsel-rg)
           ("C-:" . counsel-company)
           ("C-x C-\\" . counsel-goto-recent-directory)
           ("C-x \\" . counsel-goto-recent-directory-other-window)
           :map ivy-minibuffer-map
           ("M-y" . ivy-next-line))
    :config
    (setq counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

#+END_SRC

** Company mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish " ⓐ"
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    ;; (global-company-mode t)
    :config
    (progn
      (setq company-idle-delay 0.1)
      (setq company-tooltip-limit 10)
      (setq company-minimum-prefix-length 2)
      (setq company-echo-delay 0)

      (add-to-list 'company-backends 'company-ispell t)))
#+END_SRC

*** Add quickhelp in company-mode

ref: https://github.com/expez/company-quickhelp

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :ensure
    :commands company-quickhelp-mode
    :init (company-quickhelp-mode 1))
#+END_SRC

*** keybindings

When the completion candidates are shown,
- <f1> to display the documentation for the selected candidate,
- C-w  to see its source. Not all back-ends support this.
- M-n/p select up/down
- <return> to complete
- <Tab> complete the common part
- C-s
- C-r
- C-o
- <f1> to dispaly the documentation
- <C-w> to see its source

** TODO Spell checking
*** Ispell

if want to use "hunspell", then must install hunspell and hunspell_en in OS.

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :config
    (progn
      (cond
       ((executable-find "aspell")
	(setq ispell-program-name "aspell")
	(setq ispell-extra-args   '("--sug-mode=slow"
                                    "--lang=en_US"
                                    "--ignore=2"
                                    "--ignore-case"
                                    "--run-together"
                                    "--run-together-limit=5"
                                    "--run-together-min=2")))
       ;; how to fire 'hunspell'?
       ((executable-find "hunspell")
	(setq ispell-program-name "hunspell")
	(setq ispell-extra-args   '("-d en_US"))
	(setq ispell-local-dictionary-alist
              '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
		("zh_TW" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))))

      (setq ispell-local-dictionary "en_US")
      (setq ispell-silently-savep t)))
#+END_SRC

*** TODO flyspell

=C-.= corrects word at point.
=C-,​= to jump to next misspelled word.
=M-$= correct word at point

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flyspell
    :ensure ispell
    :diminish " Ⓢ"
    :init
    (progn
      (add-hook 'prog-mode-hook #'turn-on-flyspell)
      (add-hook 'text-mode-hook #'turn-on-flyspell)

      (dolist (hook '(elfeed-search-mode-hook change-log-mode-hook log-edit-mode-hook))
	(add-hook hook (lambda () (flyspell-mode -1)))))

    :config (unbind-key "C-;" flyspell-mode-map))
#+END_SRC

*** flyspell-correct-ivy

#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct-ivy
    :ensure flyspell
    :ensure flyspell-correct
    :ensure ivy
    :bind (:map flyspell-mode-map
                ("M-$" . flyspell-correct-word-generic))
    :init
    (progn
      (setq flyspell-correct-interface 'flyspell-correct-ivy)
      ;; (bind-keys :map flyspell-mode-map
      ;; ("M-$" . flyspell-correct-word-generic))
      ;; bind flyspell-correct-word-generic
      ;; (define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-word-generic)
      ;; (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-previous-word-generic)
      ))
#+END_SRC

*** Make spell-checking tool ignore some org-mode section

see: http://emacs.stackexchange.com/questions/450/intelligent-spell-checking-in-org-mode

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ispell
    '(progn
       (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
       (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
       ))
#+END_SRC

** avy keybindings

[[https://github.com/abo-abo/avy][GitHub - abo-abo/avy: Jump to things in Emacs tree-style]]

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-g c" . avy-goto-char)
           ("M-g l" . avy-goto-line)
           ("M-g w" . avy-goto-word-1)))
#+END_SRC

** ace-pinyin

[[https://github.com/cute-jumper/ace-pinyin][GitHub - cute-jumper/ace-pinyin: Jump to Chinese character by pinyin with `avy' or `ace-jump-mode`]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-pinyin
    :ensure
    :ensure avy
    :diminish ""
    :commands ace-pinyin-global-mode
    :init
    (setq ace-pinyin-simplified-chinese-only-p nil)
    (ace-pinyin-global-mode 1))
#+END_SRC

** link-hint

[[https://github.com/noctuid/link-hint.el][GitHub - noctuid/link-hint.el: Pentadactyl-like Link Hinting in Emacs with Avy]]

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :bind ("C-c ol" . link-hint-open-link)
    :init
    (dolist (map (list help-mode-map Info-mode-map))
	(bind-key "f" 'link-hint-open-link map)))
#+END_SRC

** begin-end-buffer

移動 cursor 到目前 buffer 合理的首/尾。
至少支援 ibuffer, dired, elfeed-search.

[[https://github.com/DamienCassou/beginend][GitHub - DamienCassou/beginend: Emacs package to redefine M-< and M-> for some modes]]

ref: [[https://emacs.cafe/emacs/package/2017/08/01/beginend.html][beginend.el]]

#+BEGIN_SRC emacs-lisp
  (use-package beginend
    :diminish beginend-global-mode
    :diminish beginend-prog-mode
    :diminish beginend-elfeed-search-mode
    :diminish beginend-dired-mode
    :diminish beginend-ibuffer-mode
    :init
    (setq beginend-global-mode t)
    (beginend-global-mode))
#+END_SRC

** edit very large file

[[https://github.com/m00natic/vlfi][GitHub - m00natic/vlfi: View Large Files in Emacs]]

~C-c C-v~

#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :init
    (require 'vlf-setup)
    )
#+END_SRC

** unfill

#+BEGIN_SRC emacs-lisp
  (use-package unfill)
#+END_SRC
* Programming
** comment/uncomment a line or region

- With positive prefix, apply to N lines including current one.
- With negative prefix, apply to -N lines above."

#+BEGIN_SRC emacs-lisp
  (bind-key "M-;" #'comment-line)
#+END_SRC

** aggressive-indent

非文字模式及 python-mode 下，自動縮排。
ref: [[http://endlessparentheses.com/permanent-auto-indentation.html][Aggressive Auto-indentation with Emacs · Endless Parentheses]]

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :diminish " Ⓘ"
    :init
    (global-aggressive-indent-mode 1)
    :config
    (dolist (mm '(haskell-mode haskell-cabal-mode haskell-interactive-mode
                               python-mode
                               pug-mode stylus-mode))
      (add-to-list 'aggressive-indent-excluded-modes mm)))
#+END_SRC

** rainbow-mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
	:diminish rainbow-mode
    :hook (prog-mode css-mode))
#+END_SRC

** rainbow-delimiters

ref: https://github.com/Fanael/rainbow-delimiters

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook ((prog-mode text-mode) . rainbow-delimiters-mode))
#+END_SRC

** highlight-parentheses

highlight surrounding parentheses
https://github.com/tsdh/highlight-parentheses.el

#+BEGIN_SRC emacs-lisp
  (use-package  highlight-parentheses
    :diminish ""
    :hook (prog-mode . highlight-parentheses-mode)
    :init
    (setq hl-paren-colors '("Springgreen3"
                            "IndianRed1"
                            "IndianRed3"
                            "IndianRed4")))
#+END_SRC

** Highlight numbers on program mode

ref: [[https://github.com/Fanael/highlight-numbers]]

#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :init
    (add-hook 'prog-mode-hook '(lambda()
                                 (if (not (derived-mode-p 'json-mode))
                                     (highlight-numbers-mode)))))
#+END_SRC

** TODO Flycheck

http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish (flycheck-mode . " ⓢ")
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    (setq flycheck-keymap-prefix (kbd "C-c v"))

    :config
    (progn
      ;; disable jshint since we prefer eslint checking
      (setq-default flycheck-disabled-checkers
		    (append flycheck-disabled-checkers '(javascript-jshint)))

      ;; disable json-jsonlist checking for json files
      (setq-default flycheck-disabled-checkers
		    (append flycheck-disabled-checkers
			    '(json-jsonlist)))

      (flycheck-add-mode 'javascript-eslint 'web-mode)
      ;; customize flycheck temp file prefix
      (setq-default flycheck-temp-prefix ".flycheck")

      ;; use local eslint from node_modules before global
      ;; http://emacs.stackexchange.com/questions/21205/flycheck-with-file-relative-eslint-executable
      (defun my/use-eslint-from-node-modules ()
	(let* ((root (locate-dominating-file
		      (or (buffer-file-name) default-directory)
		      "node_modules"))
	       (eslint (and root
			    (expand-file-name "node_modules/eslint/bin/eslint.js"
					      root))))
	  (when (and eslint (file-executable-p eslint))
	    (setq-local flycheck-javascript-eslint-executable eslint))))
      (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)

      (setq flycheck-indication-mode 'right-fringe)
      (define-key flycheck-mode-map flycheck-keymap-prefix nil)

      (define-key flycheck-mode-map flycheck-keymap-prefix flycheck-command-map)))
#+END_SRC

** Magit (setup)

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")
      (setq magit-auto-revert-mode nil)
      (setq magit-save-some-buffers nil)
      (setq magit-set-upstream-on-push t)
      (setq magit-diff-refine-hunk t)
      (setq magit-completing-read-function 'ivy-completing-read)
      (setq magit-default-tracking-name-function 'magit-default-tracking-name-branch-only))
    :bind ("C-c g" . magit-status))
#+END_SRC

** magit-filenotify

#+BEGIN_SRC emacs-lisp
    (use-package magit-filenotify
      :hook ('magit-status-mode . magit-filenotify-mode))
#+END_SRC

** meld

Using =call-meld= to find the differences of current buffer from last commit.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fd" 'call-meld)

  (defun call-meld ()
    "Find the differences of current buffer from last commit."
    (interactive)
    (save-excursion
      (shell-command (format "meld %s" (buffer-file-name))))
    )
#+END_SRC

** TODO ediff

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-vertically)
  (setq ediff-merge-split-window-function 'split-window-vertically)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

** diff-hl

[[https://github.com/dgutov/diff-hl][GitHub - dgutov/diff-hl: Emacs package for highlighting uncommitted changes]]

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :init
    (progn (global-diff-hl-mode +1)
           (diff-hl-dired-mode 1)))
#+END_SRC

*** keybinds to navigate

- C-x v =  diff-hl-diff-goto-hunk :: Run VC diff command and go to the line corresponding to the current.
- C-x v n  diff-hl-revert-hunk    :: Revert the diff hunk with changes at or above the point.
- C-x v [  diff-hl-previous-hunk  :: Go to the beginning of the previous hunk in the current buffer.
- C-x v ]  diff-hl-next-hunk      :: Go to the beginning of the next hunk in the current buffer.

** projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish ""
    :init
    (progn (projectile-global-mode)
           (setq projectile-completion-system 'ivy)))
#+END_SRC

** TODO yasnippet

ref: yasnippet http://longhorizon.org/blog/2013/03/31/improving-python-development-in-emacs-with-yasnippet/

** Python (elpy)

emacs 中 Python 的設定有太多的選擇，我的選擇是 =elpy= ，原因是只要安裝好 =elpy= 就可用。

ref: https://github.com/jorgenschaefer/elpy

1) install ~elpy~ and ~jedi~ and ~virtualenv~ on OS

   #+BEGIN_SRC sh
     pip install elpy jedi virtualenv
   #+END_SRC

2) 參考 oh-my-emacs 簡單設定一下就好。

   ref: https://github.com/xiaohanyu/oh-my-emacs/blob/master/modules/ome-python.org


3) 如果 pip 更新 jedi 的話，要執行 ~jedi M-x jedi:install-server~ ，重新設定 emacs 中的 jedi。

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package elpy
    :diminish "☀"
    :ensure
    :ensure flycheck
    :bind ("M-*" . pop-tag-mark)
    :commands elpy-enable
    :init
    (elpy-enable)
    :config
    <<elpy-config>>)
#+END_SRC

*** set elpy backend and module

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (setq elpy-rpc-backend "jedi")

  (setq elpy-modules (delq 'elpy-module-highlight-indentation elpy-modules))
  (setq elpy-modules (delq 'elpy-module-django elpy-modules))

  (add-to-list 'elpy-modules 'elpy-module-company)
  (add-to-list 'elpy-modules 'elpy-module-yasnippet)
#+END_SRC

*** setup flycheck with elpy
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC

*** binding newline-and-indent to <RET>
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (define-key python-mode-map (kbd "RET")
    'newline-and-indent)
#+END_SRC

*** set comment-inline-offset
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (add-hook 'python-mode-hook
            (lambda ()
              (set (make-local-variable 'comment-inline-offset) 2)))
#+END_SRC
** TODO web-mode

目前是為了 mako 使用的 web-mode，看起來還有一些問題需要微調，不知如何下手。

Homepage: [[http://web-mode.org/][web-mode.el - html template editing for emacs]]
Source: https://github.com/fxbois/web-mode

ref: http://cestlaz.github.io/posts/using-emacs-21-web-mode/#.WCy93XeZOuU

useful keybindings

- C-c C-n :: jumping to opening/closing tags
- C-c C-f :: HTML folding
- C-c C-s :: snippet insertion
- M-q :: filling
- C-c C-w ::
- C-c C-m ::
- C-c C-i :: indent entire buffer

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.tmpl\\'" "\\.html?\\'" "\\.mako\\'"
    :init
    ;; (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode))
    (setq web-mode-engines-alist  '(("mako" . "\\.tmpl\\'")))
    ;; (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

    (setq web-mode-ac-sources-alist
      '(("css" . (ac-source-css-property))
        ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

    (setq web-mode-enable-current-element-highlight t)
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t)

    (defun my-web-mode-hook ()
      "Hooks for Web mode."

      (setq web-mode-markup-indent-offset 4)
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-style-padding 4)
      (setq web-mode-script-padding 4))

    (add-hook 'web-mode-hook  'my-web-mode-hook))

#+END_SRC

** css-mode
#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :init (setq css-indent-offset 2))
#+END_SRC

** js2-mode

ref: https://github.com/mooz/js2-mode

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js$"
    :init
    (progn
      ;; (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
      (add-hook 'js2-mode-hook
        (lambda () (setq js2-basic-offset 4)))
      (add-hook 'js2-mode-hook 'flycheck-mode)))
#+END_SRC
** company-tern

#+BEGIN_SRC emacs-lisp
(use-package company-tern
:demand company
:demand tern
:commands company-backends
:init
(add-to-list 'company-backends 'company-tern))
#+END_SRC

** json-mode

ref: https://github.com/joshwnj/json-mode

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'")
    ;; :init (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode)))
#+END_SRC

** hexo mode

https://github.com/kuanyui/hexo.el

#+BEGIN_SRC emacs-lisp
(use-package hexo)
#+END_SRC

** pug mode

[[https://github.com/hlissner/emacs-pug-mode][GitHub - hlissner/emacs-pug-mode: Pug support for Emacs, based on slim-mode.]]

must install pug-cli first.

#+BEGIN_SRC sh
sudo npm install pug-cli -g
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package pug-mode
    :config
    (defun pug-compile-saved-file()
      (when (and (stringp buffer-file-name)
                 (string-match "\\.pug\\'" buffer-file-name))
        (pug-compile)))
    (add-hook 'after-save-hook 'pug-compile-saved-file))
#+END_SRC

** stylus mode

[[https://github.com/vladh/stylus-mode][GitHub - vladh/stylus-mode: Stylus support for Emacs, based on pug-mode.]]

#+BEGIN_SRC emacs-lisp
  (use-package stylus-mode
    :quelpa (:fetcher github :repo "vladh/stylus-mode"))
#+END_SRC

** haskell-mode

~C-c C-,~: haskell-mode can also sort and align your import sections nicely.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs$" "\\.l?hs$"
    :bind (:map haskell-mode-map
                ([f5] . my/haskell-stack-build)
                ("M-g i" . haskell-navigate-imports)
                ("M-g M-i" . haskell-navigate-imports))
    :init
    (defun my/haskell-stack-build ()
      (interactive)
      (compile "stack build --fast"))

    (defun my/haskell-hook ()
      (setq mode-name "λ")
      (turn-on-haskell-doc-mode)
      (turn-on-haskell-indent)
      (turn-on-eldoc-mode))

    (add-hook 'haskell-mode-hook 'my/haskell-hook))
#+END_SRC

** intero-mode

http://commercialhaskell.github.io/intero/

#+BEGIN_SRC emacs-lisp
  (use-package intero
    :requires (haskell-mode)
    :hook (haskell-mode . intero-mode)
    ;; :init
    ;; (add-hook 'haskell-mode-hook 'intero-mode)
    :config
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    :diminish "λ")
#+END_SRC

** stylish-haskell

#+BEGIN_SRC sh
cabal update
cabal install happy alex
cabal install stylish-haskell
#+END_SRC

~M-x haskell-mode-stylish-buffer~

** flycheck-haskell

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-haskell
    :hook (flycheck-mode . flycheck-haskell-setup))
#+END_SRC

** hindent

~M-q~ : reformat the current declaration.

#+BEGIN_SRC sh
stack install hindent
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (when (executable-find "hindent")
    (use-package hindent
      :diminish hindent-mode " ↹"
      :hook (haskell-mode . hindent-mode)
      :config
      (setq hindent-reformat-buffer-on-save t)))
#+END_SRC

** haskell-snippets
#+BEGIN_SRC emacs-lisp
   (use-package haskell-snippets)
#+END_SRC

** TODO hlint-refactor

#+BEGIN_SRC emacs-lisp :tangle no
   (use-package hlint-refactor
   :hook (haskell-mode . hlint-refactor-mode)
   :diminish "")
#+END_SRC

** yaml mode

[[https://github.com/yoshiki/yaml-mode][GitHub - yoshiki/yaml-mode: The emacs major mode for editing files in the YAML data serialization format.]]

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yaml\\'" "\\.yml\\'"
    :config
    (add-hook 'yaml-mode-hook
              '(lambda ()
                 (define-key yaml-mode-map "\C-m" 'newline-and-indent))))
#+END_SRC

** systemd-mode

會自動以 company 補全，不必再設定。

#+BEGIN_SRC emacs-lisp
  (use-package systemd)
#+END_SRC

*** keybindings

(define-key map (kbd "C-c C-d") 'systemd-doc-directives)
(define-key map (kbd "C-c C-o") 'systemd-doc-open)
** ReStructure

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rst\\'" . rst-mode))
#+END_SRC

** markdown-mode

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.markdown\\'" "\\.md\\'")
#+END_SRC

** nginx-mode

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode)
#+END_SRC

** fish-mode

[[https://github.com/wwwjfy/emacs-fish][GitHub - wwwjfy/emacs-fish: fish-mode for emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode ("\\.fish\\'" . fish-mode)
    :config
    (add-hook 'fish-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'fish_indent-before-save))))
#+END_SRC

** TODO edbi for database management

[[https://github.com/kiwanami/emacs-edbi][GitHub - kiwanami/emacs-edbi: Database Interface for Emacs Lisp]]

must install following packages from CLI firstly.

#+BEGIN_SRC sh
  sudo cpan RPC::EPC::Service DBI DBD::SQLite DBD::mysql AnyEvent
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package edbi
    :ensure deferred
    :ensure epc
    :ensure ctable
    :ensure concurrent
    :ensure e2wm
    :init
    (autoload 'e2wm:dp-edbi "e2wm-edbi.el" nil t))
#+END_SRC

*** key binding

#+BEGIN_SRC ditaa :file edbi-keybings.png :cmdline -E
       move cursor: hjklnpfbae
     q                         q
    +--------+                +-------+
    |        |                |       |
    | Tables |      SPC       | table |
    | viewer | -------------> | define|
    |        |                |       |
    +--+-+---+   M-n/p        +--+-+--+
       | |       C-c q           | |
       | |c      C-c C-c        c| |
       | |      +----------+     | |
       | +----->|   SQL    |<----+ |
       |        +----------+       |
       | RET    |  query   |    V  |
       +------->|  data    |<------+
                +----------+
                 SPC
#+END_SRC

#+RESULTS:
[[file:edbi-keybings.png]]

*** company-edbi

[[https://github.com/proofit404/company-edbi][GitHub - proofit404/company-edbi: Edbi backend for company-mode.]]

#+BEGIN_SRC emacs-lisp
  (use-package company-edbi
    :commands company-backends
    :init
    (setq edbi:completion-tool nil)
    (add-to-list 'company-backends 'company-edbi))
#+END_SRC

*** edbi mysql

for stock project to use mySQL.

#+BEGIN_SRC emacs-lisp
  (defun opened-edbi-frame-p ()
    (dolist (f (frame-list))
      (if (e2wm:managed-p f)
          (return t))))

  (defun edbi-open-stock-mysql ()
    (interactive)
    (if (opened-edbi-frame-p)
        (message "edbi already open")
      (progn
        (make-frame)
        (let* ((uri "dbi:mysql:stock:localhost")
               (data-source (edbi:data-source uri "stock" "stock"))
               (conn (edbi:start)))
          (edbi:connect conn data-source)
          (edbi:dbview-open conn))
        (e2wm:dp-edbi))))

  (defun edbi-close-stock-mysql ()
    (interactive)
    (if (e2wm:managed-p)
        (progn
          (e2wm:stop-management)
          (delete-frame)
          (kill-edbi-buffers))
      (message "%s" "Please switch to edbi frame!")))

  (bind-key "C-c so" 'edbi-open-stock-mysql)
  (bind-key "C-c sk" 'edbi-close-stock-mysql)
#+END_SRC

*** edbi-sqlite

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package edbi-sqlite
    :bind (("C-x BB" . stock-db-stock-open)
	   ("C-x BQ" . stock-db-stock-close))
    :init
<<edbi-sqlite-config>>
)
#+END_SRC

**** create edbi workspace

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defvar edbi-eyebrowse-mode-prev nil)
  (defvar edbi-eyebrowse-slot nil)

  (defun switch-to-edbi-workspace ()
    (setq edbi-eyebrowse-mode-prev eyebrowse-mode)

    (unless eyebrowse-mode
      (eyebrowse-mode))

    (if edbi-eyebrowse-slot
        (eyebrowse-switch-to-window-config edbi-eyebrowse-slot)
      (progn
        (eyebrowse-create-window-config)
        (setq edbi-eyebrowse-slot (eyebrowse--get 'current-slot))
        (eyebrowse-rename-window-config edbi-eyebrowse-slot "stock")
        )))
#+END_SRC

**** open stock database

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defun stock-db-stock-open()
    "open and manage my stock db."
    (interactive)
    (if edbi-eyebrowse-slot
        (eyebrowse-switch-to-window-config edbi-eyebrowse-slot)
      (progn
        (switch-to-edbi-workspace)
        (edbi-sqlite "/mnt/lvm-data/Programing/stock4/db/stock2.db")
        (e2wm:dp-edbi))))

#+END_SRC

**** close stock database

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defun stock-db-stock-close ()
    "close my stock db"
    (interactive)
    (e2wm:stop-management)
    (when edbi-eyebrowse-slot
      (progn
        (eyebrowse-switch-to-window-config edbi-eyebrowse-slot)
        (setq edbi-eyebrowse-slot nil)
        (kill-edbi-buffers)
        (eyebrowse-close-window-config)
        )))
#+END_SRC

***** kill edbi buffers

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defun kill-buffer-edbi (buffer-or-name)
    (when (or (string/starts-with buffer-or-name "*edbi")
              (string/starts-with buffer-or-name "*epc"))
      (kill-buffer buffer-or-name)))


  ;; (cond
  ;; ((string/starts-with buffer-or-name "*edbi")
  ;; (kill-buffer buffer-or-name))
  ;; ((string/starts-with buffer-or-name "*epc")
  ;; (kill-buffer buffer-or-name))
  ;; (t nil)))


  (defun kill-edbi-buffers ()
    (interactive)
    (mapc 'kill-buffer-edbi (mapcar (function buffer-name) (buffer-list))))
#+END_SRC

*** flycheck for edbi

[[https://github.com/purcell/sqlint][GitHub - purcell/sqlint: Simple SQL linter]]
[[https://emacs.stackexchange.com/questions/20273/setting-up-flycheck-in-pair-with-different-mode-is-not-working][Setting up flycheck in pair with different mode is not working - Emacs Stack Exchange]]

1. install ruby for sqlint
   #+BEGIN_SRC sh
     yaourt -S ruby
     gem install sqlint
   #+END_SRC

2. add hook to flycheck

   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'flycheck
       '(progn
          (flycheck-add-mode 'sql-sqlint 'edbi:sql-mode)))
   #+END_SRC
* Internet navigation
** eww (Emacs Web broWser)

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package eww
    :bind (("C-c b" . browse-at-point))
    :config
    <<eww-config>>)
#+END_SRC

*** keybindings

- F :: (eww-toggle-fonts) can be used to toggle whether to use variable-pitch fonts or not.
- R :: (eww-readable) will try do identify the main textual parts of a web page and display only that,
       leaving menus and the like off the page.
- S :: will list all eww buffers, and allow managing them.
- C-c ok :: send current page to kindle
- C-c oo :: write current page as org-mode file

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (bind-keys :map eww-mode-map
             ("f" . link-hint-open-link)
             ("j" . next-line)
             ("k" . previous-line)
             ("l" . forward-char)
             ("h" . backward-char)
             ("d" . scroll-up-command)
             ("e" . scroll-down-command)
             ("B" . eww-browse-with-external-browser)
             ("m" . endless/toggle-image-display)
             ("q" . eww-quit-reset-image-flag)
             ("H" . eww-back-url)
             ("L" . eww-forward-url)
             ("c" . eww-copy-title-url-org-capture)
             ("ok" . eww-to-kindle-directly)
             ("oK" . send-url-to-kindle-at-point)
             ("oo" . eww-to-org)
             ("yy" . eww-copy-page-url)
             ("yt" . eww-copy-current-title)
             ("yo" . eww-copy-title-url-org)
             ("yu" . eww-copy-title-url))
#+END_SRC

*** Using google chrome as generic browser

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (setq browse-url-browser-function 'eww-browse-url)

  (setq browse-url-generic-program (executable-find "google-chrome-stable")
        shr-external-browser 'browse-url-generic)
#+END_SRC

*** using google search

ref: http://emacs.stackexchange.com/questions/2955/how-to-customize-background-color-for-some-web-pages-opened-with-eww

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (setq eww-search-prefix "https://www.google.com/search?q=")
  (setq shr-color-visible-luminance-min 70)
#+END_SRC

*** truncate lines

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (add-hook 'eww-mode-hook '(lambda ()
                              (toggle-truncate-lines nil)))
#+END_SRC

*** toggle image display

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config

  (defun eww-quit-reset-image-flag ()
    "reset image-flag"

    (interactive)
    (setq endless/display-images t)
    ;; (quit-window)
    (kill-buffer "*eww*"))

  (defvar-local endless/display-images t)

  (defun endless/toggle-image-display ()
    "Toggle images display on current buffer."
    (interactive)
    (setq endless/display-images (null endless/display-images))
    (endless/backup-display-property endless/display-images))

  (defun endless/backup-display-property (invert &optional object)
    "Move the 'display property at POS to 'display-backup.
  Only applies if display property is an image.
  If INVERT is non-nil, move from 'display-backup to 'display
  instead.
  Optional OBJECT specifies the string or buffer. Nil means current
  buffer."
    (let* ((inhibit-read-only t)
           (from (if invert 'display-backup 'display))
           (to (if invert 'display 'display-backup))
           (pos (point-min))
           left prop)
      (while (and pos (/= pos (point-max)))
	(if (get-text-property pos from object)
            (setq left pos)
          (setq left (next-single-property-change pos from object)))
          (if (or (null left) (= left (point-max)))
            (setq pos nil)
          (setq prop (get-text-property left from object))
          (setq pos (or (next-single-property-change left from object)
			(point-max)))
          (when (eq (car prop) 'image)
            (add-text-properties left pos (list from nil to prop) object))))))

#+END_SRC

*** eww browse at point

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (defun browse-at-point (arg)
    "browse at point: selected region or url or single word.
   if cursor at whitespace then call eww wait for input some thing."
    (interactive "P")

    (if (consp arg)
        (call-interactively 'eww)
      (if (string= "link" (car (org-thing-at-point)))
          (org-open-at-point)
        (unless (setq-local thing (thing-at-point 'url))
          (unless (setq-local thing (thing-at-point 'symbol))
            (call-interactively 'eww)))
        (eww thing))))
#+END_SRC

*** get current data/title/source on EWW buffer for EMACS 25+

#+BEGIN_SRC emacs-lisp emacs-lisp :tangle no :noweb-ref eww-config
  (defun eww-current-title nil
    "Return title of the Web page the current EWW buffer is visiting."
    (plist-get eww-data :title))

  (defun eww-current-source ()
    "Return source of the Web page the current EWW buffer is visiting."
    (plist-get eww-data :source))
#+END_SRC

*** eww copy current title and url to kill-ring

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (defun eww-copy-current-title ()
    (interactive)
    (yank-url-or-title (eww-current-title)))

  (defun eww-copy-title-url ()
    (interactive)
    (yank-url-or-title (concat (eww-current-title) "\n" (eww-current-url))))

  (defun eww-copy-title-url-org ()
    (interactive)
    (yank-url-or-title (org-make-link-string (eww-current-url) (eww-current-title))))

  (defun eww-copy-current-source ()
    (interactive)
    (yank-url-or-title (eww-current-source)))
#+END_SRC

*** capture idea to GTD system

#+BEGIN_SRC emacs-lisp
(defun eww-copy-title-url-org-capture ()
(interactive)
  (eww-copy-title-url-org)
  (org-capture :goto "t")
  (yank))
#+END_SRC

*** org-eww-mode

using org-eww to save current web page to org-mode in eww-mode

#+BEGIN_SRC emacs-lisp emacs-lisp :tangle no :noweb-ref eww-config
  (defun eww-to-org ()
    "Save eww current page to an org file"
    (interactive)
    (require 'org-eww)

    (let* ((eww-org-default-directory "/mnt/lvm-data/Documents/eww/")
           (org-file-name (expand-file-name (concat
                                             (replace-regexp-in-string "\[ :　/\]" "-" (eww-current-title))
                                             ".org")
                                            eww-org-default-directory)))
      (org-eww-copy-for-org-mode)
      (switch-to-buffer (get-buffer-create org-file-name))
      (yank)
      (goto-char (point-min))
      (insert "#+TITLE:\n#+AUTHOR:\n#+DATE:\n\n")
      (write-file org-file-name)
      ))
#+END_SRC

** elfeed

[[https://github.com/skeeto/elfeed][GitHub - skeeto/elfeed: An Emacs web feeds client]]

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package elfeed
    :ensure eww
    :bind ("C-c e" . elfeed)
    :config
    <<elfeed-config>>)
#+END_SRC

*** keybindings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (unbind-key "y" elfeed-search-mode-map)
  (bind-keys :map elfeed-search-mode-map
             ("m" . elfeed-toggle-star)
             ("j" . next-line)
             ("k" . previous-line)
             ("l" . forward-char)
             ("h" . backward-char)
             ("f" . avy-goto-line)
             ("d" . scroll-up-command)
             ("e" . scroll-down-command)
             ("g" . elfeed-update)
             ("a" . my/cycle-elfeed-search-filter)
             ("R" . elfeed-search-mark-all-read-next-filter)
             ("B" . elfeed-search-external-browser)
             ("C-<return>" . elfeed-search-browse-url)
             ("c" . copy-elfeed-search-org-capture)
             ("w" . copy-elfeed-search-url)
             ("yy" . copy-elfeed-search-url)
             ("yt" . copy-elfeed-search-title)
             ("yu" . copy-elfeed-search-title-url)
             ("yo" . copy-elfeed-search-org)
             ("ok" . elfeed-search-to-kindle)
             ("oK" . send-url-to-kindle-at-point))

  (unbind-key "y" elfeed-show-mode-map)
  (bind-keys :map elfeed-show-mode-map
             ("j" . next-line)
             ("k" . previous-line)
             ("l" . forward-char)
             ("h" . backward-char)
             ("f" . link-hint-open-link)
             ("d" . scroll-up-command)
             ("e" . scroll-down-command)
             ("B" . elfeed-show-external-browser)
             ("C-<return>" . elfeed-show-visit)
             ("c" . copy-elfeed-show-org-capture)
             ("w" . copy-elfeed-show-url)
             ("yy" . copy-elfeed-show-url)
             ("yt" . copy-elfeed-show-title)
             ("yu" . copy-elfeed-show-title-url)
             ("yo" . copy-elfeed-show-org)
             ("ok" . elfeed-show-to-kindle)
             ("oK" . send-url-to-kindle-at-point))
#+END_SRC

*** set faces
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (custom-set-faces
   '(elfeed-search-unread-title-face ((t :inherit default)))
   '(elfeed-search-title-face ((t :inherit font-lock-comment-face)))
   '(elfeed-search-date-face ((t (:inherit font-lock-string-face))))
   '(elfeed-search-feed-face ((t (:inherit font-lock-doc-face))))
   '(elfeed-search-tag-face ((t (:inherit font-lock-constant-face))))
   )

  (defface elfeed-search-starred-title-face
    '((t :foreground "#cc6666"))
    "Marks a starred Elfeed entry.")

  (defface elfeed-search-mustread-title-face
    '((t :foreground "#cc6666"))
    "Marks a mustread Elfeed entry.")

  (defface elfeed-search-it-title-face
    '((t :foreground "#b5bd68"))
    "Marks a news Elfeed entry.")

  (defface elfeed-search-finace-title-face
    '((t :foreground "#8abeb7"))
    "Marks a finace news Elfeed entry.")

  (defface elfeed-search-read-title-face
    '((t :inherit font-lock-comment-face))
    "Marks a finace news Elfeed entry.")

  (defface elfeed-search-junk-title-face
    '((t :inherit font-lock-comment-face))
    "Marks a junk Elfeed entry.")

  (push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)
  (push '(star elfeed-search-starred-title-face) elfeed-search-face-alist)
  (push '(mustread elfeed-search-mustread-title-face) elfeed-search-face-alist)
#+END_SRC

*** using curl to get feeds
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (setq elfeed-use-curl t)
#+END_SRC

*** remove tag 'unread' if news was 1 week ago
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (add-hook 'elfeed-new-entry-hook
            '(lambda() (progn
                         (elfeed-make-tagger :before "1 week ago"
                                             :remove 'unread))))
#+END_SRC

*** set default search-filter
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defconst elfeed-search-filter-default "@1-weeks-ago +unread")
  (setq elfeed-search-filter elfeed-search-filter-default)
#+END_SRC

*** reset to default filter
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-reset-to-default-filter ()
    "elfeed reset to default filter"
    (interactive)
    (elfeed-search-set-filter elfeed-search-filter-default))
#+END_SRC

*** update feeds when enter elfeed first time
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (add-hook 'elfeed-search-mode-hook
            '(lambda() (progn
                         (elfeed-update))))
#+END_SRC

*** refresh buffer when show elfeed entry

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defadvice elfeed-show-entry
      (after switch-buffer activate)
    "after elfeed show entry then refresh buffer"
    (elfeed-show-refresh))
#+END_SRC

*** elfeed-search mark current buffer all read

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-mark-all-read ()
    "mark all feed as read in elfeed search mode"
    (interactive)
    (call-interactively 'mark-whole-buffer)
    (elfeed-search-untag-all-unread))

  (defun elfeed-search-mark-all-read-next-filter ()
    "mark all feed as read and switch to next filter"
    (interactive)
    (call-interactively 'elfeed-search-mark-all-read)
    (my/cycle-elfeed-search-filter)
    )
#+END_SRC

*** elfeed toggle star

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'starred))
#+END_SRC

*** switch to next filter that has unread feeds

#+BEGIN_SRC emacs-lisp
  (defun my/cycle-elfeed-search-filter ()
    "Switch next filter has unread feeds."
    (interactive)
    (cl-loop for index-feed = (my/cycle-elfeed-search-filter-1)
             ;; do (message "%s %s" index-feed (elfeed-search-has-unread))
             until (or (= 0 index-feed)
                       (elfeed-search-has-unread))))
#+END_SRC

**** switch to next tag circularly

迴圈切換目前有的 tags. tags 來源是 (elfeed-db-get-all-tags).
目的為集中注意力在同一類資訊。

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun my/cycle-elfeed-search-filter-1 ()
    "switch to next tag circularly."
    ;;(interactive)
    (let* ((filters (vconcat (cons "" (mapcar (lambda (x) (format "+%s" x))
                                              (seq-remove (lambda (x) (eq x 'unread))
                                                          (elfeed-db-get-all-tags))))))
           (index-before
            (if (get 'my/cycle-elfeed-search-filter 'filter-index)
                (get 'my/cycle-elfeed-search-filter 'filter-index)
              0))
           (index-after
            (% (+ index-before 1) (length filters)))
           (next-filter (format "@1-week-ago %s +unread"
                                (aref filters index-after))))

      (put 'my/cycle-elfeed-search-filter 'filter-index index-after)
      (elfeed-search-set-filter next-filter)
      (beginning-of-buffer)
      index-after))
#+END_SRC

**** there are unread feeds on current filter

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-has-unread ()
    (if (and elfeed-search-filter-active elfeed-search-filter-overflowing)
        (return nil)
      (cl-loop with feeds = (make-hash-table :test 'equal)
               for entry in elfeed-search-entries
               count (elfeed-tagged-p 'unread entry) into unread-count
               until (> unread-count 0)
               finally
               (cl-return (> unread-count 0)))))
#+END_SRC

*** yank url and/or title
**** get url and/or title
***** get url and/or title from elfeed entry

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-entry-url (entry)
    (and entry (elfeed-entry-link entry)))

  (defun elfeed-link-title (entry)
    (and entry (elfeed-entry-title entry)))

  (defun elfeed-entry-title-url (entry)
    (concat (elfeed-link-title entry) "\n" (elfeed-entry-url entry)))

  (defun elfeed-entry-link-org (entry)
    "get link string as org-mode link format"
    (concat "[[" (elfeed-entry-url entry) "][" (elfeed-link-title entry) "]]"))
#+END_SRC

***** get current url and/or title in elfeed-search

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun get-elfeed-search-url ()
    (elfeed-entry-url (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-title ()
    (elfeed-link-title (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-title-url ()
    (elfeed-entry-title-url (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-org ()
    (elfeed-entry-link-org (elfeed-search-selected :ignore-region)))
#+END_SRC

***** get current url and/or title in elfeed-show

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun get-elfeed-show-url ()
    (elfeed-entry-url elfeed-show-entry))

  (defun get-elfeed-show-title ()
    (elfeed-link-title elfeed-show-entry))

  (defun get-elfeed-show-title-url ()
    (elfeed-entry-title-url elfeed-show-entry))

  (defun get-elfeed-show-org ()
    (elfeed-entry-link-org elfeed-show-entry))

#+END_SRC

**** yank url and/or title in elfeed search mode

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun yank-url-or-title (url-or-title)
    (message "%s" url-or-title)
    (kill-new url-or-title))

  (defun copy-elfeed-search-url ()
    "copy url to clipboard"
    (interactive)
    (yank-url-or-title (get-elfeed-search-url)))

  (defun copy-elfeed-search-title ()
    "copy title to clipboard"
    (interactive)
    (yank-url-or-title (get-elfeed-search-title)))

  (defun copy-elfeed-search-title-url ()
    "copy title and url to clipboard"
    (interactive)
    (yank-url-or-title (get-elfeed-search-title-url)))

  (defun copy-elfeed-search-org ()
    "copy url to clipboard as org-mode formate"
    (interactive)
    (yank-url-or-title (get-elfeed-search-org)))
#+END_SRC

**** yank url and/or title in elfeed show mode

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun copy-elfeed-show-url ()
    "copy url to clipboard."
    (interactive)
    (yank-url-or-title (get-elfeed-show-url)))

  (defun copy-elfeed-show-title ()
    "copy title to clipboard."
    (interactive)
    (yank-url-or-title (get-elfeed-show-title)))

  (defun copy-elfeed-show-title-url ()
    "copy title and url to clipboard as title url."
    (interactive)
    (yank-url-or-title (get-elfeed-show-title-url)))

  (defun copy-elfeed-show-org ()
    "copy title and url to clipboard as org-mode link format"
    (interactive)
    (yank-url-or-title (get-elfeed-show-org)))

#+END_SRC

*** open current page by external browser

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-external-browser ()
    "open current url via extenal browser"
    (interactive)
    (elfeed-search-browse-url t))

  (defun elfeed-show-external-browser ()
    "open current url via extenal browser"
    (interactive)
    (elfeed-show-visit t))
#+END_SRC

*** elfeed dead feeds

ref: [[https://github.com/skeeto/.emacs.d/blob/master/etc/feed-setup.el][.emacs.d/feed-setup.el at master · skeeto/.emacs.d · GitHub]]

there is no new post for a long time.

#+BEGIN_SRC emacs-lisp  :tangle no :noweb-ref elfeed-config
(cl-defun elfeed-dead-feeds (&optional (years 1.0))
   "Return a list of feeds that haven't posted en entry in YEARS years."
   (let* ((living-feeds (make-hash-table :test 'equal))
   (seconds (* years 365.0 24 60 60))
   (threshold (- (float-time) seconds)))
   (with-elfeed-db-visit (entry feed)
   (let ((date (elfeed-entry-date entry)))
   (when (> date threshold)
   (setf (gethash (elfeed-feed-url feed) living-feeds) t))))
   (cl-loop for url in (elfeed-feed-list)
   unless (gethash url living-feeds)
   collect url)))
#+END_SRC

*** capture idea to GTD system

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
(defun copy-elfeed-search-org-capture ()
  (interactive)
  (copy-elfeed-search-org)
  (org-capture :goto "t")
  (yank))

(defun copy-elfeed-show-org-capture ()
  (interactive)
  (copy-elfeed-show-org)
  (org-capture :goto "t")
  (yank))
#+END_SRC

*** TODO elfeed-show/search: binding "oo" to converting to org-mode
must know the content
<2017-08-29 二 11:47>

** elfeed-goodies

[[https://github.com/algernon/elfeed-goodies][GitHub - algernon/elfeed-goodies: Various goodies for Elfeed]]

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-goodies
    :ensure elfeed
    :commands elfeed-goodies/setup
    :init
    (setq elfeed-goodies/entry-pane-size 0.618)
    (elfeed-goodies/setup))
#+END_SRC

** elfeed-org

[[https://github.com/remyhonig/elfeed-org][GitHub - remyhonig/elfeed-org: Configure the Elfeed RSS reader with an Orgmode file]]

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :demand elfeed
    :demand org
    :commands elfeed-org
    :init
    (progn
      ;; (expand-file-name "emacs-init.org" user-emacs-directory)
      (setq rmh-elfeed-org-files (list "~/.elfeed.org"))
      (elfeed-org)))
#+END_SRC
* Blog
** nikola new post

#+BEGIN_SRC emacs-lisp
  (defun nikola-new-post ()
    "Create a new post or open an old post for nikola."

    (interactive)
    (let ((default-directory "/mnt/lvm-data/Documents/blog-2018/posts/"))
      (call-interactively 'find-file)
      (when (= 0 (buffer-size))
        (insert (car (cdr (assoc "N" org-structure-template-alist))))
        (goto-char (point-min)))))

  (bind-key "C-c nn" 'nikola-new-post)
#+END_SRC

** nikola build/deploy blogger site from emacs

#+BEGIN_SRC emacs-lisp
  (defun nikola-build ()
    "build blogger site by nikola build"

    (interactive)
    (message "nikola build")
    (async-shell-command "nikola build"))

  (defun nikola-deploy ()
    "deploy to github by nikola github_deploy"

    (interactive)
    (message "nikola deploy")
    (async-shell-command "nikola github_deploy"))

  (bind-key "C-c nb" 'nikola-build)
  (bind-key "C-c nd" 'nikola-deploy)
#+END_SRC
** insert current date time

for nikola blogger generator

#+BEGIN_SRC emacs-lisp
  (defun current-date-time-nikola ()
    (format-time-string "%Y-%m-%d %H:%M:%S UTC+08:00"))

  (defun insert-current-date-time ()
    "insert current date time at point"
    (interactive)
    (insert (current-date-time-nikola)))
#+END_SRC

* Org and GTD system
** Org

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :diminish org-src-mode
    :bind (("C-c l" . org-store-link)
           ("C-c c" . org-capture)
           ("C-c a" . org-agenda)
           (:map org-mode-map
                 ("C-c ok" . org-kindle-export-to-html)))
    :config
    <<org-config>>)
#+END_SRC

*** basic setup
 #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
   (setq org-src-fontify-natively t
         org-src-window-setup 'current-window
         org-confirm-babel-evaluate nil
         org-list-indent-offset 0
         org-blank-before-new-entry '((heading . t)
					(plain-list-item . t))
         org-startup-indented t)
 #+END_SRC

*** Extend org-mode's easy templates

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist
               '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist
               (list "T" (concat "#+TITLE:?\n#+AUTHOR:\n#+DATE: "
                             (current-date-time-nikola)
                             "\n#+UID: mario-long-epub-uid-for-kindle")))

  (add-to-list 'org-structure-template-alist
               (list "N" (concat "#+BEGIN_COMMENT\n"
                                 ".. title:\n"
                                 ".. slug:\n"
                                 ".. date: " (current-date-time-nikola) "\n"
                                 ".. status: draft\n"      ;;published | draft
                                 ".. tags:\n"
                                 ".. category:\n"
                                 ".. link:\n"
                                 ".. description:\n"
                                 ".. type: text\n"         ;;text | micro
                                 "#+END_COMMENT\n"
                                 "#+OPTIONS: toc:nil ^:{}\n"
                                 "#+LANGUAGE: zh-TW\n"
                                 )))
#+END_SRC

*** Extend babel support languages

ref: https://orgmode.org/worg/org-contrib/babel/languages.html

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (require 'ob-shell)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ditaa . t)
     (dot . t)
     ))
#+END_SRC

*** 去除 Org-mode 輸出 HTML 時多餘的空格

對 pandoc 無效。

SOURCE: https://github.com/emacs-china/emacs-china.github.io/blob/master/blog/FengShu/org-remove-useless-space-between-chinese.org

#+BEGIN_SRC emacs-lisp :tangle no :exports no
(require 'ox-html)
  (defun eh-org-clean-space (text backend info)
    "在 export 為 HTML 時，刪除中文之間不必要的空格"
    (when (org-export-derived-backend-p backend 'html)
      (let ((regexp "[[:multibyte:]]")
            (string text))
        ;; org 預設將一個換行符轉換為空格，但中文不需要這個空格，刪除。
        (setq string
              (replace-regexp-in-string
               (format "\\(%s\\) *\n *\\(%s\\)" regexp regexp)
               "\\1\\2" string))
        ;; 刪除粗體之前的空格
        (setq string
              (replace-regexp-in-string
               (format "\\(%s\\) +\\(<\\)" regexp)
               "\\1\\2" string))
        ;; 刪除粗體之後的空格
        (setq string
              (replace-regexp-in-string
               (format "\\(>\\) +\\(%s\\)" regexp)
               "\\1\\2" string))
        string)))

  (add-to-list 'org-export-filter-paragraph-functions
               'eh-org-clean-space)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
;; https://coldnew.github.io/a1ed40e3/
(defadvice org-html-paragraph (before org-html-paragraph-advice
                                      (paragraph contents info) activate)
  "Join consecutive Chinese lines into a single long line without
unwanted space when exporting org-mode to html."
  (let* ((origin-contents (ad-get-arg 1))
         (fix-regexp "[[:multibyte:]]")
         (fixed-contents
          (replace-regexp-in-string
           (concat
            "\\(" fix-regexp "\\) *\n *\\(" fix-regexp "\\)") "\\1\\2" origin-contents)))
	(ad-set-arg 1 fixed-contents)))
#+END_SRC

*** Convert inline verbatim to kbd when HTML export

ref: https://emacs-china.org/t/org-mode/1165

change =verbatim= to =kbd=
~code~

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ox-html
    '(setq org-html-text-markup-alist
           '((bold . "<b>%s</b>")
             (code . "<code>%s</code>")
             (italic . "<i>%s</i>")
             (strike-through . "<del>%s</del>")
             (underline . "<span class=\"underline\">%s</span>")
             (verbatim . "<kbd>%s</kbd>"))))
#+END_SRC

*** 中文*加強*語法，或+刪除+一句話，不用加上空白

the _quick_ *fox* jumped over a brown +lazy+ dog.

dir/subdir/
dir /subdir/
an*emphasis*word
an *emphasis* word

#+BEGIN_SRC emacs-lisp
  (setcar org-emphasis-regexp-components (concat " \t('\"{[:multibyte:]"))
  (setcar (nthcdr 1 org-emphasis-regexp-components) (concat "[:multibyte:]- \t.,:!?;'\")}\\"))
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

*** TODO add new markup to org-mode HTML export
ref: [[https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export][How to add new markup to org-mode HTML export? - Emacs Stack Exchange]]
ref: [[http://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html][Use Org-Mode Links for Absolutely Anything · Endless Parentheses]]

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
#+END_SRC

*** keybinds

- =C-Return= 增加一個標題
- =C-S-Return= 增加一個 TODO 標題
- =C-<left>/<right>= 對標題設定 TODO keywords
- =C-<up>/<down>= 對標題設定重要性
- =S-M-Return= 增加一個 checkbox 專案

- =M-<left>/<right>= 標題上/下推一階
- =S-<left>/<right>= :: Cycle the thing at point or in the current line, depending on context.

  Depending on context, this does one of the following:
  + switch a timestamp at point one day into the future
  + on a headline, switch to the next TODO keyword.
  + on an item, switch entire list to the next bullet type
  + on a property line, switch to the next allowed value
  + on a clocktable definition line, move time block into the future

- =<TAB>= 迴圈展開一個標題 (含子標題)
- =S-<TAB>= 迴圈展開全檔的標題

- =C-c C-c= 增加或修改 tags
- =C-c \= 展開本檔相對應 tag 的標題，可用 & | 串接，做邏輯性查詢
- =C-c '= 編輯原始碼

- =C-c C-o= open url/internal link
- =C-c &= back to previous position

- =C-c *= org-toggle-heading or table result

- =C-c [= 將目前檔案加入 agenda file list 中
- =C-c ]= 將目前檔案從 agenda file list 中移出

** Capture and Agenda

**** basic settings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (setq org-agenda-window-setup 'current-window)
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+END_SRC

**** binding

***** capture

- C-c C-c: save eand exit
- C-c C-q: tagged
- C-c C-s: schedule
- C-c C-d: deadline

***** agenda

- s: save all files of agenda

**** files for agenda/inbox/gtd

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (setq org-capture-templates
        '(("t" "Todo" entry (file org-default-inbox-file)
           "* TODO %?\n%T")
          ("e" "Emacs" entry (file+headline org-default-inbox-file "emacs")
           "* TODO %?\n%T")
          ("n" "Note" entry (file org-my-notes-file)
           "* %?\n%T")
          ))

  (setq org-agenda-files (list org-default-inbox-file
                               org-my-notes-file
                               user-emacs-init-org
                               ))

  ;; (setq org-agenda-current-span 'day)
  ;; (setq org-agenda--span 2)

  (setq org-refile-targets '((nil :maxlevel . 2)  ; refile to headings in the current buffer
                             (org-agenda-files :level . 1)
                             ))

  (add-hook 'org-agenda-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-g") 'org-agenda-exit)))
#+END_SRC

**** show dropbox status of GTD directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (bind-key "C-c fg" 'my/GTD-dropbox-status)
  (defun my/GTD-dropbox-status ()
    (interactive)
    (message "%s" (shell-command-to-string "cd ~/Dropbox/GTD&&dropbox-cli filestatus")))
#+END_SRC

**** pop up a new frame to do a capture

#+BEGIN_SRC sh
  $ emacsclient -ne "(make-capture-frame)"
#+END_SRC

press =C-x w= to close this frame

#+BEGIN_SRC emacs-lisp
  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))
#+END_SRC

**** archive all the DONE/CNACELED tasks by one command

ref: http://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command

#+BEGIN_SRC emacs-lisp
  (defun org-archive-done-tasks ()
    "archive all the DONE/CNACELED tasks "
    (interactive)
    (dolist (status '("/DONE" "/CANCELED"))
      (org-map-entries (lambda ()
             (org-archive-subtree)
             (setq org-map-continue-from (outline-previous-heading)))
               status 'file)))
#+END_SRC

** TODO Org sync with Google Calendar

ref: https://github.com/myuhe/org-gcal.el
ref: [[http://cestlaz.github.io/posts/using-emacs-26-gcal/#.WaQM4nUjHRY][Using Emacs - 26 - Google Calendar, Org Agenda | C'est la Z]]
ref: [[http://www.iperiusbackup.net/en/how-to-enable-google-drive-api-and-get-client-credentials/][How to enable Google Drive API and get client credentials]]

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-gcal
    :ensure
    :ensure request
    :ensure alert
    :config

    (when (file-exists-p user-secret-file)
      (load-file user-secret-file))

    (add-to-list 'org-agenda-files (cdr(car org-gcal-file-alist)))
    ;; don’t use org-gcal-sync because 亂碼
    (add-hook 'org-agenda-mode-hook (lambda () (org-gcal-refresh-token) (org-gcal-fetch)))
    (add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-refresh-token) (org-gcal-fetch)))
    )

#+END_SRC

** TODO super-agneda

[[https://github.com/alphapapa/org-super-agenda][GitHub - alphapapa/org-super-agenda: Supercharge your Org daily/weekly agenda by grouping items]]

#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :config
    (org-super-agenda-mode)
    (let ((org-super-agenda-groups
           '(;; Each group has an implicit boolean OR operator between its selectors.
             (:name "Today"  ; Optionally specify section name
                    :time-grid t  ; Items that appear on the time grid
                    :todo "TODAY")  ; Items that have this TODO keyword
             (:name "Important"
                    ;; Single arguments given alone
                    :tag "bills"
                    :priority "A")
             ;; Set order of multiple groups at once
             (:order-multi (2 (:name "Shopping in town"
                                     ;; Boolean AND group matches items that match all subgroups
                                     :and (:tag "shopping" :tag "@town"))
                              (:name "Food-related"
                                     ;; Multiple args given in list with implicit OR
                                     :tag ("food" "dinner"))
                              (:name "Personal"
                                     :habit t
                                     :tag "personal")
                              (:name "Space-related (non-moon-or-planet-related)"
                                     ;; Regexps match case-insensitively on the entire entry
                                     :and (:regexp ("space" "NASA")
                                                   ;; Boolean NOT also has implicit OR between selectors
                                                   :not (:regexp "moon" :tag "planet")))))
             ;; Groups supply their own section names when none are given
             (:todo "WAITING" :order 8)  ; Set order of this section
             (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                    ;; Show this group at the end of the agenda (since it has the
                    ;; highest number). If you specified this group last, items
                    ;; with these todo keywords that e.g. have priority A would be
                    ;; displayed in that group instead, because items are grouped
                    ;; out in the order the groups are listed.
                    :order 9)
             (:priority<= "B"
                          ;; Show this section after "Today" and "Important", because
                          ;; their order is unspecified, defaulting to 0. Sections
                          ;; are displayed lowest-number-first.
                          :order 1)
             ;; After the last group, the agenda will display items that didn't
             ;; match any of these groups, with the default order position of 99
             )))
      (org-agenda nil "a")))
#+END_SRC

** Pretty Bullets
ref: https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** org-kindle

push file.org to my kindle via htmlize, pandoc, kindlegen, kmail

#+BEGIN_SRC emacs-lisp
  (defun org-kindle-export-as-html ()
    (interactive)

    (setq-local org-html-doctype "html5")
    (setq-local org-export-default-language "zh_TW")
    (setq-local org-html-head-include-default-style nil)
    (setq-local org-html-postamble nil)
    (setq-local org-html-head-include-scripts nil)
    (org-html-export-as-html))

  (defun org-kindle-export-to-html ()
    (interactive)

    (let* ((fname (buffer-file-name))
           (fn-html (temporary-file-name (concat fname ".html")))
           (fn-epub (temporary-file-name (concat fname ".epub")))
           (fn-mobi (temporary-file-name (concat fname ".mobi"))))

      (save-window-excursion
        (org-kindle-export-as-html)
        (write-file fn-html)
        (kill-buffer)

        (shell-command (concat "pandoc -f html -o " fn-epub " -i " fn-html))
        (shell-command (concat "kindlegen " fn-epub))
        (async-shell-command (concat "kmail " fn-mobi)))))

  (bind-key "C-c ok" #'org-kindle-export-to-html org-mode-map)

#+END_SRC

*** stylesheet.css for pandoc to export epub

edit ~~/.pandoc/epub.css~

** TODO Present by reveal.js
1. ref: https://github.com/hakimel/reveal.js
2. ref: https://github.com/yjwen/org-reveal

#+BEGIN_QUOTE
Reveal.js is a tool for creating good-looking HTML presentations,
authored by Hakim El Hattab.

Org-Reveal exports your Org documents to reveal.js presentations.
With Org-reveal, you can create beautiful presentations with 3D
effects from simple but powerful Org contents.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ox-reveal
    :ensure htmlize
    :config
    (progn
      (setq org-reveal-root "file:///mnt/lvm-data/github/reveal.js")))
#+END_SRC

** TODO PlantUML mode
[[http://archive.3zso.com/archives/plantuml-quickstart.html][使用 Emacs 敲出 UML，PlantUML 快速指南]]
https://github.com/skuro/plantuml-mode

** TODO graphviz

** TODO ditaa

http://www.cnblogs.com/chenfanyu/archive/2013/01/27/2878845.html

* Finalization
** diminish some mode

#+BEGIN_SRC emacs-lisp
  (diminish 'overwrite-mode)

  (eval-after-load 'org-indent
    '(diminish 'org-indent-mode))
#+END_SRC

* Difficulties

** ~C-M-p~ don't work

原因：fcitx 按鍵衝突
解法：http://sudodev.cn/emacs-backward-list-shortcut/

「配置 Fcitx」這一項，點選彈出輸入法配置視窗，點開「全域性設定」頁籤，
勾選底下的「顯示高階選項」之後多出來一些內容，往下擼，找到設定有
「Ctrl+Alt+P」這一項的設定，點這個按鈕，回車，就置為空了。

** install ditaa

步驟：
1. linux 中安裝 ditaa, 也會先安裝 java
2. 建立目錄：=~/.emacs.d/elpa/contrib/scripts=
3. 用 ~find /. -name "ditaa*"~ 找 ditaa.jar 在哪？
4. 建 ~ditaa.jar~ 的連結到 =~/.emacs.d/elpa/contrib/scripts= 中

#+BEGIN_SRC sh
yaourt -S ditaa
mkdir -p ~/.emacs.d/elpa/contrib/scripts
find /. -name "ditaa*"
ln -s /usr/share/java/ditaa/ditaa-0_10.jar ditaa.jar
#+END_SRC

* The Final note

使用 emacs 會上癮，尤其是 lisp 這種語言，真的迷人。

只要花時間熟悉這套工具、語言，真的就不想用其它的編輯器，也無法用其它的編輯器了。

因為，已經習慣自己一手打造出來，獨一無二，順手的工具。

* Maybe or reading
** TODO oremacs/README.md at github · abo-abo/oremacs             :READING:

https://github.com/abo-abo/oremacs/blob/github/README.md

** TODO zamansky/emacs.dz: Awesome emacs config files              :READING:

https://github.com/zamansky/emacs.dz

** TODO aculich/.emacs.d                                           :READING:

https://github.com/aculich/.emacs.d

** TODO skeeto/.emacs.d: My personal .emacs.d                      :READING:

https://github.com/skeeto/.emacs.d

** TODO lunaryorn/old-emacs-configuration                          :READING:

https://github.com/lunaryorn/old-emacs-configuration?files=1

** TODO .emacs.d/setup-diff.el at master · kaushalmodi/.emacs.d  :READING:

https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-diff.el

** TODO emacs-init.org refector [75%]

- [ ] cleanup no export code block
- [ ] review all
- [X] rearrange headings
- [X] add todo keywork for wanted functions
- [X] move to do itme to emacs-init.org
** TODO add IRC using ERC

#gentoo
irc.freenode.net
<2016-12-16 Fri 16:07>

** MAYBE toggle dot to space in string

<2016-12-07 Wed 10:42>

** MAYBE my-viewer-key-map

<2016-12-26 一 11:14>

** MAYBE Hirerachy of mode

http://emacs.stackexchange.com/questions/2655/hierarchy-of-modes

** TODO web-mode settings: change the face of matched tag(for nikola)

current is black background is not easy to read.

** MAYBE Emacs-BPR (Background Process Runner)                     :READING:

ilya-babanov/emacs-bpr
https://github.com/ilya-babanov/emacs-bpr

** TODO study abo-abo all respo of emacs
** TODO hydra                                                     :READING:

https://github.com/abo-abo/hydra/blob/master/README.md

** TODO diff/ediff/meld @dired/@ibuffer

<2017-08-20 日 16:15>

** TODO DTrace : debugger for elisp

http://nullprogram.com/blog/2018/01/17/

** TODO Debugging Elfeed with DTrace http://irreal.org/blog/?p=6912
** TODO [[http://irreal.org/blog/?p=7198][Irreal: Emacs Tools for Writers]]

<2018-05-16 Wed 09:52>

** TODO meld in dired.....Dired: marking, copying, moving and deleting files | Pragmatic Emacs

http://pragmaticemacs.com/emacs/dired-marking-copying-moving-and-deleting-files/

** TODO emacs-haskell-tutorial/tutorial.md at master · serras/emacs-haskell-tutorial

https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#interactive-commands

** TODO emacs & hoogle

2.4 Emacs Integration
haskell-mode from versions 2.4 onwards have the function haskell-hoogle, which will hoogle the identifier at point. Setup:

(require 'haskell-mode)
(define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
;(setq haskell-hoogle-command "hoogle")
You will need a web browser configured for best results. Here's an example setup for Safari:

(setq browse-url-browser-function 'browse-url-safari)
(defun browse-url-safari (url &optional new-window)
 "Open URL in a new Safari window."
 (interactive (browse-url-interactive-arg "URL: "))
 (unless
     (string= ""
              (shell-command-to-string
               (concat "open -a Safari " url)))
   (message "Starting Safari...")
   (start-process (concat "open -a Safari " url) nil "open -a Safari " url)
   (message "Starting Safari... done")))
Alternately, you can build the command-line hoogle (darcs repo below) and uncomment the third line above, then results will appear in a buffer.
<2018-06-12 二 20:50>

** TODO company-web/README.md at master · osv/company-web

https://github.com/osv/company-web/blob/master/README.md
** TODO Org ad hoc code, quick hacks and workarounds               :READING:

http://thomasf.github.io/solarized-css/test/org-hacks.html#sec-1-4
<2017-01-13 Fri 19:16>

** TODO Org-Mode As a Rabbit Hole: Agenda Tasks Piling Up          :READING:

http://karl-voit.at/2017/08/12/org-rabbit-hole/

** TODO setup sop for clock-in/out todo item

effort time
analysis
<2016-12-26 一 10:19>

** TODO Kanban in Emacs Org-Mode to Get More Work Done             :READING:

http://jr0cket.co.uk/2016/09/Kanban-board-Emacs-Org-mode-to-get-work-done.html

what's theme

** TODO gmail -> todo list -> orgmode

<2017-01-13 Fri 19:49>

** TODO Maximize the org-capture buffer

https://fuco1.github.io/2017-09-02-Maximize-the-org-capture-buffer.html

emacsclient "%u" 

** TODO org-capture-extension/README.md at master · sprig/org-capture-extension

https://github.com/sprig/org-capture-extension/blob/master/README.md

** TODO org-recent-headings/README.org at master · alphapapa/org-recent-headings

https://github.com/alphapapa/org-recent-headings/blob/master/README.org

** TODO org-super-agenda/README.org at master · alphapapa/org-super-agenda

https://github.com/alphapapa/org-super-agenda/blob/master/README.org

** TODO org-web-tools/README.org at master · alphapapa/org-web-tools

https://github.com/alphapapa/org-web-tools/blob/master/README.org

** TODO alphapapa/org-protocol-capture-html: Capture HTML from the browser selection into Emacs as org-mode content

https://github.com/alphapapa/org-protocol-capture-html

** TODO org examples and cookbook                                  :READING:

http://ehneilsen.net/notebook/orgExamples/org-examples.html

** TODO org-super-agenda/README.org at master · alphapapa/org-super-agenda · GitHub

https://github.com/alphapapa/org-super-agenda/blob/master/README.org

** TODO Reddit - orgmode - Do you use Pandoc? What would be your wishes regarding Pandoc and Org-mode? :READING:

https://www.reddit.comundefined/

** TODO org-super-agenda/README.org at master · alphapapa/org-super-agenda · GitHub

https://github.com/alphapapa/org-super-agenda/blob/master/README.org

** TODO Amazon.com Message. html format

https://www.amazon.com/gp/feature.html?ie=UTF8&docId=1000765211

** MAYBE [[https://coldnew.github.io/4e70786/][在任何 mode 下都可以使用像 org-mode 的 easy-template 進行補全 | coldnew's blog]]

** MAYBE latex 中文字形，解決𤸔
** TODO 簡繁互換 in eww buffer

#+BEGIN_SRC emacs-lisp emacs-lisp :tangle no :noweb-ref eww-config

#+END_SRC

** TODO hangups

ref: https://github.com/jtamagnan/hangups.el

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hangups
    ;;:load-path
    :ensure adaptive-wrap
    :bind (("C-c h" . hangups-open-conversation-small-p)
	   :map hangups-conv-mode-map
	   ("j" . next-line)
	   ("k" . previous-line)
	   ("l" . forward-char)
	   ("h" . backward-char)
	   ("d" . scroll-up-command)
	   ("e" . scroll-down-command)
	   ("o" . browse-at-point))
    :config
    (progn
      (defun hangups-open-conversation-small-p ()
	"Open conversation to small-p."
	(interactive)

	(hangups)
	(let ((name "小 p_葉"))
	  (switch-to-buffer (get-buffer-create (hangups/buffer-name name)))
	  (hangups-conv-mode)
	  (hangups-conversation name hangups-messages))

	(add-hook 'hangups-list-mode-hook
		  (lambda () (run-with-timer 120 (* 1 60) 'hangups-list-refresh)))

	(spaceline-define-segment hangups-lighter
	  "hangups conversations"
	  (when (> hangups/convs-unread 0)
	    "\u2706")
	  :face font-lock-warning-face)

	(spaceline-spacemacs-theme '(hangups-lighter)))
      ))
#+END_SRC

** TODO erc
** TODO Insert stock ids at point in elfeed.org

Insert stock ids to '.elfeed.org' and read their RSS

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package esqlite
    :config
    (progn
      (defun insert-stock-id-at-point ()
        "Insert stock ids at point."

        (interactive)

        (if (string= ".elfeed.org" (buffer-name))
            (let* ((db-name "/mnt/lvm-data/Programing/stock4/db/stock2.db")
                   (sql-fetch-stock-ids "select s.sid, i.name from summary as s, stock_info as i where s.sid=i.sid and s.userid=\"mariolong\""))

              (dolist (rec (esqlite-read db-name sql-fetch-stock-ids))
                (insert (format "*** [[http://news.wearn.com/rss/%s][%s-%s]]\n"
                                (s-trim (car rec))
                                (s-trim (car rec))
                                (s-trim (second rec))))))

          (message "%s" "Must in '.elfeed.org'")))

      (bind-key "C-c fi" 'insert-stock-id-at-point)
      ))
#+END_SRC

** TODO GitHub - bmag/emacs-purpose: Manage Windows and Buffers According to Purposes

https://github.com/bmag/emacs-purpose
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package window-purpose
    :init
    (purpose-mode))

#+END_SRC

** TODO auto revert ibuffer

[[https://emacs.stackexchange.com/questions/2177/how-can-i-make-ibuffer-auto-refresh-the-list-of-buffers][ref: How can I make ibuffer auto-refresh the list of buffers? - Emacs Stack Exchange]]

#+BEGIN_SRC emacs-lisp :tangle no
 :noweb-ref ibuffer-config
  (setq auto-revert-verbose nil)

  (defun my-ibuffer-stale-p (&optional noconfirm)
    (frame-or-buffer-changed-p 'ibuffer-auto-buffers-changed))

  (defun my-ibuffer-auto-revert-setup ()
    (set (make-local-variable 'buffer-stale-function)
         'my-ibuffer-stale-p)
    (set (make-local-variable 'auto-revert-verbose) nil)
    (auto-revert-mode 1))

  (add-hook 'ibuffer-mode-hook 'my-ibuffer-auto-revert-setup)
#+END_SRC

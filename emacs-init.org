#+TITLE: Emacs Configuration
#+AUTHOR: Mario Long
#+EMAIL: mariolong5782@gmail.com
#+STARTUP: overview showstars
#+BABEL: :cache yes
#+OPTIONS: ^:nil

* 前言

2016-1-5
用了一陣子的 spacemacs，雖然覺得不錯，但是 0.105 版出來後，許多設定又不能用了。
算了，還是追隨 coldnew 的腳步，回到自己的 org 檔吧。

2016-6-3
我又回來了。
實在是用不到 spacemacs 那麼多的功能，而且覺得 spacemacs 愈來愈慢，不夠快意。

* Initialization
** load prefer newer

since emacs 24.4, new option `load-prefer-newer' has been
introduce, which make me never accidentally using outdated compiled files.

#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

** cleanup
*** 不必顯示功能表、工具列和捲軸

在 init.el 的開始部份加上下列 3 行：
如果要用功能表，可以按 <F10> 。

#+begin_src emacs-lisp :tangle no
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

*** 不顯示啟始畫面
在 init.el 的開始部份加上，

#+begin_src emacs-lisp :tangle no
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+end_src

*** 直接開啟全螢幕
在 init.el 的開始部份加上，

#+begin_src emacs-lisp :tangle no
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+end_src

*** 清除 redefinition 訊息

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

*** 清除 scratch message

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message "")
#+END_SRC

** 設定字型

重要的是設定中文字型

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Source Code Pro 18")

  (dolist (charset '(kana han cjk-misc bopomofo))
    (set-fontset-font (frame-parameter nil 'font) charset
                      (font-spec :family "Source Han Sans" :size 28)))

  (set-fontset-font (frame-parameter nil 'font) 'symbol (font-spec :family "Symbola" :size 32))
#+end_src

一二三四五六七八九十一二三四五六七八九十一二三四五六七八九十一二三四五六七八九十一二三四五六七八九十
1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890

** Define user-cache-directory variable

user-emacs-directory 定義於 init.el 中

#+BEGIN_SRC emacs-lisp
  (defconst user-cache-directory
    (file-name-as-directory (concat user-emacs-directory ".cache"))
    "My emacs storage area for persistent files.")
#+END_SRC

** TODO [#C] add .emacs.d/lisp to load path
ref: https://www.emacswiki.org/emacs/DotEmacsModular

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "lisp/hangups.el"))
  (add-to-list 'load-path (concat user-emacs-directory "lisp/moedict.el"))
  ;; (add-to-list 'load-path (concat user-emacs-directory "lisp/swiper"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
  (let* ((lisp-dir '("lisp/" "themes/")))
    (dolist (lisp-path lisp-dir)
      (when (not (file-exists-p lisp-path))
        (make-directory (concat user-emacs-directory lisp-path) t))
      (let* ((load-dir (concat user-emacs-directory lisp-path))
             (default-directory load-dir))
        (setq load-path
              (append
               (let ((load-path (copy-sequence load-path)))
                 (append
                  (copy-sequence (normal-top-level-add-to-load-path '(".")))
                  (normal-top-level-add-subdirs-to-load-path)))
               load-path)))))
#+END_SRC

** Tangle this initial file before exit emacs

#+BEGIN_SRC emacs-lisp
  (defconst emacs-init-org-file (expand-file-name "emacs-init.org" user-emacs-directory))
  (defconst emacs-init-el-file (expand-file-name "emacs-init.el" user-emacs-directory))

  (defun tangle-emacs-init-org ()
    "Tangle emacs-init.org to .el"

    (interactive)

    (let* ((age (lambda (file)
                  (float-time
                   (time-subtract (current-time)
                                  (nth 5 (or (file-attributes (file-truename file))
                                             (file-attributes file))))))))
      (if (file-exists-p emacs-init-org-file)
          (unless (and (file-exists-p emacs-init-el-file)
                       (> (funcall age emacs-init-org-file)
                          (funcall age emacs-init-el-file)))
            (progn
              ;; (require 'org)
              ;; (require 'ob-tangle)
              (setq org-confirm-babel-evaluate nil)
              (setq org-confirm-execute-src-block nil)
              (org-babel-tangle-file emacs-init-org-file emacs-init-el-file "emacs-lisp"))
            ))))

  (add-hook 'kill-emacs-hook 'tangle-emacs-init-org)
#+END_SRC

* Package Management

用過 quelpa，因為啟動時會自動抓原始碼，啟動速度真的很慢。
試用過 Cask 和 pallet，實在是看不出來有何優勢，也不能自動刪除不需要的 package，所以先不用。

經過一番找尋，發現 req-package 真的不錯。
首先安裝還是透過 =package.el= ，成功之後，就可以用 =req-package= 安裝其它的套件。

** Initalize =package=
用 =package.el= 要先加來源庫，以下工作改到 init.el 中執行。

#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

  (package-initialize)
#+END_SRC

** 安裝 =req-package=

#+BEGIN_SRC emacs-lisp
  (if (not (package-installed-p 'req-package))
      (progn
        ;; (package-refresh-contents)
        (package-install 'req-package)))

  (require 'req-package)
#+END_SRC

** 安裝 =diminish= 和 =bind-key=

使用 =req-package= 時，會用到 =:diminish= 和 =:bind= ，故安裝以下 2 個套件。

#+BEGIN_SRC emacs-lisp :tangle no
  ;; (req-package diminish)
  ;; (req-package bind-key)
#+END_SRC

** 更新所有已安裝的套件

用 =M-x upgrade-all-installed-packages= 更新所有已安裝的套件
因為用了 jedi.el，所以要更新一下 jedi server

#+BEGIN_SRC emacs-lisp
  (defun upgrade-all-installed-packages ()
    "Upgrade all installed packages."
    (interactive)
    (save-window-excursion
      (package-list-packages)
      (package-menu-mark-upgrades)
      (package-menu-execute t))
    ;; (jedi:install-server)
    )
#+END_SRC

** 刪除不需要的套件

用 =M-x package-list-packages= 找到不需要的套件，並刪除之。

** 載入自定檔

#+BEGIN_SRC emacs-lisp :tangle no
  (load (concat user-emacs-directory "custom.el"))
#+END_SRC

** 重新載入 emacs 設定

#+BEGIN_SRC emacs-lisp
  (defun reload-emacs ()
    "reload my emacs settings"

    (interactive)
    (load-file (concat user-emacs-directory "init.el"))
    (delete-other-windows))
#+END_SRC

** 執行目前 buffer 到錯誤發生
#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
    "Evaluate emacs buffer until error occured."

    (interactive)
    (goto-char (point-min))
    (while t (eval (read (current-buffer)))))
#+END_SRC

* Theme
** Theme

#+begin_src emacs-lisp
  (req-package color-theme-sanityinc-tomorrow
    :init (load-theme 'sanityinc-tomorrow-night :no-confirm))
#+end_src

** Change cursor color according to mode

#+BEGIN_SRC emacs-lisp
  ;; Change cursor color according to mode
  (defvar hcz-set-cursor-color-color "")
  (defvar hcz-set-cursor-color-buffer "")
  (defun hcz-set-cursor-color-according-to-mode ()
    "change cursor color according to some minor modes."
    ;; set-cursor-color is somewhat costly, so we only call it when needed:
    (let ((color
           (if buffer-read-only "white"
             (if overwrite-mode "#5599aa"
               "#f99157"))))
      (unless (and
               (string= color hcz-set-cursor-color-color)
               (string= (buffer-name) hcz-set-cursor-color-buffer))
        (set-cursor-color (setq hcz-set-cursor-color-color color))
        (setq hcz-set-cursor-color-buffer (buffer-name)))))
  (add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+END_SRC

** smart-mode-line

#+BEGIN_SRC emacs-lisp
  (req-package smart-mode-line
    :require smart-mode-line-powerline-theme
    :init
    (progn
      (setq sml/vc-mode-show-backend t)
      (setq sml/no-confirm-load-theme t)
      (sml/setup)))
#+END_SRC

*** diminish some mode

#+BEGIN_SRC emacs-lisp
  (diminish 'overwrite-mode)
#+END_SRC

** TODO [#C] spaceline
from spacemacs import spaceline for nice look

** fringe
改得細一點，預設值是 8 pixel

#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)
#+END_SRC

** rainbow-mode

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-mode
    :diminish rainbow-mode
    :init
    (add-hook 'prog-mode-hook 'rainbow-mode)
    (add-hook 'css-mode-hook 'rainbow-mode))
#+END_SRC

** rainbow-delimiters
ref: https://github.com/Fanael/rainbow-delimiters

#+BEGIN_SRC emacs-lisp
  (req-package rainbow-delimiters
    :config
    (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
    (add-hook 'org-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

** highlight-parentheses
set color of parenttheses like spacemacs.

#+BEGIN_SRC emacs-lisp
  (req-package  highlight-parentheses
    :init
    (progn
      (add-hook 'prog-mode-hook #'highlight-parentheses-mode)
      (setq hl-paren-delay 0.2)
      (setq hl-paren-colors '("Springgreen3"
                              "IndianRed1"
                              "IndianRed3"
                              "IndianRed4")))
    :config
    (progn
      ;; (global-highlight-parentheses-mode t)
      (set-face-attribute 'hl-paren-face nil :weight 'ultra-bold)))
#+END_SRC

* Chinese setup
** pangu-spacing

自動在中英文字間加入空白，以利閱讀

#+BEGIN_SRC emacs-lisp
  (req-package pangu-spacing
    :defer 1
    :config
    (progn
      (global-pangu-spacing-mode 1)

      (add-to-list 'pangu-spacing-inhibit-mode-alist 'eww-mode)
      (add-to-list 'pangu-spacing-inhibit-mode-alist 'elfeed-search-mode)
      (add-to-list 'pangu-spacing-inhibit-mode-alist 'elfeed-show-mode)

      ;; Always insert `real' space in org-mode.
      (dolist (m '(org-mode-hook markdown-mode-hook rst-mode-hook))
        (add-hook m '(lambda()
                       (set (make-local-variable 'pangu-spacing-real-insert-separtor) t))))
      ))
#+END_SRC

** fcitx

進入 normal mode 時，自動切換至英文輸入模式

#+BEGIN_SRC emacs-lisp
  (req-package fcitx
    :defer 1
    :config
      (fcitx-aggressive-setup)
    )
#+END_SRC

** set buffer to utf-8-unix
#+BEGIN_SRC emacs-lisp
  (defun buffer-to-utf-8-unix()
    (interactive)
    (set-buffer-file-coding-system 'utf-8-unix))

  (bind-key "C-c fu" 'buffer-to-utf-8-unix)
#+END_SRC

** Translate buffer via opencc

#+BEGIN_SRC emacs-lisp
  (defvar opencc-conv-temp-file (expand-file-name
                                 (concat user-cache-directory "opencc.tmp")))

  (defun opencc-conv-command ()
    (concat "opencc"
            " -i " opencc-conv-temp-file))

  (defun opencc-buffer ()
    "Convert chinese from simplified to variants and phrases of Taiwan"

    (interactive)

    (set-buffer-file-coding-system 'utf-8-unix)
    (let ((str (buffer-substring-no-properties (point-max) 1)))
      (with-temp-file opencc-conv-temp-file
        (insert str "\n")))

    (let ((result
           (shell-command-to-string (opencc-conv-command))))

      (erase-buffer)
      (insert result)
      (goto-char (point-min))))

  (bind-key "C-c fo" 'opencc-buffer)
#+END_SRC

** 萌典 moedict
安裝後，需執行一次 =moedict-install-dictionary= ，才能開始使用萌典。

#+BEGIN_SRC emacs-lisp
  (req-package moedict
    :require esqlite
    :loader :path
    :bind ("C-c m" . moedict))

  (setq browse-url-chromium-program "google-chrome-stable")
#+END_SRC

* 一般設定
** TODO Don't ask me when close emacs with process is running
#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (flet (process-list) ad-do-it))
#+END_SRC

** Don't ask me when kill process buffer
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

** Set prefer coding to utf-8
#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq system-time-locale "en_US" )
#+END_SRC

** Turn on syntax highlighting for all buffers:
#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC
** ethan-wspace

Takes care of trailing whitespaces (removal, highlighting)
https://github.com/glasserc/ethan-wspace

#+BEGIN_SRC emacs-lisp
  (req-package ethan-wspace
    :config
    (progn
      ;; Turn off `mode-require-final-newline' since ethan-wspace
      ;; supersedes `require-final-newline'.
      (setq mode-require-final-newline nil)

      ;; Enable ethan-wspace globally
      (global-ethan-wspace-mode 1)

      ;; Prevent etha-wspace touch my TAB on makefile mode
      (add-hook 'makefile-mode-hook
                '(lambda()
                   (setq ethan-wspace-errors (remove 'tabs ethan-wspace-errors))))

      ;; Ignore no trailing newline error
      (setq-default ethan-wspace-errors (remove 'no-nl-eof ethan-wspace-errors))))
#+END_SRC

*** 不指示空白行及行尾空白
#+BEGIN_SRC emacs-lisp :tangle no
  (setq-default indicate-empty-lines nil)
  (setq-default indicate-buffer-boundaries nil)
#+END_SRC

*** 存檔前清除多餘的空白
#+BEGIN_SRC emacs-lisp :tangle no
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Whitespaces and tabs
#+BEGIN_SRC emacs-lisp :tangle no
  (setq c-basic-offset 4)
  (setq python-indent-offset 4)
  (setq tab-width 4)
  (setq indent-tabs-mode nil)
#+END_SRC

** Default truncate lines
#+BEGIN_SRC emacs-lisp
  (toggle-truncate-lines t)
#+END_SRC

** Bell off
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

** Shorten answer
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Clipboard
#+BEGIN_SRC emacs-lisp
  (setq x-select-enable-clipboard t
        x-select-enable-primary t)
#+END_SRC

** Show keystrokes in progress
#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

** DONE Transient mark
If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp :tangle no
(transient-mark-mode t)
#+END_SRC

** DONE Show active region
#+BEGIN_SRC emacs-lisp :tangle no
  (make-variable-buffer-local 'transient-mark-mode)
  (put 'transient-mark-mode 'permanent-local t)
  (setq-default transient-mark-mode t)
#+END_SRC

** Remove text in active region if inserting text
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Save minibuffer history
When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.

#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
  (setq history-length 1000)
#+END_SRC

** Subword mode

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC
** Save files and exit (current file)
=C-x C-c= save-buffers-kill-emacs

#+begin_src emacs-lisp
  (bind-key "C-x k" 'kill-this-buffer)
#+END_SRC

** Parentheses
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis)
#+END_SRC

** Line Numbers
In most case, I'll make line numers display globally by =linum=.

#+BEGIN_SRC emacs-lisp
  (req-package linum
    :config
    (add-hook 'prog-mode-hook
              '(lambda () (linum-mode 1))))

  (setq column-number-mode t)
#+END_SRC

** Relative Line Numbers

#+BEGIN_SRC emacs-lisp
  (req-package linum-relative
    :init
    (progn
      (linum-relative-mode)
      (setq linum-relative-current-symbol "")
      (setq linum-relative-format "%4s")))
#+END_SRC

** Highlight numbers

ref: [[https://github.com/Fanael/highlight-numbers]]

#+BEGIN_SRC emacs-lisp
  (req-package highlight-numbers
    :require (parent-mode)
    :config
    ;; json-mode has it's own highlight numbers method
    (add-hook 'prog-mode-hook '(lambda()
                                 (if (not (derived-mode-p 'json-mode))
                                     (highlight-numbers-mode)))))
#+END_SRC

** Highlight FIXME, TODO

#+begin_src emacs-lisp
  (defun font-lock-comment-annotations ()
    "Highlight a bunch of well known comment annotations.
  This functions should be added to the hooks of major modes for programming."

    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))

  (add-hook 'prog-mode-hook 'font-lock-comment-annotations)
#+end_src

** Hind mouse point
#+BEGIN_SRC emacs-lisp
  (mouse-avoidance-mode 'banish)
#+END_SRC
** TODO async

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package async
    :init
    (progn
      (async-bytecomp-package-mode 1)
      (setq async-bytecomp-allowed-packages '(all))))
#+END_SRC

* Window Management
** winner-mode

Undo/redo window configuration with C-c <left>/<right>

#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

** switch-window

#+BEGIN_SRC emacs-lisp
(req-package switch-window
  :bind ("C-x o" . switch-window))
#+END_SRC

* Buffer Management
** Edit current buffer as root

#+BEGIN_SRC emacs-lisp
  (defun edit-current-file-as-root ()
    "Edit the file that is associated with the current buffer as root"
    (interactive)
    (if (buffer-file-name)
        (progn
          (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
          (find-file file))
      (message "Current buffer does not have an associated file.")))
#+END_SRC

** Delete current buffer file

#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+END_SRC

** Rename current Buffer and file

#+BEGIN_SRC emacs-lisp
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
#+END_SRC

** TODO Clone current Buffer and file

#+BEGIN_SRC emacs-lisp :tangle no
  (defun clone-current-buffer-file ()
    "Clone current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
#+END_SRC

** Auto revert

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*")) ;; disable revert query
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-b" 'ibuffer)
  (autoload 'ibuffer "ibuffer" "List buffers." t)
#+END_SRC

** Dired relative functions
*** TODO dired
#+BEGIN_SRC emacs-lisp :tangle no
(req-package dired
  :commands dired
  :require (helm-swoop autorevert diff-hl)
;  :init (add-hook 'dired-load-hook (lambda () (load "dired-x")
;                                     ;; Set global variables here.  For example:
;                                     ;; (setq dired-guess-shell-gnutar "gtar")
;                                    ))
  :config (progn (define-key dired-mode-map (kbd "M-i") 'helm-swoop)
                 (define-key dired-mode-map (kbd "M-RET") 'dired-find-file-other-window)
                 (add-hook 'dired-mode-hook (lambda () (auto-revert-mode 1)))
                 (add-hook 'dired-mode-hook (lambda () (diff-hl-dired-mode 1)))
                 ))
#+END_SRC

*** dired+

#+BEGIN_SRC emacs-lisp
  (req-package dired+
    :init (progn
            (diredp-toggle-find-file-reuse-dir 1)
            (autoload 'dired-async-mode "dired-async.el" nil t)
            (dired-async-mode 1)))
#+END_SRC

*** openwith

#+BEGIN_SRC emacs-lisp
  (req-package openwith
    :config
    (progn
      (openwith-mode t)
      (setq openwith-associations
            (list (list (openwith-make-extension-regexp '("jpg" "jpeg" "png"))
                        "feh -FY" '(file))
                  (list (openwith-make-extension-regexp '("flac" "mp3" "wav" "aiff" "m4a" "aac"))
                        "mpv" '(file))
                  (list (openwith-make-extension-regexp '("avi" "flv" "mov" "mp4" "rmvb" "m2ts"
                                                          "mpeg" "mpg" "ogg" "wmv" "mkv"))
                        "mpv" '(file))
                  ))))

#+END_SRC

** Multi-term
這個比 eshell 好用。原因很簡單…習慣！

參考：
http://rawsyntax.com/blog/learn-emacs-zsh-and-multi-term/
http://blog.jobbole.com/51598/

將 shell 設為 zsh，呼叫 shell 的快捷鍵設為 <C-x  t>。
C-! 以 popup window 的方式在下方開一個 term 視窗

#+BEGIN_SRC emacs-lisp
  (req-package multi-term
    :init (setq multi-term-program "/bin/zsh")
    :bind ("C-x t" . multi-term)
    :config
    (progn (add-hook 'term-mode-hook
                     (lambda ()
                       (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
                       (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))))
           (add-hook 'term-mode-hook
                     (lambda ()
                       (setq term-buffer-maximum-size 10000)))
           (add-hook 'term-mode-hook
                     (lambda ()
                       (define-key term-raw-map (kbd "C-y") 'term-paste)))))
#+END_SRC

*** popup multi-term

#+BEGIN_SRC emacs-lisp
  (defun popwin-term:multi-term ()
    (interactive)
    (popwin:display-buffer-1
     (or (get-buffer "*terminal*")
         (save-window-excursion
           (call-interactively 'multi-term)))
     :default-config-keywords '(:position :bottom :height 12 :stick t)))

  (bind-key "C-!" 'popwin-term:multi-term)
#+END_SRC

** Create *scratch* automatically

Sometimes I'll kill the =*scratch*= buffer to make it clean, just use
following function to let emacs re-create it automatically.

#+BEGIN_SRC emacs-lisp
  (run-with-idle-timer 1 t
                       '(lambda ()
                          (unless (get-buffer "*scratch*")
                            (with-current-buffer
                                (get-buffer-create "*scratch*")
                              (lisp-interaction-mode)
                              ))))
#+END_SRC

** recentf

#+BEGIN_SRC emacs-lisp
(req-package recentf
  :config
  (progn
    (setq recentf-save-file (concat user-cache-directory "recentf"))
    (recentf-mode 1)
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 10)))
#+end_src

** save-place
自動記錄每一個檔案，遊標所在的位置，下次再開啟這個檔案時，遊標會自動到上次看的地方。

#+BEGIN_SRC emacs-lisp
(req-package saveplace
             :config
               (progn
                 (setq save-place-file (concat user-cache-directory "places"))
                 (setq-default save-place t)))
#+end_src

** uniquift
Add parts of each file's directory to the buffer name if not unique

#+BEGIN_SRC emacs-lisp
(req-package uniquify
  :config
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

** backup

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,(concat user-emacs-directory
                                                 "backups"))))
  (setq backup-by-copying-when-linked t)
  (setq delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
#+end_src

*** 不要再產生 “backup~” 或 “#autosave#” 檔案

#+begin_src emacs-lisp
  (setq make-backup-files nil) ; stop creating those backup~ files
  (setq auto-save-default nil) ; stop creating those #autosave# files
#+end_src

** pdf-tools
如果報錯：無安裝 epdfinfo，執行一次 ~(pdf-tools-install)~ 即可。

#+BEGIN_SRC emacs-lisp
  (req-package pdf-tools
    ;;:commands pdf-view-mode
    :init (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
    :config (progn
              (pdf-tools-install)
              (setq pdf-view-continuous t)

              (bind-keys :map pdf-view-mode-map
                         ("j" . pdf-view-next-line-or-next-page)
                         ("k" . pdf-view-previous-line-or-previous-page)
                         ("H" . pdf-view-next-page)
                         ("L" . pdf-view-previous-page)
                         ("e" . pdf-view-scroll-down-or-previous-page)
                         ("d" . pdf-view-scroll-up-or-next-page)
                         ;; ("gg" . pdf-view-first-page)
                         ;; ("G" . pdf-view-last-page)
                         ("=" . pdf-view-fit-width-to-window)
                         ("-" . pdf-view-shrink)
                         ("+" . pdf-view-enlarge))
              ))
#+END_SRC

* 編輯功能                                                             :edit:
** Smooth-scrolling

#+BEGIN_SRC emacs-lisp
  (req-package smooth-scrolling
    :commands (smooth-scrolling-mode)
    :init
    (progn
      (smooth-scrolling-mode 1)
      (setq smooth-scroll-margin 5)))
#+END_SRC

** avy
ref: https://github.com/abo-abo/avy

#+BEGIN_SRC emacs-lisp
  (req-package avy
    :commands (global-avy-mode avy-goto-char avy-goto-line)
    :bind (("C-z" . avy-goto-char)
           ("M-g f" . avy-goto-line)))
#+END_SRC

** ace-pinyin
ref: https://github.com/cute-jumper/ace-pinyin

#+BEGIN_SRC emacs-lisp
  (req-package ace-pinyin
    :config
    (progn
      (ace-pinyin-global-mode +1)
      (setq ace-pinyin-simplified-chinese-only-p nil)
      ))
#+END_SRC

** ace-link
ref: https://github.com/abo-abo/ace-link

#+BEGIN_SRC emacs-lisp
  (req-package ace-link
    :config
    (ace-link-setup-default "f"))
#+END_SRC

** Smart home
按 home 鍵，可讓遊標回到行首或第一個非空字元

ref: https://github.com/tjarvstrand/config-files/blob/master/.emacs.d/lib/smart-beginning-of-line.el

#+BEGIN_SRC emacs-lisp
  (defun smart-beginning-of-line ()
    "Move point to first non-whitespace character or beginning-of-line.

  Move point to the first non-whitespace character on this line.
  If point was already at that position, move point to beginning of line."

    (interactive)
    (let ((oldpos (point)))
      (back-to-indentation)
      (and (= oldpos (point))
           (beginning-of-line))))

  (bind-key [home] 'smart-beginning-of-line)
  (bind-key* "C-a" 'smart-beginning-of-line)
#+END_SRC

** Find symbol at point

Source: http://blog.jorgenschaefer.de/2012/11/emacs-search-for-symbol-at-point.html

#+BEGIN_SRC emacs-lisp
  (bind-key "C-d" 'fc/isearch-yank-symbol isearch-mode-map)

  ;; (define-key isearch-mode-map (kbd "C-d")
  ;; 'fc/isearch-yank-symbol)

  (defun fc/isearch-yank-symbol ()
    "Yank the symbol at point into the isearch minibuffer.

  C-w does something similar in isearch, but it only looks for
  the rest of the word. I want to look for the whole string. And
  symbol, not word, as I need this for programming the most."

    (interactive)
    (isearch-yank-string
     (save-excursion
       (when (and (not isearch-forward)
                  isearch-other-end)
         (goto-char isearch-other-end))
       (thing-at-point 'symbol))))
#+END_SRC

** Delete whole line or multi-lines

ref: http://endlessparentheses.com/kill-entire-line-with-prefix-argument.html

C-1 C-k 刪去整行
C-3 C-k 刪去 3 行

#+BEGIN_SRC emacs-lisp
  (defmacro bol-with-prefix (function)
    "Define a new function which calls FUNCTION.
  Except it moves to beginning of line before calling FUNCTION when
  called with a prefix argument. The FUNCTION still receives the
  prefix argument."
    (let ((name (intern (format "endless/%s-BOL" function))))
      `(progn
         (defun ,name (p)
           ,(format
             "Call `%s', but move to BOL when called with a prefix argument."
             function)
           (interactive "P")
           (when p
             (forward-line 0))
           (call-interactively ',function))
         ',name)))

  (global-set-key [remap paredit-kill] (bol-with-prefix paredit-kill))
  (global-set-key [remap org-kill-line] (bol-with-prefix org-kill-line))
  (global-set-key [remap kill-line] (bol-with-prefix kill-line))
#+END_SRC

** hungry-delete

#+BEGIN_SRC emacs-lisp
  (req-package hungry-delete
    :init (global-hungry-delete-mode 1))
#+END_SRC

** move-text

用 M-up, M-down 移動當行或 region

ref: http://emacs.stackexchange.com/questions/4238/moving-line-with-move-text-up-doesnt-move-point

#+BEGIN_SRC emacs-lisp
  ;move line up down
  (defun move-text-internal (arg)
    (cond
     ((and mark-active transient-mark-mode)
      (let ((column (current-column))
            (pos (< (point) (mark)))
            (text (delete-and-extract-region (point) (mark))))
        (forward-line arg)
        (move-to-column column t)
        (set-mark (point))
        (insert text)
        (and pos (exchange-point-and-mark))
        (setq deactivate-mark nil)))
     (t
      (let ((column (current-column)))
        (beginning-of-line)
        (when (or (> arg 0) (not (bobp)))
          (forward-line)
          (when (or (< arg 0) (not (eobp)))
            (transpose-lines arg)
            ;; Account for changes to transpose-lines in Emacs 24.3
            (when (and (eval-when-compile
                         (not (version-list-<
                               (version-to-list emacs-version)
                               '(24 3 50 0))))
                       (< arg 0))
              (forward-line -1)))
          (forward-line -1))
        (move-to-column column t)))))

  (defun move-text-down (arg)
    "Move region (transient-mark-mode active) or current line
    arg lines down."
    (interactive "*p")
    (move-text-internal arg))

  (defun move-text-up (arg)
    "Move region (transient-mark-mode active) or current line
    arg lines up."
    (interactive "*p")
    (move-text-internal (- arg)))

  (bind-key "M-<up>" 'move-text-up)
  (bind-key "M-<down>" 'move-text-down)
#+END_SRC

** undo-tree
用 M-x undo-tree-visualize (C-x u) 看 undo-tree，很直覺。

#+BEGIN_SRC emacs-lisp
  (req-package undo-tree
    :diminish ""
    :init
    (progn
      (setq undo-tree-auto-save-history t)
      (setq undo-tree-history-directory-alist
            `((".*" . ,(expand-file-name "undo" user-cache-directory))))
      (global-undo-tree-mode)))
#+END_SRC

** expand-region

M-SPC 設定 mark
C-= 擴展
C-- C-= 縮減
C-0 C-= 還原

ref: https://github.com/magnars/expand-region.el

#+BEGIN_SRC emacs-lisp
  (bind-key "M-SPC" 'set-mark-command)
  (req-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

** smartparens
ref: https://github.com/Fuco1/smartparens
ref: https://ebzzry.github.io/emacs-pairs.html

#+BEGIN_SRC emacs-lisp
  (req-package smartparens-config
    :ensure smartparens
    :diminish (smartparens-mode)
    :init
    (progn
      (smartparens-global-mode t)
      (show-smartparens-global-mode t)))
#+END_SRC

** Emulation of the vi % command
ref: https://www.emacswiki.org/emacs/NavigatingParentheses

#+BEGIN_SRC emacs-lisp
  (defun goto-match-paren (arg)
    "Go to the matching parenthesis if on parenthesis, otherwise insert %.
    vi style of % jumping to matching brace."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1)))))

  (bind-key "%" 'goto-match-paren)
#+END_SRC

** iedit

[[https://github.com/victorhge/iedit][iedit]] let you edit multiple regions in the same way simultaneously.

Normal scenario of Iedit mode is like:

- Highlight certain contents - by press C-; (The default key binding)
  All occurrences of a symbol, string or a rectangle in the buffer or
  a region may be highlighted corresponding to current mark, point and
  prefix argument.  Refer to the document of `iedit-mode’ for
  details.

- Edit one of the occurrences The change is applied to other
  occurrences simultaneously.

- Finish - by pressing C-; again

#+BEGIN_SRC emacs-lisp
  (req-package iedit
    :init (setq iedit-unmatched-lines-invisible-default t))
#+END_SRC

** comment/uncomment-line

Source: http://endlessparentheses.com/implementing-comment-line.html?source=rss

#+BEGIN_SRC emacs-lisp
  (defun endless/comment-line (n)
    "Comment or uncomment current line and leave point after it.

  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above."

    (interactive "p")
    (comment-or-uncomment-region
     (line-beginning-position)
     (goto-char (line-end-position n)))
    (forward-line 1)
    (back-to-indentation))

  (bind-key "M-;" #'endless/comment-line)
#+END_SRC

** aggressive-indent
ref: http://endlessparentheses.com/permanent-auto-indentation.html

非文字模式下，自動縮排。

#+BEGIN_SRC emacs-lisp
  (req-package aggressive-indent
    :init (global-aggressive-indent-mode))
#+END_SRC

** Company mode

#+BEGIN_SRC emacs-lisp
  (req-package company
    :diminish company-mode
    :init (add-hook 'after-init-hook 'global-company-mode)
    :config
    (progn
      (global-company-mode t)

      (setq company-idle-delay 0.1)
      (setq company-tooltip-limit 10)
      (setq company-minimum-prefix-length 2)
      (setq company-echo-delay 0)

      (add-to-list 'company-backends 'company-ispell t)
      ))
#+END_SRC

*** Add quickhelp in company-mode
ref: https://github.com/expez/company-quickhelp

#+BEGIN_SRC emacs-lisp
  (req-package company-quickhelp
    :require company
    :config (company-quickhelp-mode 1))
#+END_SRC

*** keybindings

M-n/p select up/down
<return> to complete
<Tab> complete the common part
C-s
C-r
C-o
<f1> to dispaly the documentation
<C-w> to see its source
** Flycheck

#+BEGIN_SRC emacs-lisp
  (req-package flycheck
    :diminish (flycheck-mode . " ✓ ")
    :config
    (progn
      (add-hook 'after-init-hook 'global-flycheck-mode)
      (setq flycheck-indication-mode 'right-fringe)
      (define-key flycheck-mode-map flycheck-keymap-prefix nil)
      (setq flycheck-keymap-prefix (kbd "C-c v"))
      (define-key flycheck-mode-map flycheck-keymap-prefix flycheck-command-map)))
#+END_SRC
** Spell checking
*** Ispell

if want to use "hunspell", then must install hunspell and hunspell_en in OS.

#+BEGIN_SRC emacs-lisp
  (req-package ispell
    :loader :built-in
    :config                               ;
    (progn
      (cond
       ((executable-find "aspell")
        (setq ispell-program-name "aspell")
        (setq ispell-extra-args   '("--sug-mode=ultra"
                                    "--lang=en_US"
                                    ;; "--ignore=2"
                                    ;; "--run-together"
                                    ;; "--run-together-limit=5"
                                    ;; "--run-together-min=2"
                                    )))
       ((executable-find "hunspell")
        (setq ispell-program-name "hunspell")
        (setq ispell-extra-args   '("-d en_US"))
        ;; (setq ispell-local-dictionary-alist ;
        ;; '(("zh_TW" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
        ;; ))
        )
       )
      (setq ispell-local-dictionary "en_US")
      (setq ispell-silently-savep t)
      ))
#+END_SRC

*** flyspell

=C-.= corrects word at point.
=C-,​= to jump to next misspelled word.
=M-$= correct word at point
 
#+BEGIN_SRC emacs-lisp
  (req-package flyspell
    :require (ispell)
    :init
    (progn
      ;; (add-hook 'prog-mode-hook #'flyspell-prog-mode) 
      (add-hook 'prog-mode-hook #'turn-on-flyspell)
      (add-hook 'text-mode-hook #'turn-on-flyspell)
      (add-hook 'org-mode-hook  #'turn-on-flyspell))
    :config (unbind-key "C-;" flyspell-mode-map))
#+END_SRC

*** flyspell-correct-ivy

#+BEGIN_SRC emacs-lisp
  (req-package flyspell-correct-ivy
    :defer 1  
    :require (flyspell ivy flyspell-correct)
    :bind (:map flyspell-mode-map
                ("M-$" . flyspell-correct-word-generic))
    :config
    (progn
      (setq flyspell-correct-interface 'flyspell-correct-ivy)
      ;; (bind-keys :map flyspell-mode-map 
      ;; ("M-$" . flyspell-correct-word-generic))
      ;; bind flyspell-correct-word-generic
      ;; (define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-word-generic)
      ;; (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-previous-word-generic)
      ))
#+END_SRC

*** Make spell-checking tool ignore some org-mode section
see: http://emacs.stackexchange.com/questions/450/intelligent-spell-checking-in-org-mode

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ispell
    '(progn
       (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
       (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
       ))
#+END_SRC

** popwin

#+BEGIN_SRC emacs-lisp
  (req-package popwin
    :init
    (progn
      (setq helm-popwin
            '(("*Flycheck errors*" :height 10)
              ("*Helm Find Files*" :height 0.3)
              ("^\*helm.+\*$" :regexp t :height 15))))
    :config
    (progn
      (popwin-mode 1)
      (push '("*helm semantic/imenu*" :width 0.382 :position left) popwin:special-display-config)
      (push '(" *undo-tree*" :width 0.3 :position right) popwin:special-display-config)
      ))
#+END_SRC

** Unbind-key
#+BEGIN_SRC emacs-lisp
  (unbind-key "C-\\")
  (unbind-key "C-z")
  (unbind-key "C-x C-z")
  (unbind-key "C-x m")
#+END_SRC

** Which-key
#+BEGIN_SRC emacs-lisp
  (req-package which-key
    :config
    (progn
      (setq which-key-idle-delay 0.5)
      (which-key-mode)
      (which-key-setup-side-window-bottom)
      (setq which-key-side-window-max-width 0.25)))
#+END_SRC

** discover-my-major

[[https://github.com/steckerhalter/discover-my-major][discover-my-major]] make you discover key bindings and their meaning for the
current Emacs major mode.

GitHub: https://github.com/steckerhalter/discover-my-major

#+BEGIN_SRC emacs-lisp
  (req-package discover-my-major
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-m" . discover-my-mode)))
#+END_SRC

* helm

Helm offers a command called =helm-mini= that opens a =helm= buffer
populated with recent files and currently open buffers. I want Helm
everywhere, so instead we'll activate =helm-mode= and work from there.

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package helm-config 
    :require (popwin async)
    :diminish helm-mode
    :init (progn
            (setq helm-ff-auto-update-initial-value)
            (setq popwin:special-display-config
                  (append helm-popwin
                          popwin:special-display-config))
            ;;(bind-key* "M-x" 'helm-M-x)
            ;;(bind-key* "C-x f" 'helm-recentf)
            ;; (bind-key* "C-x b" 'helm-mini)
            ;; (bind-key* "C-x C-f" 'helm-find-files)
            )
    ;; :config (helm-mode 1)
    )
#+END_SRC

* Completion
** ivy
看起來比 helm 好看些，且快速

#+BEGIN_SRC emacs-lisp
  (req-package ivy
    :require (counsel swiper)
    :bind (("C-s" . swiper)
           ("M-x" . counsel-M-x)
           ("C-x f" . ivy-recentf)
           ("C-x l" . counsel-locate)
           ("C-c k" . counsel-ag)
           ("C-:" . counsel-company)
           )
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq completion-in-region-function 'ivy-completion-in-region)
    
      (eval-after-load 'magit
        '(setq magit-completing-read-function 'ivy-completing-read))

      ))
#+END_SRC

** Open recent directory with dired via ivy
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ivy'
    '(progn
       (defun counsel-goto-recent-directory ()
         "Open recent directory with dired"

         (interactive)
         (unless recentf-mode (recentf-mode 1))
         (let ((collection
                (delete-dups
                 (append (mapcar 'file-name-directory recentf-list)
                         ;; fasd history
                         (if (executable-find "fasd")
                             (split-string (shell-command-to-string "fasd -ld") "\n" t))))))
           (ivy-read "directories:" collection :action 'dired)))

       (bind-key "C-h C-\\" 'counsel-goto-recent-directory)
       ))
#+END_SRC

** ivy swoop like helm-swoop
ref: https://github.com/abo-abo/swiper/issues/3

#+BEGIN_SRC emacs-lisp
#+END_SRC

* Project relative function                                        :project:
** TODO Magit

#+BEGIN_SRC emacs-lisp
  (req-package magit
    :require (ivy)
    :init
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")
      (setq magit-auto-revert-mode nil)
      (setq magit-save-some-buffers nil)
      (setq magit-set-upstream-on-push t)
      (setq magit-diff-refine-hunk t)
      (setq magit-completing-read-function 'ivy-completing-read)
      (setq magit-default-tracking-name-function 'magit-default-tracking-name-branch-only))
    :bind ("C-c g" . magit-status))

    (req-package magit-filenotify
      :require magit
      :init (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))
#+END_SRC

** TODO diff-hl

可以顯示出尚未 stage 的程式碼

#+BEGIN_SRC emacs-lisp
  (req-package diff-hl
    :init (global-diff-hl-mode))
#+END_SRC

** TODO ediff
#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-vertically)
  (setq ediff-merge-split-window-function 'split-window-vertically)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

** projectile

#+BEGIN_SRC emacs-lisp
  (req-package projectile
    :require (ivy)
    :init
    (progn (projectile-global-mode)
           (setq projectile-completion-system 'ivy)))
#+END_SRC

* Interactive Commands
** convert org, markdown, kindle file
*** get major mode of current buffer

#+BEGIN_SRC emacs-lisp
  (defun current-buffer-mode()
    "Return the major-mode associated with current buffer."

    (with-current-buffer (buffer-name)
      major-mode))
#+END_SRC

*** convert org-mode to pdf via pandoc
#+BEGIN_SRC emacs-lisp
  (defun org-to-pdf ()
    "Conver org to pdf and open the pdf file."

    (interactive)
    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (let* ((pdf-name (concat (file-name-sans-extension buffer-file-name) ".pdf")))

            (message "convert to %s" (file-name-nondirectory pdf-name))

            (let* ((latex-engin "xelatex")
                   (template "/home/mario/.pandoc/default.latex")
                   (result (shell-command
                            (format "pandoc %s --latex-engine %s --template %s -s -o %s"
                                    buffer-file-name
                                    latex-engin
                                    template
                                    pdf-name
                                    ))))
              (if (eq result 0)
                  (find-file pdf-name)
                (message result)))
            ))
      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

*** convert markdown to orgmode via pandoc

#+BEGIN_SRC emacs-lisp
  (defun md-to-org ()
    "Convert markdown to org for edit. Especially for evernote/geeknote."

    (interactive)
    (if (eq (current-buffer-mode) 'markdown-mode)
        (let* ((default-directory "/mnt/lvm-data/Documents/")
               (md-buffer-name (buffer-name))
               (md-file-name (buffer-file-name))
               (md-org-buffer (find-file (read-file-name "" default-directory)))
               (md-org-file-name (buffer-file-name)))

          (if (not (file-exists-p md-org-file-name))
              (progn
                (shell-command (format "pandoc -f markdown -t org -o %s %s"
                                       md-org-file-name
                                       md-file-name))
                (revert-buffer nil t)
                (goto-char (point-min))
                (insert "#+TITLE:\n")
                (save-buffer)
                (kill-buffer md-buffer-name))
            (message "%s is already exist." md-org-file-name)))
      (message "Current buffer must be 'markdown-mode'!")))
#+END_SRC

*** send command to wpub via async

#+BEGIN_SRC emacs-lisp
(defun async-wpub (cmd)
    (message "%s" cmd)
    (let ((wpub-buffer "*async-wpub*")
          (name "async-wpub"))
      (start-file-process-shell-command name wpub-buffer cmd)
      ))
#+END_SRC

*** send org-mode file to kindle via wpub
#+BEGIN_SRC emacs-lisp

  ;; send .org to my kindle via wpub.py
  (defun org-to-kindle ()
    "Send current buffer to kindle via wpub.py"

    (interactive)

    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (message "%s is sending..." (buffer-name))

          ;; (set-buffer-file-coding-system 'utf-8-unix)
          (let* ((wpub-temp-file (expand-file-name
                                  (concat user-cache-directory (buffer-name))))
                 (wpub-command (format "wpub -f org '%s'" wpub-temp-file))
                 (str (buffer-substring-no-properties (point-max) 1)))

            (with-temp-file wpub-temp-file
              (insert str "\n"))

            (async-wpub wpub-command)))

      (message "Current buffer must be 'org-mode'!")))

#+END_SRC

*** TODO url to kindle via wpub (add quit options)
#+BEGIN_SRC emacs-lisp
  (defun url-to-kindle (url)
    (interactive)
    (if url
        (let* ((wpub-cmd-opencc (if (y-or-n-p "Convert to Traditional Chinese?")
                                    "-o"
                                  ""))
               (wpub-command-for-async (format "wpub %s '%s'" wpub-cmd-opencc url)))
          (async-wpub wpub-command-for-async))
      )
    )

#+END_SRC

*** eww to kindle via wpub
#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle ()
    "send the content of current url to kindle via wpub"

    (interactive)
    (url-to-kindle eww-current-url)
    )
#+END_SRC

*** send url or org to kindle
#+BEGIN_SRC emacs-lisp
(defun send-url-or-org-to-kindle ()
    "Send content of current buffer to kindle"

    (interactive)
    (cond
     ((not (eq eww-current-url nil)) (eww-to-kindle))
     ((eq (current-buffer-mode) 'org-mode) (org-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-search-mode) (elfeed-search-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-show-mode) (elfeed-show-to-kindle))
     (t (message "%s" "Can't send this page to kindle."))))
#+END_SRC

*** bindkeys
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c oo" 'md-to-org)
  (bind-key "C-c op" 'org-to-pdf)
  (bind-key "C-c ok" 'send-url-or-org-to-kindle)
#+END_SRC

** Insert stock ids at point
#+BEGIN_SRC emacs-lisp
  (req-package esqlite
    :config
    (progn
      (defun insert-stock-id-at-point ()
        "Insert stock ids at point."

        (interactive)

        (if (string= ".elfeed.org" (buffer-name))
            (let* ((db-name "/mnt/lvm-data/Programing/stock4/db/stock2.db")
                   (sql-fetch-stock-ids "select s.sid, i.name from summary as s, stock_info as i where s.sid=i.sid and s.userid=\"mariolong\""))

              (dolist (sid (esqlite-read db-name sql-fetch-stock-ids))
                (insert (format "**** [[https://tw.stock.yahoo.com/rss/s/%s][%s-%s]]\n"
                                (car sid) (car sid) (second sid)))))

          (message "%s" "Must in '.elfeed.org'")))

      (bind-key "C-c fi" 'insert-stock-id-at-point)
      ))
#+END_SRC
* Internet relative functions                                      :internet:
** helm-google

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package helm-google
    :bind ("C-c hg" . helm-google))
#+END_SRC

** eww (Emacs Web broWser)
*** eww basic
#+BEGIN_SRC emacs-lisp
  (req-package eww
    :defer 1
    :loader :built-in
    :config
    (progn
      (setq browse-url-browser-function 'eww-browse-url)

      (setq browse-url-generic-program (executable-find "google-chrome-stable")
            shr-external-browser 'browse-url-generic)

      (add-hook 'eww-mode-hook '(lambda ()
                                  (toggle-truncate-lines nil)))

      ;; (unbind-key "g" eww-mode-map)
      ;; (unbind-key "o" eww-mode-map)
      (bind-keys :map eww-mode-map
                 ;; ("gg" . beginning-of-buffer)
                 ;; ("G" . end-of-buffer)
                 ("j" . next-line)
                 ("k" . previous-line)
                 ("l" . forward-char)
                 ("h" . backward-char)
                 ("d" . scroll-up-command)
                 ("e" . scroll-down-command)
                 ("B" . eww-browse-with-external-browser)
                 ;; ("f" . ace-link-eww)
                 ("m" . endless/toggle-image-display)
                 ("q" . eww-quit-reset-image-flag)
                 ("H" . eww-back-url)
                 ("L" . eww-forward-url)
                 ("ok" . eww-to-kindle)
                 ("oo" . eww-to-org)
                 ("yy" . eww-copy-page-url))
      ))
#+END_SRC

*** toggle image display

#+BEGIN_SRC emacs-lisp

  (defun eww-quit-reset-image-flag ()
    "reset image-flag"

    (interactive)
    (setq endless/display-images t)
    ;; (quit-window)
    (kill-buffer "*eww*")
    )

  (defvar-local endless/display-images t)

  (defun endless/toggle-image-display ()
    "Toggle images display on current buffer."
    (interactive)

    (setq endless/display-images
          (null endless/display-images))
    (endless/backup-display-property endless/display-images))

  (defun endless/backup-display-property (invert &optional object)
    "Move the 'display property at POS to 'display-backup.
  Only applies if display property is an image.
  If INVERT is non-nil, move from 'display-backup to 'display
  instead.
  Optional OBJECT specifies the string or buffer. Nil means current
  buffer."
    (let* ((inhibit-read-only t)
           (from (if invert 'display-backup 'display))
           (to (if invert 'display 'display-backup))
           (pos (point-min))
           left prop)
      (while (and pos (/= pos (point-max)))
        (if (get-text-property pos from object)
            (setq left pos)
          (setq left (next-single-property-change pos from object)))
          (if (or (null left) (= left (point-max)))
            (setq pos nil)
          (setq prop (get-text-property left from object))
          (setq pos (or (next-single-property-change left from object)
                        (point-max)))
          (when (eq (car prop) 'image)
            (add-text-properties left pos (list from nil to prop) object))))))

#+END_SRC

*** eww to org
save current web page to org-mode

#+BEGIN_SRC emacs-lisp
  (defun eww-to-org ()
    "save current page to org file from eww"

    (interactive)
    (if (eq (current-buffer-mode) 'eww-mode)
        (let* ((back-current-url eww-current-url)
               (default-directory "/mnt/lvm-data/Documents/eww/")
               (org-file-name (expand-file-name (concat eww-current-title ".org") default-directory)))

          (write-file org-file-name)
          (eww back-current-url)
          (message "write file: %s" eww-to-org-file-name)
          )))
#+END_SRC
*** TODO eww browse at point (add prefix key to open eww directly)

#+BEGIN_SRC emacs-lisp
  (defun browse-at-point ()
    "browse at point: selected region or url or single word
  if cursor at whitespace then call eww wait for input some thing."

    (interactive)

    (defun thing-at-point-to-eww ()
      (unless (setq ret (thing-at-point 'url))
        (unless (setq ret (thing-at-point 'symbol))
          (setq ret (thing-at-point 'whitespace))
          ))

      (if (null ret)
          (setq ret ""))

      (s-trim ret))

    (if mark-active
        (setq thing (buffer-substring-no-properties (region-beginning) (region-end)))
      (setq thing (thing-at-point-to-eww)))

    (if (string= "" thing)
        (call-interactively 'eww)
      (eww thing)))

  (bind-key "C-c b" 'browse-at-point)
#+END_SRC

*** Yahoo! dictionary

#+BEGIN_SRC emacs-lisp
  (defun dictionary-at-point ()
    "find the definition from Yahoo Dictionary."

    (interactive)
    (let ((dictionary-url "https://tw.dictionary.yahoo.com/dictionary?p=")
          (word (read-from-minibuffer "Input word:" (word-at-point))))
      (if word
          (eww (concat dictionary-url word)))))

  (bind-key "C-c y" 'dictionary-at-point)
#+END_SRC

** elfeed
*** elfeed basic
#+BEGIN_SRC emacs-lisp
  (req-package elfeed
    :bind ("C-c e" . elfeed)
    :config
    (progn
      (custom-set-faces
       '(elfeed-search-unread-title-face ((t :inherit default)))
       '(elfeed-search-title-face ((t :inherit font-lock-comment-face)))
       '(elfeed-search-date-face ((t (:inherit font-lock-string-face))))
       '(elfeed-search-feed-face ((t (:inherit font-lock-doc-face))))
       '(elfeed-search-tag-face ((t (:inherit font-lock-constant-face))))
       )

      (setq elfeed-search-filter "@1-weeks-ago +unread")
      (setf url-queue-timeout 30)

      (add-hook 'elfeed-search-mode-hook
                '(lambda() (progn
                             (elfeed-update))))

      (add-hook 'elfeed-new-entry-hook
                '(lambda() (progn
                             (elfeed-make-tagger :before "1 week ago"
                                                 :remove 'unread))))

      (defun elfeed-search-mark-all-read ()
        "mark all feed as read in elfeed search mode"

        (interactive)
        (mark-whole-buffer)
        (elfeed-search-untag-all-unread)
        )

      (defun elfeed-search-mark-read ()
        "mark current line to read and scroll screen down in elfeed search mode"

        (interactive)
        (elfeed-search-untag-all-unread)
        (when (< (smooth-scroll-lines-below-point) smooth-scroll-margin)
          (scroll-up-line))
        )

      (defun elfeed-entry-url (entry)
        (and entry (elfeed-entry-link entry)))

      (defun get-elfeed-search-url ()
        (elfeed-entry-url (elfeed-search-selected :ignore-region)))

      (defun get-elfeed-show-url ()
        (elfeed-entry-url elfeed-show-entry))

      (defun copy-elfeed-search-url ()
        "copy url to clipboard"

        (interactive)
        (setq return-url (get-elfeed-search-url))
        (message "%s" return-url)
        (kill-new return-url))

      (defun copy-elfeed-show-url ()
        "copy url to clipboard"

        (interactive)
        (setq return-url (get-elfeed-show-url))
        (message "%s" return-url)
        (kill-new return-url))

      (defun elfeed-search-to-kindle ()
        "send current content to kindle"

        (interactive)
        (url-to-kindle (get-elfeed-search-url)))

      (defun elfeed-show-to-kindle ()
        "send current content to kindle"

        (interactive)
        (url-to-kindle (get-elfeed-show-url)))

      (defun elfeed-search-external-browser ()
        "open current url via extenal browser"

        (interactive)
        (elfeed-search-browse-url t))

      (defun elfeed-show-external-browser ()
        "open current url via extenal browser"

        (interactive)
        (elfeed-show-visit t))

      ;; (unbind-key "g" elfeed-search-mode-map)
      (bind-keys :map elfeed-search-mode-map
                 ;; ("gg" . beginning-of-buffer)
                 ;; ("G" . end-of-buffer)
                 ("n" . elfeed-search-mark-read)
                 ("j" . elfeed-search-mark-read)
                 ("k" . previous-line)
                 ("l" . forward-char)
                 ("h" . backward-char)
                 ("d" . scroll-up-command)
                 ("e" . scroll-down-command)
                 ("g" . elfeed-update)
                 ("a" . elfeed-search-mark-all-read)
                 ("B" . elfeed-search-external-browser)
                 ("y" . copy-elfeed-search-url)
                 ("w" . copy-elfeed-search-url)
                 ("ok" . elfeed-search-to-kindle))

      ;; (unbind-key "g" elfeed-show-mode-map)
      (bind-keys :map elfeed-show-mode-map
                 ;; ("gg" . beginning-of-buffer)
                 ;; ("G" . end-of-buffer)
                 ("j" . next-line)
                 ("k" . previous-line)
                 ("l" . forward-char)
                 ("h" . backward-char)
                 ("d" . scroll-up-command)
                 ("e" . scroll-down-command)
                 ("B" . elfeed-show-external-browser)
                 ("y" . copy-elfeed-show-url)
                 ("w" . copy-elfeed-show-url)
                 ("ok" . elfeed-show-to-kindle))
      ))
#+END_SRC

*** elfeed-org

using org-mode to manage feed url

#+BEGIN_SRC emacs-lisp
  (req-package elfeed-org
    :config (progn
              (setq rmh-elfeed-org-files (list "~/.elfeed.org"))
              (elfeed-org)
              ))
#+END_SRC

*** TODO [#C] smooth scrolling
** hangups
ref: https://github.com/jtamagnan/hangups.el

#+BEGIN_SRC emacs-lisp
  (req-package hangups
    :loader :path
    :require adaptive-wrap
    :bind ("C-c h" . hangups)
    :config
    (progn
      ;; (unbind-key "g" hangups-conv-mode-map)
      (bind-keys :map hangups-conv-mode-map
                 ;; ("gg" . beginning-of-buffer)
                 ;; ("G" . end-of-buffer)
                 ("j" . next-line)
                 ("k" . previous-line)
                 ("l" . forward-char)
                 ("h" . backward-char)
                 ("d" . scroll-up-command)
                 ("e" . scroll-down-command)
                 ("g" . hangups-conv-refresh)
                 ("o" . browse-at-point)
                 )))
#+END_SRC

** TODO erc
* Python
*** elpy
ref: https://github.com/jorgenschaefer/elpy

#+BEGIN_SRC emacs-lisp
  (req-package elpy
    :require (flycheck company yasnippet)
    :defer 2
    :config
    (progn
      (elpy-enable)
      (setq elpy-rpc-backend "jedi")

      (eval-after-load 'flycheck
        '(progn
           (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
           (add-hook 'elpy-mode-hook 'flycheck-mode)))

      (add-to-list 'elpy-modules 'elpy-module-company)
      (add-to-list 'elpy-modules 'elpy-module-yasnippet)
      ))
#+END_SRC

*** anaconda

這個就可以了，不必再設定 company-jedi。
會自動呼叫 jedi

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package anaconda-mode
    :require (jedi auto-complete popup)
    :diminish anaconda-mode
    :init (progn
            (add-hook 'python-mode-hook 'anaconda-mode)
            (add-hook 'python-mode-hook 'eldoc-mode)))

    (req-package company-anaconda
      :init (add-to-list 'company-backends 'company-anaconda))

#+END_SRC

*** jedi

Linux 中安裝 jedi

#+BEGIN_SRC sh
   $ pip install jedi
#+END_SRC

Emacs 中，如果更新了 jedi，要再執行 =M-x jedi:install-server=

如果有關於 =~/.emacs.d/.python-environments/default= 的錯誤訊息，刪了
它，重新執行 =M-x jedi:install-server=

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package jedi
  :require (python-environment)
    :init
    (progn
      (add-hook 'python-mode-hook 'jedi:setup)
      ;; (add-hook 'python-mode-hook 'eldoc-mode)

      (setq jedi:complete-on-dot nil)
      (setq jedi:tooltip-method nil)
      ))
#+END_SRC

*** company-jedi

#+BEGIN_SRC emacs-lisp :tangle no
  (req-package company-jedi
    :init (add-to-list 'company-backends 'company-jedi))
#+END_SRC
* Org                                                                   :Org:
*** basic setup
 #+BEGIN_SRC emacs-lisp
   (req-package org
     :loader :built-in
     :mode (("\\.org\\'" . org-mode)
            ("\\.org_archive\\'" . org-mode))
     :config
     (progn
       (add-hook 'org-mode-hook
                 '(lambda ()
                    (setq mode-name " ꙮ ")))
       (setq org-src-fontify-natively t
             org-src-window-setup 'current-window
             org-confirm-babel-evaluate nil
             org-startup-indented t)
       ))
 #+END_SRC

*** Pretty Bullets
ref: https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp
  (req-package org-bullets
    :config
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

*** Extend org-mode's easy templates

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (add-to-list 'org-structure-template-alist
                    '("T" "#+TITLE:?\n#+AUTHOR:\n#+DATE:"))
       (add-to-list 'org-structure-template-alist
                    '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
       (add-to-list 'org-structure-template-alist
                    '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))))
#+END_SRC

*** Extend babel support languages

#+BEGIN_SRC emacs-lisp
(eval-after-load 'org
  '(progn
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (C . t)
        (ditaa . t)
        (dot . t)
        (js . t)
        (latex . t)
        (perl . t)
        (python . t)
        (ruby . t)
        (sh . t)
        (clojure . t)
        ))))
#+END_SRC

*** Capture and Agenda
#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (setq org-agenda-window-setup 'current-window)
       (add-hook 'org-agenda-mode-hook 'hl-line-mode)

       (setq org-directory "~/org")
       (setq org-default-notes-file (expand-file-name "notes.org" org-directory))

       (setq org-capture-templates
             '(("t" "Todo" entry (file+headline "~/org/notes.org" "Tasks")
                "* TODO %?\n%T")
               ("n" "Note" entry (file+headline "~/org/notes.org" "Notes")
                "* TODO %?\n%T")
               ))

       (setq org-agenda-files (list emacs-init-org-file org-default-notes-file))

       (add-hook 'org-agenda-mode-hook
                 '(lambda ()
                    (local-set-key (kbd "C-g") 'org-agenda-exit)))
       ))
#+END_SRC

*** keybinds
=C-c '= 編輯原始碼
=C-Return= 增加一個標題
=C-c C-c= 增加或修改 tags
=C-<left>/<right>= 對標題設定 TODO keywords
=C-<up>/<down>= 對標題設定重要性
=<TAB>= 循環展開一個標題 (含子標題)
=S-<TAB= 循環展開全檔的標題
=C-c C-o= open url link
=C-c \= 展開本檔相對應 tag 的標題，可用 & | 串接，做邏輯性查詢

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c c" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (unbind-key "C-c [")
  (unbind-key "C-c ]")
#+END_SRC

* Other Modes
** SQL

在 SQL 視窗中，自動轉行，能看到所有資料

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (toggle-truncate-lines nil)))
#+END_SRC

** Shell
** systemd-mode

會自動以 company 補全，不必再設定。

#+BEGIN_SRC emacs-lisp
  (req-package systemd)
#+END_SRC

*** keybindings

(define-key map (kbd "C-c C-d") 'systemd-doc-directives)
(define-key map (kbd "C-c C-o") 'systemd-doc-open)

** markdown-mode

#+BEGIN_SRC emacs-lisp
(req-package markdown-mode
  :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.markdown\\'" . gfm-mode))
      (add-to-list 'auto-mode-alist '("\\.md\\'" . gfm-mode))))
#+END_SRC

** ReStructure

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rst\\'" . rst-mode))
#+END_SRC

** Haskell

只是為了 xmonad 和 taffybar。

#+BEGIN_SRC emacs-lisp
  (req-package haskell-mode
    :require (flycheck flycheck-haskell)
    :mode "\\.hs$" "\\.l?hs$"
    :config
    (progn (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
           (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
           (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)

           (defun my-haskell-hook ()
             (setq mode-name " λ ")

             (turn-on-haskell-doc)
             (diminish 'haskell-doc-mode "")
             (capitalized-words-mode)

             (diminish 'capitalized-words-mode "")
             (turn-on-eldoc-mode)

             (diminish 'eldoc-mode "")
             (turn-on-haskell-decl-scan)
             (setq evil-auto-indent nil))

           ;;(setq haskell-font-lock-symbols 'unicode)
           ;;(setq haskell-literate-default 'tex)
           ;;(setq haskell-stylish-on-save t)
           ;;(setq haskell-tags-on-save t)
           (add-hook 'haskell-mode-hook 'my-haskell-hook)))
#+END_SRC

*** flycheck-haskell

#+BEGIN_SRC emacs-lisp
  (req-package flycheck-haskell
    :config (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
#+END_SRC

** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (req-package lisp-mode
    :init
    (add-hook 'emacs-lisp-mode-hook
              (lambda ()
                (setq mode-name " ξ "))))
#+END_SRC

** Web
*** TODO web-mode

目前是為了 mako 使用的 web-mode，看起來還有一些問題需要微調，不知如何下手。

Homepage: http://web-mode.org/
Source: https://github.com/fxbois/web-mode

#+BEGIN_SRC emacs-lisp
(req-package web-mode
  :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode))
      (setq web-mode-engines-alist  '(("mako" . "\\.tmpl\\'")))
      (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))))

(defun my-web-mode-hook ()
  "Hooks for Web mode."
  (setq web-mode-markup-indent-offset 4)
  (setq web-mode-code-indent-offset 4)
  (setq web-mode-css-indent-offset 2)
)
(add-hook 'web-mode-hook  'my-web-mode-hook)

#+END_SRC

*** emmet-mode

類似 zencoding 的工具
用類似 css 的語法寫 html 檔

Homepage: http://emmet.io/
Source: https://github.com/smihica/emmet-mode

#+BEGIN_SRC emacs-lisp
(req-package emmet-mode
  :init
    (progn
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook  'emmet-mode)
      (add-hook 'emmet-mode-hook
                (lambda () (setq emmet-indentation 4)))))
#+END_SRC

*** TODO js2-mode

Source: https://github.com/mooz/js2-mode

#+BEGIN_SRC emacs-lisp
(req-package js2-mode
  :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
      (add-hook 'js2-mode-hook 'flycheck-mode)))
#+END_SRC

*** json-mode

Source: https://github.com/joshwnj/json-mode

#+BEGIN_SRC emacs-lisp
(req-package json-mode
  :init (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode)))
#+END_SRC
** nginx-mode

#+BEGIN_SRC emacs-lisp
  (req-package nginx-mode)
#+END_SRC

* End of configuration
** req-package finish

At long last we need only call the following function to send =req-package= on
its merry way.

#+BEGIN_SRC emacs-lisp
  (req-package-finish)
#+END_SRC

** Startup emacs as server
#+BEGIN_SRC emacs-lisp
  (unless (string-equal "root" (getenv "USER"))
    (require 'server)
    (unless (server-running-p) (server-start)))
#+END_SRC

* The Final note

使用 emacs 會上癮，尤其是 lisp 這種語言，真的迷人，只是要花很多時間熟
悉這套工具。熟悉了這個工具，真的就不想用其它的編輯器，也不能用其它的編
輯器了。

因為，已經習慣自己一手打造出來，獨一無二，順手的工具。

* Reference

[1] https://github.com/coldnew/coldnew-emacs

[2] https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bdistribution/spacemacs/packages.el

[3] https://github.com/tjarvstrand/config-files/blob/master/.emacs

[4] https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-spell.el
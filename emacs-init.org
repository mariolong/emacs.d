#+TITLE: Emacs Configuration
#+AUTHOR: Mario Long
#+EMAIL: mariolong5782@gmail.com
#+STARTUP: overview showstars
#+BABEL: :cache yes
#+OPTIONS: ^:nil

* Preface

Thanks, coldnew. https://github.com/coldnew/coldnew-emacs
工作流程很多都是學自coldnew，啟蒙者。

2016-1-5
用了一陣子的 spacemacs，雖然覺得不錯，但是 0.105 版出來後，許多設定又不能用了。
算了，還是追隨 coldnew 的腳步，回到自己的 org 檔吧。

2016-6-3
我又回來了。
實在是用不到 spacemacs 那麼多的功能，而且覺得 spacemacs 愈來愈慢，不夠快意。

2016-11-29
花了點時間好好地整理一下這個檔

2016-12-14
Switch to =use-package=, it is faster than =req-package= very much.

* Initialization
** Use lexical binding

For some of my functions, and general coolness, =lexical binding= is a must.
Without it, closures cannot be made for example.

This line needs to appear at the beginning of the file to work. Just to keep
things looking nice I put it at the beginning of the file.

#+BEGIN_SRC emacs-lisp :padline no
  ;; -*- lexical-binding: t -*-
#+END_SRC

** load prefer newer

since emacs 24.4, new option `load-prefer-newer' has been
introduce, which make me never accidentally using outdated compiled files.

#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

** Cleanup
*** no menu bar, no tool bar, no scroll bar

Press <F10> to show menu

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

*** fullscreen

#+begin_src emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+end_src

*** inhibit startup message

#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+end_src

*** clean message of redefinition

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

*** clean scratch message

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message ";; This is scratch buffer.\n\n")
#+END_SRC

** Font settings

眼睛不好了，把字體放大些，最重要的是設定中文字型和表情符號。
123456789012345678901234567890123456789012345678901234567890

error: Fontset `tty' does not exist
solution: http://www.cnblogs.com/aqing1987/p/4464106.html

#+begin_src emacs-lisp
  (defun set-font-for-chinese ()
    (set-face-attribute 'default nil
			:family "Source Code Pro" :height 180)
    (set-face-attribute 'variable-pitch nil
			:family "Sans" :height 200 :weight 'regular)

    (dolist (charset '(kana han cjk-misc bopomofo))
      (set-fontset-font (frame-parameter nil 'font) charset
			(font-spec :family "Source Han Sans" :size 28)))

    (set-fontset-font (frame-parameter nil 'font) 'symbol (font-spec :family "Symbola" :size 32)))

  (add-to-list 'after-make-frame-functions (lambda (new-frame)
					     (select-frame new-frame)
					     (if window-system
						 (set-font-for-chinese))))

  (when window-system
    (set-font-for-chinese))
#+end_src

** Define user's directory variables

#+BEGIN_SRC emacs-lisp
  (setq user-emacs-directory (file-name-directory (or load-file-name (buffer-file-name))))
  (defconst user-emacs-init-org (expand-file-name "emacs-init.org" user-emacs-directory))
  ;; (defconst user-emacs-init-el (expand-file-name "emacs-init.el" user-emacs-directory))
  (defconst emacs-init-el (expand-file-name "init.el" user-emacs-directory))

  (defconst user-cache-directory
    (file-name-as-directory (expand-file-name ".cache" user-emacs-directory))
    "My emacs storage area for persistent files.")
#+END_SRC

** Create temporary file directory if it is not exist

#+BEGIN_SRC emacs-lisp
  (set-default 'temporary-file-directory (expand-file-name "tmp" user-emacs-directory))
  (unless (file-exists-p temporary-file-directory)
    (make-directory temporary-file-directory))
#+END_SRC

** Add .emacs.d/lisp to load path

NOTE: Don't use like xxx.el as directory name.

#+BEGIN_SRC emacs-lisp
(let* ((lisp-dir '("lisp/" "themes/")))
  (dolist (lisp-path lisp-dir)
    (when (not (file-exists-p lisp-path))
      (make-directory (concat user-emacs-directory lisp-path) t))
    (let* ((load-dir (concat user-emacs-directory lisp-path))
	   (default-directory load-dir))
      (setq load-path
	    (append
	     (let ((load-path (copy-sequence load-path)))
	       (append
		(copy-sequence (normal-top-level-add-to-load-path '(".")))
		(normal-top-level-add-subdirs-to-load-path)))
	     load-path)))))
#+END_SRC

** Tangle init.org when it saved

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled."
    (interactive)

    (require 'async)
    (let ((buffer-name "async-make-init.el"))
      (when (equal (buffer-file-name) user-emacs-init-org)
    (message "Begin re-generate init.el")
	(async-start-process buffer-name "sh"
			     '(lambda (result)
				(message "Re-Generate init.el finish." result))
			     (expand-file-name "makeinit.sh" user-emacs-directory)))))

(add-hook 'after-save-hook 'tangle-init)
#+END_SRC

** Tangle this initial file before exit emacs
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
  (defconst emacs-init-org-file (expand-file-name "emacs-init.org" user-emacs-directory))
  (defconst emacs-init-el-file (expand-file-name "emacs-init.el" user-emacs-directory))

  (defun tangle-emacs-init-org ()
    "Tangle emacs-init.org to .el"

    (interactive)

    (let* ((age (lambda (file)
                  (float-time
                   (time-subtract (current-time)
                                  (nth 5 (or (file-attributes (file-truename file))
                                             (file-attributes file))))))))
      (if (file-exists-p emacs-init-org-file)
          (unless (and (file-exists-p emacs-init-el-file)
                       (> (funcall age emacs-init-org-file)
                          (funcall age emacs-init-el-file)))
            (progn
              (setq org-confirm-babel-evaluate nil)
              (setq org-confirm-execute-src-block nil)
              (org-babel-tangle-file emacs-init-org-file emacs-init-el-file "emacs-lisp")
              (byte-compile-file emacs-init-el-file))
            ))))

  (add-hook 'kill-emacs-hook 'tangle-emacs-init-org)
#+END_SRC

* Package Management
** Initialize =package=
用 =package.el= 要先加來源庫，為了org，以下工作改到 init.el 中執行。

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

  (package-initialize)
#+END_SRC

** Install =use-package=

Switch to use-package form req-package because there are no reason to use req-package already for me.
start emacs faster than req-package very very much.

#+BEGIN_SRC emacs-lisp
  (if (not (package-installed-p 'use-package))
      (progn
	(package-refresh-contents)
	(package-install 'use-package)))

  (require 'use-package)
  (setq use-package-always-defer t)
  (setq use-package-always-ensure t)
#+END_SRC

** Paradox
use Paradox replace with package-list and my =upgrade-all-install-packages=
good look and good functions

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :init
    (setq paradox-execute-asynchronously t))
#+END_SRC

** Upgrade all installed packages

用 =M-x upgrade-all-installed-packages= 更新所有已安裝的套件

*useless*
#+BEGIN_SRC emacs-lisp :tangle no
  (defun upgrade-all-installed-packages ()
    "Upgrade all installed packages."

    (interactive)
    (save-window-excursion
      (package-list-packages)
      (package-menu-mark-upgrades)
      (package-menu-execute t)))
#+END_SRC

** uninstall packages

用 =M-x package-list-packages= 找到不需要的套件，並刪除之。

** reload emacs' "init.el"

#+BEGIN_SRC emacs-lisp
  (defun reload-emacs ()
    "reload my emacs settings"

    (interactive)
    (load-file (expand-file-name "init.el" user-emacs-directory))
    (delete-other-windows))
#+END_SRC

** Evaluate buffer until error occured

#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
    "Evaluate emacs buffer until error occured."

    (interactive)
    (goto-char (point-min))
    (while t (eval (read (current-buffer)))))
#+END_SRC

* Theme
** Theme

#+BEGIN_SRC emacs-lisp  :tangle no
  (use-package dracula-theme
    :init
    (load-theme 'dracula t))
#+END_SRC

#+begin_src emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :init
      (load-theme 'sanityinc-tomorrow-night :no-confirm))
#+end_src

** spaceline
from spacemacs import spaceline for nice look and HUD.

ref: https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bdistribution/spacemacs/packages.el

#+BEGIN_SRC emacs-lisp
  (use-package spaceline-config
    :ensure spaceline
    :commands spaceline-spacemacs-theme
    :init
    (progn
      (setq-default powerline-default-separator 'wave)
      (setq spaceline-minor-modes-separator "")
      (spaceline-spacemacs-theme)
      ))
#+END_SRC
(if (display-graphic-p) 'wave 'utf-8)
** Change cursor color according to mode

#+BEGIN_SRC emacs-lisp
  (defvar hcz-set-cursor-color-color "")
  (defvar hcz-set-cursor-color-buffer "")
  (defun hcz-set-cursor-color-according-to-mode ()
    "change cursor color according to some minor modes."
    ;; set-cursor-color is somewhat costly, so we only call it when needed:
    (let ((color
           (if buffer-read-only "white"
             (if overwrite-mode "#5599aa"
               "#f99157"))))
      (unless (and
               (string= color hcz-set-cursor-color-color)
               (string= (buffer-name) hcz-set-cursor-color-buffer))
        (set-cursor-color (setq hcz-set-cursor-color-color color))
        (setq hcz-set-cursor-color-buffer (buffer-name)))))

  (add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+END_SRC

** fringe
改得細一點，預設值是 8 pixel

#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)
#+END_SRC

** rainbow-mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :diminish rainbow-mode
    :init
    (progn
      (add-hook 'prog-mode-hook 'rainbow-mode)
      (add-hook 'css-mode-hook 'rainbow-mode)))
#+END_SRC

** rainbow-delimiters
ref: https://github.com/Fanael/rainbow-delimiters

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :init
    (progn
      (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
      (add-hook 'org-mode-hook 'rainbow-delimiters-mode)))
#+END_SRC

** highlight-parentheses
set color of parenttheses like spacemacs.

#+BEGIN_SRC emacs-lisp
  (use-package  highlight-parentheses
    :diminish ""
    :init
    (progn
      (add-hook 'prog-mode-hook #'highlight-parentheses-mode)

      (setq hl-paren-delay 0.2)
      (setq hl-paren-colors '("Springgreen3"
                              "IndianRed1"
                              "IndianRed3"
                              "IndianRed4"))
      (global-highlight-parentheses-mode t)
      (set-face-attribute 'hl-paren-face nil :weight 'ultra-bold)
      ))
#+END_SRC

** beacon
#+BEGIN_SRC emacs-lisp

(use-package beacon
:init
(beacon-mode 1))
#+END_SRC

* Chinese setup
** pangu-spacing

自動在中英文字間加入空白，以利閱讀

#+BEGIN_SRC emacs-lisp
  (use-package pangu-spacing
    :diminish ""
    :config
    (progn
      (global-pangu-spacing-mode 1)

      (dolist (mode '(eww-mode elfeed-search-mode elfeed-show-mode))
	(add-to-list 'pangu-spacing-inhibit-mode-alist mode))

      ;; Always insert `real' space in org-mode.
      (dolist (mode '(markdown-mode-hook rst-mode-hook))
	(add-hook mode '(lambda()
                       (set (make-local-variable 'pangu-spacing-real-insert-separtor) t))))
      ))
#+END_SRC

** fcitx

進入 normal mode 時，自動切換至英文輸入模式

#+BEGIN_SRC emacs-lisp
  (use-package fcitx
    :init (fcitx-aggressive-setup))
#+END_SRC

** Translate buffer via opencc

#+BEGIN_SRC emacs-lisp
  (defun opencc-buffer ()
    "Convert chinese from simplified to variants and phrases of Taiwan"

    (interactive)

    (set-buffer-file-coding-system 'utf-8-unix)

    (let ((opencc-conv-temp-file (expand-file-name "opencc.tmp" temporary-file-directory)))
      (let ((str (buffer-substring-no-properties (point-max) 1)))
	(with-temp-file opencc-conv-temp-file
	  (insert str "\n")))

      (let ((current-point (point))
	    (result
	     (shell-command-to-string (concat "opencc -i " opencc-conv-temp-file))))

	(erase-buffer)
	(insert result)
	(goto-char current-point))))

  (bind-key "C-c fo" 'opencc-buffer)

#+END_SRC

* Basic settings
** use noflet no defer
#+BEGIN_SRC emacs-lisp
  (use-package noflet
    :defer 0)
#+END_SRC

** Don't ask me when close emacs with process is running
#+BEGIN_SRC emacs-lisp
  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (noflet ((process-list ())) ad-do-it))
#+END_SRC

** Don't ask me when kill process buffer
#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

** Set prefer coding to utf-8
#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq system-time-locale "en_US" )
#+END_SRC

** Turn on syntax highlighting for all buffers:
#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC
** ethan-wspace

Takes care of trailing whitespaces (removal, highlighting)
https://github.com/glasserc/ethan-wspace

#+BEGIN_SRC emacs-lisp
  (use-package ethan-wspace
    :diminish "🄣"
    :config
    (progn
      ;; Turn off `mode-require-final-newline' since ethan-wspace
      ;; supersedes `require-final-newline'.
      (setq mode-require-final-newline nil)

      ;; Enable ethan-wspace globally
      (global-ethan-wspace-mode 1)

      ;; Prevent etha-wspace touch my TAB on makefile mode
      (add-hook 'makefile-mode-hook
                '(lambda()
                   (setq ethan-wspace-errors (remove 'tabs ethan-wspace-errors))))

      ;; Ignore no trailing newline error
      (setq-default ethan-wspace-errors (remove 'no-nl-eof ethan-wspace-errors))))
#+END_SRC

** Delete trailing whitespace before save buffer
#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

** Default truncate lines
#+BEGIN_SRC emacs-lisp
  (toggle-truncate-lines t)
#+END_SRC

** Bell off
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

** Shorten answer
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Clipboard
#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
        select-enable-primary t)
#+END_SRC

** Show keystrokes in progress
#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

** Remove text in active region if inserting text
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Save minibuffer history
When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.

#+BEGIN_SRC emacs-lisp
  (savehist-mode 1)
  (setq history-length 1000)
#+END_SRC

** Subword mode

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
#+END_SRC

** Parentheses
#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis)
#+END_SRC

** Line Numbers
In most case, I'll make line numers display globally by =linum=.

#+BEGIN_SRC emacs-lisp
  (use-package linum
    :init
    (add-hook 'prog-mode-hook
              '(lambda () (linum-mode 1))))

  (setq column-number-mode t)
#+END_SRC

** Relative Line Numbers

#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :init
    (progn
      (linum-relative-mode)
      (setq linum-relative-current-symbol "")
      (setq linum-relative-format "%4s")))
#+END_SRC

** Highlight numbers on program mode

ref: [[https://github.com/Fanael/highlight-numbers]]
:ensure parent-mode
#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :init
    ;; json-mode has it's own highlight numbers method
    (add-hook 'prog-mode-hook '(lambda()
                                 (if (not (derived-mode-p 'json-mode))
                                     (highlight-numbers-mode)))))
#+END_SRC

** Highlight FIXME, TODO in program mode

#+begin_src emacs-lisp
  (defun font-lock-comment-annotations ()
    "Highlight a bunch of well known comment annotations.
  This functions should be added to the hooks of major modes for programming."

    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))

  (add-hook 'prog-mode-hook 'font-lock-comment-annotations)
#+end_src

** Hind mouse point
#+BEGIN_SRC emacs-lisp
  (mouse-avoidance-mode 'banish)
#+END_SRC

* Window Management                                                  :window:
** golden ratio

https://github.com/roman/golden-ratio.el

#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :diminish ""
    :init
      (golden-ratio-mode 1))
#+END_SRC

** winner-mode

Undo/redo window configuration with C-c <left>/<right>

#+BEGIN_SRC emacs-lisp
(use-package winner)
#+END_SRC

** TODO ace-window with golden-ratio

https://github.com/abo-abo/ace-wimndow

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :init
    (progn
      (global-set-key [remap other-window] 'ace-window)
      (custom-set-faces
       '(aw-leading-char-face
	 ((t (:inherit ace-jump-face-foreground :height 3.0)))))
      ))
#+END_SRC

** keybinding of delete frame

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x w" 'delete-frame)
#+END_SRC

** popwin

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    :init
    (progn
      (setq helm-popwin
            '(("*Flycheck errors*" :height 10)
              ("*Helm Find Files*" :height 0.3)
              ("^\*helm.+\*$" :regexp t :height 15))))
    :config
    (progn
      (popwin-mode 1)
      (push '("*helm semantic/imenu*" :width 0.382 :position left) popwin:special-display-config)
      (push '(" *undo-tree*" :width 0.3 :position right) popwin:special-display-config)
      ))
#+END_SRC

* Buffer Management                                                  :buffer:
** Create *scratch* automatically
Sometimes I'll kill the =*scratch*= buffer to make it clean, just use
following function to let emacs re-create it automatically.

#+BEGIN_SRC emacs-lisp
  (defun create-scratch-buffer ()
    "create scratch buffer if it is not exist."

    (unless (get-buffer "*scratch*")
      (with-current-buffer
	  (get-buffer-create "*scratch*")
	(insert initial-scratch-message)
	(lisp-interaction-mode))))

  (defun switch-to-scratch-buffer ()
    "switch buffer to scratch if not exist then create new one"
    (interactive)
    (create-scratch-buffer)
    (switch-to-buffer "*scratch*"))

    ;; (run-with-idle-timer 1 t 'create-scratch-buffer)
#+END_SRC

** rebind kill-emacs to "C-x C-c C-c"

#+BEGIN_SRC emacs-lisp
  (unbind-key "C-x C-c")
  (bind-key "C-x C-c C-c" 'kill-emacs)
#+END_SRC

** kill all buffer except current buffer

http://stackoverflow.com/questions/3417438/closing-all-other-buffers-in-emacs

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-c c" 'kill-other-buffers)
  (defun kill-other-buffers ()
    (interactive)
    (mapc 'kill-buffer (cdr (buffer-list (current-buffer))))
    (delete-other-windows))
#+END_SRC

** kill all buffer except *scratch*

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-c s" 'kill-all-buffer-but-scratch)
  (defun kill-all-buffer-but-scratch ()
    (interactive)
    (switch-to-scratch-buffer)
    (kill-other-buffers)
    (delete-other-windows))
#+END_SRC

** Save files and exit (current file)
=C-x C-c= save-buffers-kill-emacs
rebind =C-x C-c= to (kill-other-buffers) as below

#+begin_src emacs-lisp
  (bind-key "C-x k" 'kill-this-buffer)
#+END_SRC

** Show current buffer-file information

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fn" 'my/file-info)

  (defun my/file-info ()
    "Show current buffer information."
    (interactive)
    (if (buffer-file-name (current-buffer))
        (progn
          (let* ((file-name (buffer-file-name (current-buffer)))
                 (f-attr (file-attributes file-name))
                 (f-size (nth 7 f-attr))  ; ファイルサイズ
                 (f-mode (nth 8 f-attr))  ; ファイル属性
                 (mes1 (format "file path: %s\n" file-name))
                 (mes2 (format "file size: %s byte\n" f-size))
                 (mes3 (format "file type: %s" f-mode))
                 (mess (concat mes1 mes2 mes3)))
            (message "%s" mess)))
      nil))
#+END_SRC

** Set buffer to utf-8-unix

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fu" 'buffer-to-utf-8-unix)

  (defun buffer-to-utf-8-unix()
    (interactive)
    (set-buffer-file-coding-system 'utf-8-unix))
#+END_SRC

** cycle revert buffer decoding

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fa" 'my/cycle-revert-buffer-decoding)

  (defun my/cycle-revert-buffer-decoding ()
    (interactive)

    (let* ((decoders [utf-8 gb18030 big5])
	   (index-before
	    (if (get 'my/cycle-revert-buffer-decoding 'state)
		(get 'my/cycle-revert-buffer-decoding 'state)
	      0))
	   (index-after (% (+ index-before 1) (length decoders)))
	   (next-decoder (aref decoders index-after)))
      (message "%s %s" decoders next-decoder)
      (put 'my/cycle-revert-buffer-decoding 'state index-after)
      (revert-buffer-with-coding-system next-decoder)))
#+END_SRC

** revert-buffer

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fv" 'revert-buffer)

  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*")) ;; disable revert query
#+END_SRC

** ibuffer
#+BEGIN_SRC emacs-lisp
  (bind-key "C-x C-b" 'ibuffer)
  (autoload 'ibuffer "ibuffer" "List buffers." t)
  (add-hook 'ibuffer-hook '(lambda ()
			     (revert-buffer)))
#+END_SRC

** Switch to previous buffer
#+BEGIN_SRC emacs-lisp
  (bind-key "M-o" 'mode-line-other-buffer)
#+END_SRC
** persistent-scratch

A persistent scratch buffer form Pragmatic Emacs
http://pragmaticemacs.com/emacs/a-persistent-scratch-buffer/

#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))
#+END_SRC

** recentf

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :config
  (progn
    (setq recentf-save-file (expand-file-name "recentf" user-cache-directory))
    (recentf-mode 1)
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 10)))
#+end_src

** save-place
自動記錄每一個檔案，游標所在的位置。
下次再開啟這個檔案時，游標會自動回到上次的地方。

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (progn
      (setq save-place-file (expand-file-name "places" user-cache-directory))
      (save-place-mode 1)))
#+end_src

** uniquift
Add parts of each file's directory to the buffer name if not unique

#+BEGIN_SRC emacs-lisp
(use-package uniquify
:ensure nil
:init
(setq uniquify-buffer-name-style 'post-forward-angle-brackets)
)
#+END_SRC
* Minibuffer                                                         :minibuffer:

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package minibuffer
  :ensure nil
  :config
  <<minibuffer-config>>)
#+END_SRC

** Make cursor in minibufer use bar shape

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))
#+END_SRC

** Some helper function to let me insert quick in minibuffer

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config

  (defun my/minibuffer-insert (p)
    (kill-line 0) (insert p))

  (defun my/minibuffer-switch-to-ramdisk ()
    "Insert ramdisk path according to system type"
    (interactive)
    (my/minibuffer-insert user-ramdisk-directory))

  (defun my/minibuffer-switch-to-home ()
    "Insert $HOME path."
    (interactive)
    (my/minibuffer-insert (file-name-as-directory (getenv "HOME"))))

  (defun my/minibuffer-switch-to-rootdir ()
    "Insert / path."
    (interactive)
    (my/minibuffer-insert "/"))

  (defun my/minibuffer-switch-to-tramp ()
    "Insert /ssh:."
    (interactive)
    (my/minibuffer-insert "/ssh:"))

  (defun my/minibuffer-switch-to-vm ()
    "Insert /ssh:vm:."
    (interactive)
    (my/minibuffer-insert "/ssh:vm:"))

  (defun my/minibuffer-switch-to-cluster ()
    "Insert /ssh:cluster:."
    (interactive)
    (my/minibuffer-insert "/ssh:cluster:"))
#+END_SRC

** Save history of minibuffer :tangle no :noweb-ref minibuffer-config

When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.  When Savehist mode is enabled
for the first time in an Emacs session, it loads the previous
minibuffer history from ‘savehist-file’.

#+BEGIN_SRC emacs-lisp  :tangle no :noweb-ref minibuffer-config
  (use-package savehist
    :config
    (setq savehist-file (expand-file-name "savehist.dat" user-cache-directory))
    (savehist-mode 1))
#+END_SRC

** Increase Garbage Collector Value in minibuffer

By binding this temporarily to a large number, you can effectively prevent garbage collection during a part of the program. I increase the value when enter minibuffer, this will help to improve minibuffer speed with large package like helm, flx.

ref: http://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
:noweb-ref minibuffer-config
  (eval-after-load 'minibuffer
    '(progn
       (lexical-let ((default-threshold gc-cons-threshold))
         (defun my/minibuffer-gc-setup-hook ()
           (setq gc-cons-threshold most-positive-fixnum))
         (add-hook 'minibuffer-setup-hook #'my/minibuffer-gc-setup-hook)
         ;; When exit, set back to default threshold
         (defun my/minibuffer-gc-exit-hook ()
           (setq gc-cons-threshold default-threshold))
         (add-hook 'minibuffer-exit-hook #'my/minibuffer-gc-exit-hook))))
#+END_SRC

** Setup Keybindings                                            :keybinding:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (bind-keys :map minibuffer-local-map
             ("C-w" . backward-kill-word)
             ("M-p" . previous-history-element)
             ("M-n" . next-history-element)
             ("C-g" . minibuffer-keyboard-quit)
             ("M-t" . my/minibuffer-switch-to-ramdisk)
             ("M-h" . my/minibuffer-switch-to-home)
             ("M-/" . my/minibuffer-switch-to-rootdir)
             ("M-s" . my/minibuffer-switch-to-tramp)
             ("M-v" . my/minibuffer-switch-to-vm)
             ("M-c" . my/minibuffer-switch-to-cluster))
#+END_SRC
* File management
** Dired: the most powerfull file management tool

https://github.com/lunaryorn/.emacs.d/blob/master/init.el

http://kuanyui.github.io/2014/06/21/dired-tutorial-and-essential-configs/

http://pragmaticemacs.com/category/dired/

We recently looked at replacing text in buffers.
Using dired, it is possible to do this in many files in a directory.
Start dired and mark files as described here.
Then use Q to run query-replace on all marked files.

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
		("s" . my/counsel-dired-sort)
		("f" . dired-find-name-in-current-directory)
		("C-x M-o" . dired-omit-and-remember))
    :config
    <<dired-config>>)
#+END_SRC

*** Dired tries to guess a default target directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-dwim-target t)
#+END_SRC

*** Revert on re-visiting
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-auto-revert-buffer t)
#+END_SRC

*** -F marks links with @
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-ls-F-marks-symlinks t)
#+END_SRC

*** set dired listing switches

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  ;; dired-listing-switches "-alh"
  (setq dired-listing-switches "--group-directories-first -alh")
  ;; dired-listing-switches "-lFaGh1v --group-directories-first"
#+END_SRC

*** Don't ask me question when recursively copy/delete file(s)

always: 表示永不詢問。
top: 表示同一批檔案只詢問一次。

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-recursive-copies  'always
	dired-recursive-deletes 'top)
#+END_SRC

*** sorting current directoy

會先問你要根據什麼屬性排序，而且紀錄下排序狀態，不會跨 buffer 就不見了。

#+BEGIN_SRC emacs-lisp
  (defconst sorting-action '(("name" "")
			     ("size" "S")
			     ("extension" "X")
			     ("access time" "ut")
			     ("modified time" "t")
			     ("status change time" "ct")))

  ;; (defun sort-dir (sort-item)
  ;; (dired-sort-other
  ;; (concat dired-listing-switches
  ;; (car (cdr (assoc sort-item sorting-action))))))

  (defun my/counsel-dired-sort ()
    (interactive)

    (let ((sort-cmd (mapcar 'car sorting-action))
	  (sort-dir (lambda (sort-item)
		      (dired-sort-other
		       (concat dired-listing-switches
			       (car (cdr (assoc sort-item sorting-action))))))))

      (ivy-read "sort by" sort-cmd
		:preselect "name"
		:initial-input "^"
		:action #'sort-dir)))
#+END_SRC

*** dired omit mode enhancement

;; Dired Omit 加強:
;; 簡單來說，這個能夠紀錄下目前的「隱藏狀態」，所以當你按
;; C-x M-o 隱藏以.為開頭的檔案後，即使到了不同目錄下，以.開頭的檔案
;; 依舊是處於隱藏狀態，直到你重新按 C-x M-o 為止。

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
(setq dired-omit-files "^\\...+$")

(defvar v-dired-omit t
  "If dired-omit-mode enabled by default. Don't setq me.")

(defun dired-omit-and-remember ()
  "This function is a small enhancement for `dired-omit-mode', which will
        \"remember\" omit state across Dired buffers."

  (interactive)
  (setq v-dired-omit (not v-dired-omit))
  (dired-omit-auto-apply)
  (revert-buffer))

(defun dired-omit-auto-apply ()
  (setq dired-omit-mode v-dired-omit))

(add-hook 'dired-mode-hook 'dired-omit-auto-apply)
#+END_SRC

*** recursively find files under current directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
(defun dired-find-name-in-current-directory ()
  (interactive)
  (find-name-dired default-directory
                   (format "*%s*" (read-from-minibuffer "Pattern: ")))
  (set-buffer-multibyte t))
(setq find-name-arg "-iname")
(setq find-ls-option '("-print0 | xargs -0 ls -ald" . ""))
#+END_SRC

*** 按 q 回到上層目錄，並自動把 cursor 移動到前一個目錄處

the behave is like press '^'
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
  (defun my-dired-backward ()
    "Go back to the parent directory (..), and the cursor will be moved to where
            the previous directory."
    (interactive)
    (let* ((DIR (buffer-name)))
      (if (equal DIR "*Find*")
          (quit-window t)
	(progn (find-alternate-file "..")
               (re-search-forward DIR nil :no-error)
               (revert-buffer)))))
  (define-key dired-mode-map (kbd "q") 'my-dired-backward)
#+END_SRC

*useless*
#+BEGIN_SRC emacs-lisp :tangle no
;; 按 Enter 時 Dired 時不會一直開新的 Dired buffer（按 Enter 時只用同一個 Dired 開目錄）
(defun dired-my-find-alternate-file ()
  (interactive)
  (if (file-regular-p (dired-get-filename))
      (dired-find-file)
    (dired-find-alternate-file)))
(define-key dired-mode-map (kbd "RET") 'dired-my-find-alternate-file) ; 按 Enter 開檔案
(put 'dired-find-alternate-file 'disabled nil) ; 避免 Dired 問你一些囉唆的問題

#+END_SRC


*** 和 KDE 的 Dolphin 一樣的檔案名過濾器，按 C-i 使用。 (by letoh)
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
(defun dired-show-only (regexp)
  (interactive "sFiles to show (regexp): ")
  (dired-mark-files-regexp regexp)
  (dired-toggle-marks)
  (dired-do-kill-lines))
(define-key dired-mode-map (kbd "C-i") 'dired-show-only)
#+END_SRC

*** M-Enter 呼叫外部程式（此處是透過 `kde-open`）來開啟檔案

如果你不是用 KDE，可以改成 xdg-open 之類的。Windows 我不知該怎麼辦啦啦啦。
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
(defun dired-open-file-with-external-program ()
  "Open file with external program in dired"
  (interactive)
  (let* ((file (dired-get-filename nil t)))
    (message "Opening %s..." file)
    (call-process "kde-open" nil 0 nil file)
    (message "Opening %s done" file)))
(define-key dired-mode-map (kbd "M-RET") 'dired-open-file-with-external-program)
#+END_SRC

*** 在 Dired 下 C-x C-j 使用`kde-open`等外部程式開啟「當前目錄」
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
(defun open-current-directory-with-external-program ()
  "Open current directory with external program."
  (interactive)
  (call-process "kde-open" nil 0 nil (file-truename default-directory)))
(define-key dired-mode-map (kbd "C-x C-j") 'open-current-directory-with-external-program)
#+END_SRC

*** 按 M-a 把檔案加入 SMPlayer 的播放清單中。
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
(defun dired-add-to-smplayer-playlist ()
  "Add a multimedia file or all multimedia files under a directory into SMPlayer's playlist via Dired."
  (interactive)
  (require 'cl)
  (let* ((PATTERN "\\(\\.mp4\\|\\.flv\\|\\.rmvb\\|\\.mkv\\|\\.avi\\|\\.rm\\|\\.mp3\\|\\.wav\\|\\.wma\\|\\.m4a\\|\\.mpeg\\|\\.aac\\|\\.ogg\\|\\.flac\\|\\.ape\\|\\.mp2\\|\\.wmv\\|.m3u\\|.webm\\)$")
         (FILE (dired-get-filename nil t)))
    (if (file-directory-p FILE) ;if it's a dir.
        (let* ((FILE_LIST (directory-files FILE t PATTERN))
               (n 0)
               s_FILE_LIST)
          (dolist (x FILE_LIST)
            (if (not (or (equal x ".") (equal x "..")))
                (setq s_FILE_LIST (concat s_FILE_LIST "'" x "' ")))
            (setq n (1+ n)))
          (message "Opening %s files..." n)
          (call-process-shell-command "smplayer -add-to-playlist" nil nil nil (format "%s &" s_FILE_LIST)))
      (if (string-match PATTERN FILE)   ;if it's a file
          (call-process "smplayer" nil 0 nil "-add-to-playlist" FILE)
        (message "This is not a supported audio or video file."))))
  (dired-next-line 1))
(define-key dired-mode-map (kbd "M-a") 'dired-add-to-smplayer-playlist)
#+END_SRC
** dired+

#+BEGIN_SRC emacs-lisp
  (use-package dired+
    :init (progn
            (diredp-toggle-find-file-reuse-dir 1)
))
 #+END_SRC

** dired-async
https://github.com/jwiegley/emacs-async

#+BEGIN_SRC emacs-lisp
  (use-package async
    :init
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1))
#+END_SRC

** narrow dired to match filter

http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC

** openwith

https://github.com/emacsmirror/openwith

#+BEGIN_SRC emacs-lisp
  (use-package openwith
    :init
    (progn
      (openwith-mode t)
      (setq openwith-associations
            (list (list (openwith-make-extension-regexp '("jpg" "jpeg" "png"))
                        "feh -FY" '(file))
                  (list (openwith-make-extension-regexp '("flac" "mp3" "wav" "aiff" "m4a" "aac"))
                        "mpv" '(file))
                  (list (openwith-make-extension-regexp '("avi" "flv" "mov" "mp4" "rmvb" "m2ts" "webm"
                                                          "mpeg" "mpg" "ogg" "wmv" "mkv"))
                        "mpv" '(file))
                  ))))
#+END_SRC

** peep-dired
#+BEGIN_SRC emacs-lisp
(use-package peep-dired
  :bind (:map dired-mode-map
              ("P" . peep-dired)))
#+END_SRC

** Making directories on the fly

ref: http://mbork.pl/2016-07-25_Making_directories_on_the_fly

Today, a friend asked me how to create a directory – or a hierarchy
of them – while finding a file in a nonexistent directory. I found
some clues on the ‘net, but the best one used the old advice
mechanism. So I decided to do it myself, based on the hints found. It
turned out to be simpler than I thought; it’s made even easier by the
fact that Elisp’s make-directory function acts basically like mkdir
-p when given non-nil second (optional) argument.

#+BEGIN_SRC emacs-lisp
  (defun make-parent-directory ()
    "Make sure the directory of `buffer-file-name' exists."
    (make-directory (file-name-directory buffer-file-name) t))

  (add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC

** Edit current buffer as root

#+BEGIN_SRC emacs-lisp
  (defun edit-current-file-as-root ()
    "Edit the file that is associated with the current buffer as root"
    (interactive)
    (if (buffer-file-name)
        (progn
          (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
          (find-file file))
      (message "Current buffer does not have an associated file.")))
  (bind-key "C-c fR" 'edit-current-file-as-root)
#+END_SRC

** Delete current buffer file

#+BEGIN_SRC emacs-lisp
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
  (bind-key "C-c fD" 'delete-current-buffer-file)
#+END_SRC

** Rename current Buffer and file

#+BEGIN_SRC emacs-lisp
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
  (bind-key "C-c fr"  'rename-current-buffer-file)
#+END_SRC

** Clone current Buffer and file

#+BEGIN_SRC emacs-lisp
  (defun clone-file-and-open (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
  (bind-key "C-c fc"  'clone-file-and-open)
#+END_SRC

** Add executable attribute to file

Actually this command is the same as =chmod +x= but it doesn't use any shell
command, it use emacs's logior function to change file attribute.

I only make =owener= can has executable permission, not change it for gourp or
others user.

#+BEGIN_SRC emacs-lisp
  (defun set-file-executable()
    "Add executable permissions on current file."

    (interactive)
    (when (buffer-file-name)
      (set-file-modes buffer-file-name
                      (logior (file-modes buffer-file-name) #o100))
      (message (concat "Made " buffer-file-name " executable"))))
  (bind-key "C-c fx" 'set-file-executable)
#+END_SRC

** no backup file
#+begin_src emacs-lisp
  (setq make-backup-files nil) ; stop creating those backup~ files
  (setq auto-save-default nil) ; stop creating those #autosave# files
#+end_src
** Using pandoc to convert org, markdown file
*** get major mode of current buffer

#+BEGIN_SRC emacs-lisp
  (defun current-buffer-mode ()
    "Return the major-mode associated with current buffer."

    (with-current-buffer (buffer-name)
      major-mode))
#+END_SRC

*** convert org-mode to pdf via pandoc
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c op" 'org-to-pdf)

  (defun org-to-pdf ()
    "Conver org to pdf and open the pdf file."

    (interactive)
    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (let* ((pdf-name (concat (file-name-sans-extension buffer-file-name) ".pdf")))

            (message "convert to %s" (file-name-nondirectory pdf-name))

            (let* ((latex-engin "xelatex")
                   (template "/home/mario/.pandoc/default.latex")
                   (result (shell-command
                            (format "pandoc %s --latex-engine %s --template %s -s -o %s"
                                    buffer-file-name
                                    latex-engin
                                    template
                                    pdf-name
                                    ))))
              (if (eq result 0)
                  (find-file pdf-name)
                (message result)))
            ))
      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

*** convert markdown to orgmode via pandoc

#+BEGIN_SRC emacs-lisp
  (defun md-to-org ()
    "Convert markdown to org for edit. Especially for evernote/geeknote."

    (interactive)
    (if (eq (current-buffer-mode) 'markdown-mode)
        (let* ((default-directory "/mnt/lvm-data/Documents/")
               (md-buffer-name (buffer-name))
               (md-file-name (buffer-file-name))
               (md-org-buffer (find-file (read-file-name "" default-directory)))
               (md-org-file-name (buffer-file-name)))

          (if (not (file-exists-p md-org-file-name))
              (progn
                (shell-command (format "pandoc -f markdown -t org -o %s %s"
                                       md-org-file-name
                                       md-file-name))
                (revert-buffer nil t)
                (goto-char (point-min))
                (insert "#+TITLE:\n")
                (save-buffer)
                (kill-buffer md-buffer-name))
            (message "%s is already exist." md-org-file-name)))
      (message "Current buffer must be 'markdown-mode'!")))
#+END_SRC

*** save buffer as org-mode and bind key as "C-c oo"

 bind key "C-c oo" to write current page of eww as orgmode
 or markdown to org.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c oo" 'write-buffer-as-orgmode)

  (defun write-buffer-as-orgmode ()
  (interactive)
    (cond
     ((eq (current-buffer-mode) 'markdown-mode) (md-to-org))
     ((eq (current-buffer-mode) 'eww-mode) (eww-to-org))
     (t (message "Current mode must be markdown or eww"))))
#+END_SRC
** Send file to kindle by wpub
*** utility for async send file by wpub

#+BEGIN_SRC emacs-lisp
  (defun async-wpub (url &optional file-type opencc)
    (let* ((cmd-opencc (if opencc (if (y-or-n-p "Convert to Traditional Chinese?") "-o" "") ""))
	   (cmd-type (if file-type (format "-f %s" file-type) ""))
	   (cmd-wpub (if url (format "wpub %s %s '%s'" cmd-opencc cmd-type url) nil)))

      (if cmd-wpub
	  (progn
	    (message "%s" cmd-wpub)
	    (start-file-process-shell-command "async-wpub"
					      "*async-wpub*"
					      cmd-wpub)))))
#+END_SRC

*** send org-mode file to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun org-to-kindle ()
    "Send current buffer to kindle via wpub.py"

    (interactive)

    (if (eq (current-buffer-mode) 'org-mode)
	(progn
	  (let ((wpub-temp-file (expand-file-name (buffer-name) temporary-file-directory))
		(str (buffer-substring-no-properties (point-max) 1)))

	    (with-temp-file wpub-temp-file
	      (insert str "\n"))

	    (async-wpub wpub-temp-file "org")))

      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

*** send html file to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun html-file-to-kindle (fname)
    (async-wpub fname "html" t))

#+END_SRC

*** send url to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun url-to-kindle (url)
    (async-wpub url nil t))
#+END_SRC

*** eww url to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle ()
    "send the content of current url to kindle via wpub"

    (interactive)
    (url-to-kindle (eww-current-url))
    )
#+END_SRC

*** eww send current page kindle

#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle-directly ()
    (interactive)

    (let ((fname (eww-temp-file-name-html (eww-current-url))))
      (eww-make-temp-file-source fname)
      (html-file-to-kindle fname)))
#+END_SRC

**** write eww source to temp file

#+BEGIN_SRC emacs-lisp
  (defun eww-temp-file-name-html (fname)
    (expand-file-name (concat (md5 fname) ".html")
		      temporary-file-directory))

  (defun eww-make-temp-file-source (temp-file-name)
    (let ((source (eww-current-source)))
      (with-temp-file temp-file-name
	(insert (string-as-multibyte source)))))
#+END_SRC

*** elfeed send page to kindle

#+BEGIN_SRC emacs-lisp

  (defun elfeed-search-to-kindle ()
    "send current content to kindle"

    (interactive)
    (url-to-kindle (get-elfeed-search-url)))

  (defun elfeed-show-to-kindle ()
    "send current content to kindle"

    (interactive)
    (url-to-kindle (get-elfeed-show-url)))

#+END_SRC

*** send url or org to kindle

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c ok" 'send-url-or-org-to-kindle)

  (defun send-url-or-org-to-kindle ()
    "Send content of current buffer to kindle"

    (interactive)
    (cond
     ((not (eq (eww-current-url) nil)) (eww-to-kindle-directly))
     ((eq (current-buffer-mode) 'org-mode) (org-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-search-mode) (elfeed-search-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-show-mode) (elfeed-show-to-kindle))
     (t (message "%s" "Can't send this page to kindle."))))
#+END_SRC
** Open recent directory with dired by ivy

#+BEGIN_SRC emacs-lisp
  (defun counsel-goto-recent-directory ()
    "Open recent directory with dired"

    (interactive)
    (unless recentf-mode (recentf-mode 1))
    (let ((collection
           (delete-dups
            (append (mapcar 'file-name-directory recentf-list)
                    ;; fasd history
                    (if (executable-find "fasd")
                        (split-string (shell-command-to-string "fasd -ld") "\n" t))))))
      (ivy-read "directories:" collection :action 'dired)))

  (bind-key "C-x C-\\" 'counsel-goto-recent-directory)
#+END_SRC

** Open recent directory with dired in other window

Use fasd to open directory in another window and switch cursor to new
window.

if there are two panel already, then don't open the other window.
Just switch to another window and open target directory.

#+BEGIN_SRC emacs-lisp
  (defun counsel-goto-recent-directory-other-window ()
    (interactive)

    (let ((old-buffer-name (buffer-name))
	  (new-directory-name (counsel-goto-recent-directory)))
      (message "open recent dir old:%s new:%s" old-buffer-name new-directory-name)
      (if (eq (count-windows) 1)
	  (split-window-right))

      (switch-to-buffer old-buffer-name)
      (other-window 1)
      (golden-ratio)
      (find-file new-directory-name)))
#+END_SRC

** Quick open some special files
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
  (bind-key "C-c ffs" 'ff-scratch)
  (bind-key "C-c ffe" 'ff-elisp-source)
  (bind-key "C-c ffi" 'ff-init-org)

  (defun ff-init-org ()
    (interactive)
    (find-file (expand-file-name "emacs-init.org" user-emacs-directory)))

  (defun ff-elisp-source ()
    (interactive)
    (let ((src-buffer-name "*Org Src emacs-init.org[ emacs-lisp ]*"))
      (if (get-buffer src-buffer-name)
	  (progn
	    (switch-to-buffer src-buffer-name)
	    (message ""))
	(message "%s" "No Org Src buffer"))))

  (defun ff-scratch ()
    (interactive)
    (switch-to-scratch-buffer))
#+END_SRC

** find-file usually files

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c ff" 'find-file-usually-files)

  (defun find-file-usually-files ()
    (interactive)
    (let ((usually-files (list user-emacs-init-org
			       emacs-init-el
			       "*scratch*"
			       "*Org Src emacs-init.org[ emacs-lisp ]*"
			       "*Messages*"
			       )))

      (ivy-read "find file:" usually-files
		:action #'find-file-or-buffer)))

  (defun find-file-or-buffer (file-or-buffer-name)
    (if (get-buffer file-or-buffer-name)
	(switch-to-buffer file-or-buffer-name)
      (if (file-exists-p file-or-buffer-name)
	  (find-file file-or-buffer-name)
	(message "Not found %s" file-or-buffer-name))
      ))
#+END_SRC

* Multi-term
這個比 eshell 好用。原因很簡單…習慣！

參考：
1. http://blog.jobbole.com/51598/
2. https://www.emacswiki.org/emacs/MultiTerm
3. http://rawsyntax.com/blog/learn-emacs-zsh-and-multi-term/
4. http://paralambda.org/2012/07/02/using-gnu-emacs-as-a-terminal-emulator/
5. http://emacs-fu.blogspot.tw/2010/06/console-apps-in-emacs-with-multi-term.html

將 shell 設為 zsh，呼叫 shell 的快捷鍵設為 <C-x  t>。

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package multi-term
    :demand popwin
    :bind (("C-x t" . multi-term-next)
	   ("C-x T" . multi-term)
	   ("C-!" . popwin-term:multi-term))
    :init
    (setq multi-term-program "/bin/zsh")
    :config
    <<term-config>>)
  #+END_SRC

** term-mode-hook
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref term-config
  (add-hook 'term-mode-hook
	    (lambda ()
	      (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
	      (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next))
	      (setq term-buffer-maximum-size 10000)
	      (define-key term-raw-map (kbd "C-y") 'term-paste)
	      ))
#+END_SRC

** popup multi-term
C-! 以 popup window 的方式在下方開一個 term 視窗

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref term-config
  (defun popwin-term:multi-term ()
    (interactive)

    (popwin:display-buffer-1
     (or (get-buffer "*terminal*")
	 (save-window-excursion
           (call-interactively 'multi-term)))
     :default-config-keywords '(:position :bottom :height 12 :stick t)))
#+END_SRC
* Editing                                                            :edit:
** Delete whole line or multi-lines

ref: http://endlessparentheses.com/kill-entire-line-with-prefix-argument.html

C-1 C-k 刪去整行
C-3 C-k 刪去 3 行

#+BEGIN_SRC emacs-lisp
  (defmacro bol-with-prefix (function)
    "Define a new function which calls FUNCTION.
  Except it moves to beginning of line before calling FUNCTION when
  called with a prefix argument. The FUNCTION still receives the
  prefix argument."
    (let ((name (intern (format "endless/%s-BOL" function))))
      `(progn
         (defun ,name (p)
           ,(format
             "Call `%s', but move to BOL when called with a prefix argument."
             function)
           (interactive "P")
           (when p
             (forward-line 0))
           (call-interactively ',function))
         ',name)))

  (global-set-key [remap paredit-kill] (bol-with-prefix paredit-kill))
  (global-set-key [remap org-kill-line] (bol-with-prefix org-kill-line))
  (global-set-key [remap kill-line] (bol-with-prefix kill-line))
#+END_SRC

** hungry-delete

#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :diminish ""
    :init
    (global-hungry-delete-mode 1))
#+END_SRC

** move-text

用 M-up, M-down 移動當行或 region

ref: http://emacs.stackexchange.com/questions/4238/moving-line-with-move-text-up-doesnt-move-point

#+BEGIN_SRC emacs-lisp
  ;move line up down
  (defun move-text-internal (arg)
    (cond
     ((and mark-active transient-mark-mode)
      (let ((column (current-column))
            (pos (< (point) (mark)))
            (text (delete-and-extract-region (point) (mark))))
        (forward-line arg)
        (move-to-column column t)
        (set-mark (point))
        (insert text)
        (and pos (exchange-point-and-mark))
        (setq deactivate-mark nil)))
     (t
      (let ((column (current-column)))
        (beginning-of-line)
        (when (or (> arg 0) (not (bobp)))
          (forward-line)
          (when (or (< arg 0) (not (eobp)))
            (transpose-lines arg)
            ;; Account for changes to transpose-lines in Emacs 24.3
            (when (and (eval-when-compile
                         (not (version-list-<
                               (version-to-list emacs-version)
                               '(24 3 50 0))))
                       (< arg 0))
              (forward-line -1)))
          (forward-line -1))
        (move-to-column column t)))))

  (defun move-text-down (arg)
    "Move region (transient-mark-mode active) or current line
    arg lines down."
    (interactive "*p")
    (move-text-internal arg))

  (defun move-text-up (arg)
    "Move region (transient-mark-mode active) or current line
    arg lines up."
    (interactive "*p")
    (move-text-internal (- arg)))

  (bind-key "M-<up>" 'move-text-up)
  (bind-key "M-<down>" 'move-text-down)
#+END_SRC

** undo-tree
用 M-x undo-tree-visualize (C-x u) 看 undo-tree，很直覺。

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-history-directory-alist
	    `(("." . ,(file-name-as-directory (expand-file-name "undo-tree" user-cache-directory)))))
      (setq undo-tree-auto-save-history t)))
#+END_SRC

** expand-region

M-SPC 設定 mark
C-= 擴展
C-- C-= 縮減
C-0 C-= 還原

ref: https://github.com/magnars/expand-region.el

#+BEGIN_SRC emacs-lisp
  (bind-key "M-SPC" 'set-mark-command)
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

** comment/uncomment line

Source: http://endlessparentheses.com/implementing-comment-line.html?source=rss

#+BEGIN_SRC emacs-lisp
  (defun endless/comment-line (n)
    "Comment or uncomment current line and leave point after it.

  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above."

    (interactive "p")
    (comment-or-uncomment-region
     (line-beginning-position)
     (goto-char (line-end-position n)))
    (forward-line 1)
    (back-to-indentation))

  (bind-key "M-;" #'endless/comment-line)
#+END_SRC

** smartparens
ref: https://github.com/Fuco1/smartparens
ref: https://ebzzry.github.io/emacs-pairs.html

#+BEGIN_SRC emacs-lisp
  (use-package smartparens-config
    :ensure smartparens
    :init
    (progn
      (smartparens-global-mode t)
      (show-smartparens-global-mode t))
    :config
    (progn
      (diminish 'smartparens-mode "ⓟ")
      ))
#+END_SRC

** aggressive-indent

ref: http://endlessparentheses.com/permanent-auto-indentation.html

非文字模式下，自動縮排。

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :diminish " Ⓘ"
    :init
    (global-aggressive-indent-mode))
#+END_SRC

** multi-cursor

ref: http://emacsrocks.com/e13.html

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ))
#+END_SRC

** iedit

[[https://github.com/victorhge/iedit][iedit]] let you edit multiple regions in the same way simultaneously.

Normal scenario of Iedit mode is like:

- Highlight certain contents - by press C-; (The default key binding)
  All occurrences of a symbol, string or a rectangle in the buffer or
  a region may be highlighted corresponding to current mark, point and
  prefix argument.  Refer to the document of `iedit-mode’ for
  details.

- Edit one of the occurrences The change is applied to other
  occurrences simultaneously.

- Finish - by pressing C-; again

co-work with 'narrow or widen dwim' as below.

#+BEGIN_SRC emacs-lisp
  (use-package iedit)
#+END_SRC

** narrow or widen dwim

Emacs narrow-or-widen-dwim · Endless Parentheses
http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
		 ((ignore-errors (org-narrow-to-block) t))
		 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; (define-key endless/toggle-map "n"
  ;; #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing
  ;; keymap, that's how much I like this command. Only
  ;; copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
		nil)))
#+END_SRC

** ivy
看起來比 helm 好看些，輕量且快速。

useful keybindings:

- M-i ivy-insert-current
- M-j ivy-yank-word (word)
- M-n ivy-next-history-element (symbol)
- rebind M-. from find-tag to ivy-next-history-element on ivy-minibuffer-map

進入 ivy-git-grep C-M-n/p 上下移動選單中的光標，檔案內容會跳到相對應的位置。

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ""
    :bind
    (("C-c C-r" . ivy-resume)
     :map ivy-minibuffer-map
     ("M-." . ivy-next-history-element))
    :config
    (progn
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (setq completion-in-region-function 'ivy-completion-in-region)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind
    ("C-s" . swiper))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure ag
    :bind
    (("M-y" . counsel-yank-pop)
     ("M-x" . counsel-M-x)
     ("C-x f" . counsel-recentf)
     ("C-x l" . counsel-locate)
     ("C-c k" . counsel-ag)
     ("C-c j" . counsel-git-grep)
     ("C-:" . counsel-company)
     ("C-x C-\\" . counsel-goto-recent-directory)
     ("C-x \\" . counsel-goto-recent-directory-other-window)
     :map ivy-minibuffer-map
     ("M-y" . ivy-next-line)))
#+END_SRC

** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish (flycheck-mode . " ⓢ")
    :config
    (progn
      (add-hook 'after-init-hook 'global-flycheck-mode)
      (setq flycheck-indication-mode 'right-fringe)
      (define-key flycheck-mode-map flycheck-keymap-prefix nil)
      (setq flycheck-keymap-prefix (kbd "C-c v"))
      (define-key flycheck-mode-map flycheck-keymap-prefix flycheck-command-map)))
#+END_SRC

** TODO Spell checking
*** Ispell

if want to use "hunspell", then must install hunspell and hunspell_en in OS.

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :config                               ;
    (progn
      (cond
       ((executable-find "aspell")
	(setq ispell-program-name "aspell")
	(setq ispell-extra-args   '("--sug-mode=ultra"
                                    "--lang=en_US"
                                    "--ignore=2"
                                    "--run-together"
                                    "--run-together-limit=5"
                                    "--run-together-min=2")))
       ;; how to fire 'hunspell'?
       ((executable-find "hunspell")
	(setq ispell-program-name "hunspell")
	(setq ispell-extra-args   '("-d en_US"))
	(setq ispell-local-dictionary-alist
              '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
		("zh_TW" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))))

      (setq ispell-local-dictionary "en_US")
      (setq ispell-silently-savep t)))
#+END_SRC

*** flyspell

=C-.= corrects word at point.
=C-,​= to jump to next misspelled word.
=M-$= correct word at point

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flyspell
    :demand ispell
    :diminish " Ⓢ"
    :init
    (progn
      (add-hook 'prog-mode-hook #'turn-on-flyspell)
      (add-hook 'text-mode-hook #'turn-on-flyspell)

      (dolist (hook '(elfeed-search-mode-hook change-log-mode-hook log-edit-mode-hook))
	(add-hook hook (lambda () (flyspell-mode -1)))))

    :config (unbind-key "C-;" flyspell-mode-map))
#+END_SRC

*** flyspell-correct-ivy

#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct-ivy
    :demand (flyspell ivy flyspell-correct)
    :bind (:map flyspell-mode-map
                ("M-$" . flyspell-correct-word-generic))
    :init
    (progn
      (setq flyspell-correct-interface 'flyspell-correct-ivy)
      ;; (bind-keys :map flyspell-mode-map
      ;; ("M-$" . flyspell-correct-word-generic))
      ;; bind flyspell-correct-word-generic
      ;; (define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-word-generic)
      ;; (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-previous-word-generic)
      ))
#+END_SRC

*** Make spell-checking tool ignore some org-mode section

see: http://emacs.stackexchange.com/questions/450/intelligent-spell-checking-in-org-mode

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ispell
    '(progn
       (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
       (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
       ))
#+END_SRC
** Company mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish " ⓐ"
    :init (add-hook 'after-init-hook 'global-company-mode)
    :config
    (progn
      (global-company-mode t)

      (setq company-idle-delay 0.1)
      (setq company-tooltip-limit 10)
      (setq company-minimum-prefix-length 2)
      (setq company-echo-delay 0)

      (add-to-list 'company-backends 'company-ispell t)))
#+END_SRC

*** Add quickhelp in company-mode
ref: https://github.com/expez/company-quickhelp

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :demand company
    :init (company-quickhelp-mode 1))
#+END_SRC

*** keybindings

When the completion candidates are shown,
<f1> to display the documentation for the selected candidate,
C-w  to see its source. Not all back-ends support this.

M-n/p select up/down
<return> to complete
<Tab> complete the common part
C-s
C-r
C-o
<f1> to dispaly the documentation
<C-w> to see its source
** discover-my-major

[[https://github.com/steckerhalter/discover-my-major][discover-my-major]] make you discover key bindings and their meaning for the
current Emacs major mode.

GitHub: https://github.com/steckerhalter/discover-my-major

#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-m" . discover-my-mode)))
#+END_SRC
** Which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish ""
    :init
    (progn
      (setq which-key-idle-delay 0.5)
      (which-key-mode)
      (which-key-setup-side-window-bottom)
      (setq which-key-side-window-max-width 0.25)))
#+END_SRC
** Unbind keys

#+BEGIN_SRC emacs-lisp
  (unbind-key "C-\\")
  (unbind-key "C-z")
  (unbind-key "C-x C-z")
  (unbind-key "C-x m")
#+END_SRC

** TODO cycle replace hyphen, underscore, space, dot

#+BEGIN_SRC emacs-lisp :tangle no
(defun xah-cycle-hyphen-underscore-space ( &optional *begin *end )
  "Cycle {underscore, space, hypen} chars in selection or inside quote/bracket or line.
When called repeatedly, this command cycles the {“_”, “-”, “ ”} characters, in that order.

The region to work on is by this order:t
① if there's active region (text selection), use that.
② If cursor is string quote or any type of bracket, and is within current line, work on that region.
③ else, work on current line.

URL `http://ergoemacs.org/emacs/elisp_change_space-hyphen_underscore.html'
Version 2016-11-11"
  (interactive)
  ;; this function sets a property 「'state」. Possible values are 0 to length of -charArray.
  (let (-p1 -p2)
    (if (and (not (null *begin)) (not (null *end)))
        (progn (setq -p1 *begin -p2 *end))
      (if (use-region-p)
          (setq -p1 (region-beginning) -p2 (region-end))
        (if (nth 3 (syntax-ppss))
            (save-excursion
              (skip-chars-backward "^\"")
              (setq -p1 (point))
              (skip-chars-forward "^\"")
              (setq -p2 (point)))
          (let (
                (-skipChars
                 (if (boundp 'xah-brackets)
                     (concat "^\"" xah-brackets)
                   "^\"<>(){}[]“”‘’‹›«»「」『』【】〖〗《》〈〉〔〕（）")))
            (skip-chars-backward -skipChars (line-beginning-position))
            (setq -p1 (point))
            (skip-chars-forward -skipChars (line-end-position))
            (setq -p2 (point))
            (set-mark -p1)))))
    (let* ((-inputText (buffer-substring-no-properties -p1 -p2))
           (-charArray ["_" "-" "." " "])
           (-length (length -charArray))
           (-regionWasActive-p (region-active-p))
           (-nowState
            (if (equal last-command this-command )
                (get 'xah-cycle-hyphen-underscore-space 'state)
              0 ))
           (-changeTo (elt -charArray -nowState)))
      (save-excursion
        (save-restriction
          (narrow-to-region -p1 -p2)
          (goto-char (point-min))
          (while
              (search-forward-regexp
               (elt -charArray (% (+ -nowState 2) -length))
               ;; (concat
               ;;  (elt -charArray (% (+ -nowState 1) -length))
               ;;  "\\|"
               ;;  (elt -charArray (% (+ -nowState 2) -length)))
               (point-max)
               'NOERROR)
            (replace-match -changeTo 'FIXEDCASE 'LITERAL))))
      (when (or (string= -changeTo " ") -regionWasActive-p)
        (goto-char -p2)
        (set-mark -p1)
        (setq deactivate-mark nil))
      (put 'xah-cycle-hyphen-underscore-space 'state (% (+ -nowState 1) -length)))))
#+END_SRC
* Cursor move
** avy
ref: https://github.com/abo-abo/avy

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-g z" . avy-goto-char)
           ("M-g f" . avy-goto-line)))
#+END_SRC

** ace-pinyin
ref: https://github.com/cute-jumper/ace-pinyin

#+BEGIN_SRC emacs-lisp
  (use-package ace-pinyin
    :demand avy
    :diminish ""
    :config
    (progn
      (ace-pinyin-global-mode +1)
      (setq ace-pinyin-simplified-chinese-only-p nil)))
#+END_SRC

** Smart home
按 home 鍵，可讓遊標回到行首或第一個非空字元

ref: https://github.com/tjarvstrand/config-files/blob/master/.emacs.d/lib/smart-beginning-of-line.el

#+BEGIN_SRC emacs-lisp
  (defun smart-beginning-of-line ()
    "Move point to first non-whitespace character or beginning-of-line.

  Move point to the first non-whitespace character on this line.
  If point was already at that position, move point to beginning of line."

    (interactive)
    (let ((oldpos (point)))
      (back-to-indentation)
      (and (= oldpos (point))
           (beginning-of-line))))

  (bind-key [home] 'smart-beginning-of-line)
  (bind-key* "C-a" 'smart-beginning-of-line)
#+END_SRC

** link-hint

ref: https://github.com/noctuid/link-hint.el

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :bind ("C-c ol" . link-hint-open-link)
    :init
    (dolist (map (list help-mode-map Info-mode-map))
        (bind-key "f" 'link-hint-open-link map)))
#+END_SRC
** TODO jump between matched parens

* Project relative function                                         :project:
** Magit (setup)

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")
      (setq magit-auto-revert-mode nil)
      (setq magit-save-some-buffers nil)
      (setq magit-set-upstream-on-push t)
      (setq magit-diff-refine-hunk t)
      (setq magit-completing-read-function 'ivy-completing-read)
      (setq magit-default-tracking-name-function 'magit-default-tracking-name-branch-only))
    :bind ("C-c g" . magit-status))
#+END_SRC

** magit-filenotify

#+BEGIN_SRC emacs-lisp
    (use-package magit-filenotify
      :init (add-hook 'magit-status-mode-hook 'magit-filenotify-mode))
#+END_SRC

** meld (hind shell command buffer after run)
Using =M-x call-meld= to find the differences from last commit.

#+BEGIN_SRC emacs-lisp
  (defun call-meld ()
    (interactive)
    (shell-command (format "meld %s" (buffer-file-name)))
    (winner-undo)
    )
  (bind-key "C-c fd" 'call-meld)
#+END_SRC

** diff-hl

keybinds to navigate the position of differences
可以顯示出尚未 stage 的程式碼

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :init
    (progn (global-diff-hl-mode +1)
	   (diff-hl-dired-mode 1)))
#+END_SRC

** ediff

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-vertically)
  (setq ediff-merge-split-window-function 'split-window-vertically)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

** projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish ""
    :init
    (progn (projectile-global-mode)
           (setq projectile-completion-system 'ivy)))
#+END_SRC
* Internet relative functions                                      :internet:
** eww (Emacs Web broWser)

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package eww
    :defer 0
    :bind (("C-c b" . browse-at-point))
    :config
    <<eww-config>>)
#+END_SRC

*** Using google chrome as generic browser
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (setq browse-url-browser-function 'eww-browse-url)

  (setq browse-url-generic-program (executable-find "google-chrome-stable")
        shr-external-browser 'browse-url-generic)
#+END_SRC

*** using google search
ref: http://emacs.stackexchange.com/questions/2955/how-to-customize-background-color-for-some-web-pages-opened-with-eww

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (setq eww-search-prefix "https://www.google.com/search?q=")
  (setq shr-color-visible-luminance-min 70)
#+END_SRC

*** truncate lines
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (add-hook 'eww-mode-hook '(lambda ()
                              (toggle-truncate-lines nil)))
#+END_SRC

*** keybindings

F: (eww-toggle-fonts) can be used to toggle whether to use variable-pitch fonts or not.
R: (eww-readable) will try do identify the main textual parts of a web page and display only that,
    leaving menus and the like off the page.
S: will list all eww buffers, and allow managing them.

C-c ok: send current page to kindle
C-c oo: write current page as org-mode file

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (bind-keys :map eww-mode-map
	     ("f" . link-hint-open-link)
	     ("j" . next-line)
	     ("k" . previous-line)
	     ("l" . forward-char)
	     ("h" . backward-char)
	     ("d" . scroll-up-command)
	     ("e" . scroll-down-command)
	     ("B" . eww-browse-with-external-browser)
	     ("m" . endless/toggle-image-display)
	     ("q" . eww-quit-reset-image-flag)
	     ("H" . eww-back-url)
	     ("L" . eww-forward-url)
	     ("ok" . eww-to-kindle-directly)
	     ("oo" . eww-to-org)
	     ("yy" . eww-copy-page-url)
	     ("yt" . eww-copy-current-title)
	     ("yo" . eww-copy-title-url-org)
	     ("yu" . eww-copy-title-url))
#+END_SRC

*** toggle image display

#+BEGIN_SRC emacs-lisp

  (defun eww-quit-reset-image-flag ()
    "reset image-flag"

    (interactive)
    (setq endless/display-images t)
    ;; (quit-window)
    (kill-buffer "*eww*"))

  (defvar-local endless/display-images t)

  (defun endless/toggle-image-display ()
    "Toggle images display on current buffer."
    (interactive)
    (setq endless/display-images (null endless/display-images))
    (endless/backup-display-property endless/display-images))

  (defun endless/backup-display-property (invert &optional object)
    "Move the 'display property at POS to 'display-backup.
  Only applies if display property is an image.
  If INVERT is non-nil, move from 'display-backup to 'display
  instead.
  Optional OBJECT specifies the string or buffer. Nil means current
  buffer."
    (let* ((inhibit-read-only t)
           (from (if invert 'display-backup 'display))
           (to (if invert 'display 'display-backup))
           (pos (point-min))
           left prop)
      (while (and pos (/= pos (point-max)))
	(if (get-text-property pos from object)
            (setq left pos)
          (setq left (next-single-property-change pos from object)))
          (if (or (null left) (= left (point-max)))
            (setq pos nil)
          (setq prop (get-text-property left from object))
          (setq pos (or (next-single-property-change left from object)
			(point-max)))
          (when (eq (car prop) 'image)
            (add-text-properties left pos (list from nil to prop) object))))))

#+END_SRC
*** eww browse at point

#+BEGIN_SRC emacs-lisp
  (defun my/thing-at-point-to-eww ()
    (if mark-active
	(s-trim (buffer-substring-no-properties (region-beginning) (region-end)))
      (unless (setq-local ret (thing-at-point 'url))
	(unless (setq-local ret (thing-at-point 'symbol))
	  (setq-local ret "")))
      ret))

  (defun browse-at-point (arg)
    "browse at point: selected region or url or single word
  if cursor at whitespace then call eww wait for input some thing."

    (interactive "P")

    (if (consp arg)
	(call-interactively 'eww)
      (let ((thing (my/thing-at-point-to-eww)))
	(if (string= "" thing)
	    (call-interactively 'eww)
	  (eww thing)))))
#+END_SRC

*** Yahoo! dictionary
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
  (defun dictionary-at-point ()
    "find the definition from Yahoo Dictionary."

    (interactive)
    (let ((dictionary-url "https://tw.dictionary.yahoo.com/dictionary?p=")
          (word (read-from-minibuffer "Input word:" (word-at-point))))
      (if word
          (eww (concat dictionary-url word)))))

  (bind-key "C-c y" 'dictionary-at-point)
#+END_SRC

*** org-eww-mode

using org-eww to save current web page to org-mode in eww-mode

#+BEGIN_SRC emacs-lisp
  (use-package org-eww
    :ensure nil
    :config
    (defun eww-to-org ()
      "Save eww current page to an org file"
      (interactive)
      (require 'org-eww)

      (let* ((eww-org-default-directory "/mnt/lvm-data/Documents/eww/")
             (org-file-name (expand-file-name (concat
                                               (replace-regexp-in-string "\[ :　/\]" "-" (eww-current-title))
                                               ".org")
                                              eww-org-default-directory)))
	(org-eww-copy-for-org-mode)
	(switch-to-buffer (get-buffer-create org-file-name))
	(yank)
	(goto-char (point-min))
	(insert "#+TITLE:\n#+AUTHOR:\n#+DATE:\n\n")
	(write-file org-file-name)
	)))
#+END_SRC

*** TODO 簡繁互換 in eww buffer

#+BEGIN_SRC emacs-lisp

#+END_SRC

*** eww to org
save current web page to org-mode
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
  (defun eww-to-org ()
    "save current page to org file from eww"

    (interactive)
    (if (eq (current-buffer-mode) 'eww-mode)
        (let* ((back-current-url (eww-current-url))
               (default-directory "/mnt/lvm-data/Documents/eww/")
               (org-file-name-o (expand-file-name (concat (eww-current-title) ".org") default-directory))
               (org-file-name (replace-regexp-in-string " " "-" org-file-name-o)))

          (write-file org-file-name)
          (goto-char (point-min))
          (insert "#+TITLE:\n#+AUTHOR:\n#+DATE:\n\n")
          (show-all)
          (write-file org-file-name)

          (eww back-current-url)
          (message "write file: %s" eww-to-org-file-name)
          )))
#+END_SRC

*** get current data/title/source on EWW buffer for EMACS 25+

#+BEGIN_SRC emacs-lisp
  (defun eww-current-title nil
    "Return title of the Web page the current EWW buffer is visiting."
    (plist-get eww-data :title))

  (defun eww-current-source ()
    "Return source of the Web page the current EWW buffer is visiting."
    (plist-get eww-data :source))
#+END_SRC

*** eww copy current title and url to kill-ring

#+BEGIN_SRC emacs-lisp

  (defun eww-copy-current-title ()
    (interactive)
    (yank-url-or-title (eww-current-title)))

  (defun eww-copy-title-url ()
    (interactive)
    (yank-url-or-title (concat (eww-current-title) "\n" (eww-current-url))))

  (defun eww-copy-title-url-org ()
    (interactive)
    (yank-url-or-tilte (org-make-link-string (eww-current-url) (eww-current-title))))

  (defun eww-copy-current-source ()
    (interactive)

    (yank-url-or-title (eww-current-source)))

#+END_SRC

** elfeed

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package elfeed
    :bind ("C-c e" . elfeed)
    :config
    <<elfeed-config>>)
#+END_SRC

*** set faces
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (custom-set-faces
   '(elfeed-search-unread-title-face ((t :inherit default)))
   '(elfeed-search-title-face ((t :inherit font-lock-comment-face)))
   '(elfeed-search-date-face ((t (:inherit font-lock-string-face))))
   '(elfeed-search-feed-face ((t (:inherit font-lock-doc-face))))
   '(elfeed-search-tag-face ((t (:inherit font-lock-constant-face))))
   )

  (defface elfeed-search-starred-title-face
    '((t :foreground "#cc6666"))
    "Marks a starred Elfeed entry.")

  (defface elfeed-search-mustread-title-face
    '((t :foreground "#cc6666"))
    "Marks a mustread Elfeed entry.")

  (defface elfeed-search-it-title-face
    '((t :foreground "#b5bd68"))
    "Marks a news Elfeed entry.")

  (defface elfeed-search-finace-title-face
    '((t :foreground "#8abeb7"))
    "Marks a finace news Elfeed entry.")

  (defface elfeed-search-read-title-face
    '((t :inherit font-lock-comment-face))
    "Marks a finace news Elfeed entry.")

  (defface elfeed-search-junk-title-face
    '((t :inherit font-lock-comment-face))
    "Marks a junk Elfeed entry.")

  ;; (push '(it elfeed-search-it-title-face) elfeed-search-face-alist)
  ;; (push '(emacs elfeed-search-it-title-face) elfeed-search-face-alist)
  ;; (push '(finace elfeed-search-finace-title-face) elfeed-search-face-alist)
  (push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)
  (push '(star elfeed-search-starred-title-face) elfeed-search-face-alist)
  (push '(mustread elfeed-search-mustread-title-face) elfeed-search-face-alist)
  ;; (push '(read elfeed-search-read-title-face) elfeed-search-face-alist)
  ;; (push '(junk elfeed-search-junk-title-face) elfeed-search-face-alist)

  ;; (theme-color
  ;; (background . "#1d1f21")
  ;; (current-line . "#282a2e")
  ;; (selection . "#373b41")
  ;; (foreground . "#c5c8c6")
  ;; (comment . "#969896")
  ;; (red . "#cc6666")
  ;; (orange . "#de935f")
  ;; (yellow . "#f0c674")
  ;; (green . "#b5bd68")
  ;; (aqua . "#8abeb7")
  ;; (blue . "#81a2be")
  ;; (purple . "#b294bb"))

#+END_SRC

*** using curl to get feeds
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (setq elfeed-use-curl t)
#+END_SRC

*** update feeds when enter elfeed first time
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (add-hook 'elfeed-search-mode-hook
            '(lambda() (progn
                         (elfeed-update))))
#+END_SRC

*** TODO when enter elfeed-show-mode then refresh first
dont work because elfeed-show-mode run elfeed-show-refresh already
*useless*
#+BEGIN_SRC emacs-lisp :tangle no
:noweb-ref elfeed-config
  (defun my/elfeed-show-mode-hook ()
    (message "%s" "My elfeed show hook")
    (call-interactively 'elfeed-show-refresh))

  (add-hook 'elfeed-show-mode-hook 'my/elfeed-show-mode-hook)
#+END_SRC

*** remove tag 'unread' if news was 1 week ago
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (add-hook 'elfeed-new-entry-hook
            '(lambda() (progn
                         (elfeed-make-tagger :before "1 week ago"
                                             :remove 'unread))))
#+END_SRC

*** remove some uninteresting topic
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'elfeed-new-entry-hook
          (elfeed-make-tagger :entry-title "集中市場認購*"
                              :add 'junk
                              :remove 'unread))
#+END_SRC

*** keybindings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (unbind-key "y" elfeed-search-mode-map)
  (bind-keys :map elfeed-search-mode-map
	     ("m" . elfeed-toggle-star)
	     ("j" . next-line)
	     ("k" . previous-line)
	     ("l" . forward-char)
	     ("h" . backward-char)
	     ("f" . avy-goto-line)
	     ("d" . scroll-up-command)
	     ("e" . scroll-down-command)
	     ("g" . elfeed-update)
	     ("a" . my/cycle-elfeed-search-filter)
	     ("R" . elfeed-search-mark-all-read)
	     ("B" . elfeed-search-external-browser)
             ("C-<return>" . elfeed-search-browse-url)
	     ("yy" . copy-elfeed-search-url)
	     ("yt" . copy-elfeed-search-title)
	     ("yu" . copy-elfeed-search-title-url)
	     ("yo" . copy-elfeed-search-org)
	     ("w" . copy-elfeed-search-url)
	     ("ok" . elfeed-search-to-kindle))

  (unbind-key "y" elfeed-show-mode-map)
  (bind-keys :map elfeed-show-mode-map
	     ("j" . next-line)
	     ("k" . previous-line)
	     ("l" . forward-char)
	     ("h" . backward-char)
	     ("f" . link-hint-open-link)
	     ("d" . scroll-up-command)
	     ("e" . scroll-down-command)
	     ("B" . elfeed-show-external-browser)
	     ("C-<return>" . elfeed-show-visit)
	     ("yy" . copy-elfeed-show-url)
	     ("yt" . copy-elfeed-show-title)
	     ("yu" . copy-elfeed-show-title-url)
	     ("yo" . copy-elfeed-show-org)
	     ("w" . copy-elfeed-show-url)
	     ("ok" . elfeed-show-to-kindle))
#+END_SRC

*** set default search-filter
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (setq elfeed-search-filter "@1-weeks-ago +unread")
#+END_SRC

*** reset to default filter
#+BEGIN_SRC emacs-lisp
  (defun elfeed-reset-to-default-filter ()
    (interactive)
    (elfeed-search-set-filter "@1-week-ago +unread"))
#+END_SRC

*** cycle filters

#+BEGIN_SRC emacs-lisp
  (defun my/cycle-elfeed-search-filter ()
    (interactive)

    (let* ((filters ["" "+emacs" "+it" "+finace" "-news" "+news1" "+news2"])
	   (index-before
	    (if (get 'my/cycle-elfeed-search-filter 'filter-index)
		(get 'my/cycle-elfeed-search-filter 'filter-index)
	      0))
	   (index-after (% (+ index-before 1) (length filters)))
	   (next-filter (format "@1-week-ago %s +unread" (aref filters index-after))))

      (put 'my/cycle-elfeed-search-filter 'filter-index index-after)
      (elfeed-search-set-filter next-filter)
      (beginning-of-buffer)
      ))
#+END_SRC

*** elfeed-search mark current entry
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-mark-all-read ()
    "mark all feed as read in elfeed search mode"

    (interactive)
    (mark-whole-buffer)
    (elfeed-search-untag-all-unread))
#+END_SRC

*** elfeed toggle star
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'starred))
#+END_SRC

*** get url and/or title from elfeed entry

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun elfeed-entry-url (entry)
    (and entry (elfeed-entry-link entry)))

  (defun elfeed-link-title (entry)
    (and entry (elfeed-entry-title entry)))

  (defun elfeed-entry-title-url (entry)
    (concat (elfeed-link-title entry) "\n" (elfeed-entry-url entry)))

  (defun elfeed-entry-link-org (entry)
    (concat "[[" (elfeed-entry-url entry) "][" (elfeed-link-title entry) "]]"))
#+END_SRC

*** get current url and/or title in elfeed-search

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun get-elfeed-search-url ()
    (elfeed-entry-url (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-title ()
    (elfeed-link-title (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-title-url ()
    (elfeed-entry-title-url (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-org ()
    (elfeed-entry-link-org (elfeed-search-selected :ignore-region)))
#+END_SRC

*** get current url and/or title in elfeed-show

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun get-elfeed-show-url ()
    (elfeed-entry-url elfeed-show-entry))

  (defun get-elfeed-show-title ()
    (elfeed-link-title elfeed-show-entry))

  (defun get-elfeed-show-title-url ()
    (elfeed-entry-title-url elfeed-show-entry))

  (defun get-elfeed-show-org ()
    (elfeed-entry-link-org elfeed-show-entry))

#+END_SRC

*** yank url and/or title in elfeed search mode

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun yank-url-or-title (url-or-title)
    (message "%s" url-or-title)
    (kill-new url-or-title))

  (defun copy-elfeed-search-url ()
    "copy url to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-search-url)))

  (defun copy-elfeed-search-title ()
    "copy title to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-search-title)))

  (defun copy-elfeed-search-title-url ()
    "copy title and url to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-search-title-url)))

  (defun copy-elfeed-search-org ()
    "copy url to clipboard as org-mode formate"

    (interactive)
    (yank-url-or-title (get-elfeed-search-org)))
#+END_SRC

*** yank url and/or title in elfeed show mode

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun copy-elfeed-show-url ()
    "copy url to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-show-url)))

  (defun copy-elfeed-show-title ()
    "copy url to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-show-title)))

  (defun copy-elfeed-show-title-url ()
    "copy title and url to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-show-title-url)))

  (defun copy-elfeed-show-org ()
    "copy title and url to clipboard"

    (interactive)
    (yank-url-or-title (get-elfeed-show-org)))

#+END_SRC

*** open page by external browser

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun elfeed-search-external-browser ()
    "open current url via extenal browser"

    (interactive)
    (elfeed-search-browse-url t))

  (defun elfeed-show-external-browser ()
    "open current url via extenal browser"

    (interactive)
    (elfeed-show-visit t))

#+END_SRC

** elfeed-goodies

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-goodies
    :init
    (elfeed-goodies/setup))
#+END_SRC

** elfeed-org

using org-mode to manage feed url

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :init
    (progn
      (setq rmh-elfeed-org-files (list "~/.elfeed.org"))
      (elfeed-org)))
#+END_SRC

*** Insert stock ids at point in elfeed.org
Insert stock ids to '.elfeed.org' and read their RSS

#+BEGIN_SRC emacs-lisp
  (use-package esqlite
    :config
    (progn
      (defun insert-stock-id-at-point ()
        "Insert stock ids at point."

        (interactive)

        (if (string= ".elfeed.org" (buffer-name))
            (let* ((db-name "/mnt/lvm-data/Programing/stock4/db/stock2.db")
                   (sql-fetch-stock-ids "select s.sid, i.name from summary as s, stock_info as i where s.sid=i.sid and s.userid=\"mariolong\""))

              (dolist (rec (esqlite-read db-name sql-fetch-stock-ids))
                (insert (format "*** [[http://news.wearn.com/rss/%s][%s-%s]]\n"
                                (s-trim (car rec))
                                (s-trim (car rec))
                                (s-trim (second rec))))))

          (message "%s" "Must in '.elfeed.org'")))

      (bind-key "C-c fi" 'insert-stock-id-at-point)
      ))
#+END_SRC

** hangups

ref: https://github.com/jtamagnan/hangups.el

#+BEGIN_SRC emacs-lisp
  (use-package hangups
    :load-path
    :ensure adaptive-wrap
    :bind (("C-c h" . hangups-open-conversation-small-p)
	   :map hangups-conv-mode-map
	   ("j" . next-line)
	   ("k" . previous-line)
	   ("l" . forward-char)
	   ("h" . backward-char)
	   ("d" . scroll-up-command)
	   ("e" . scroll-down-command)
	   ("o" . browse-at-point))
    :config
    (progn
      (defun hangups-open-conversation-small-p ()
	"Open conversation to small-p."
	(interactive)

	(hangups)
	(let ((name "小p_葉"))
	  (switch-to-buffer (get-buffer-create (hangups/buffer-name name)))
	  (hangups-conv-mode)
	  (hangups-conversation name hangups-messages))

	(add-hook 'hangups-list-mode-hook
		  (lambda () (run-with-timer 120 (* 1 60) 'hangups-list-refresh)))

	(spaceline-define-segment hangups-lighter
	  "hangups conversations"
	  (when (> hangups/convs-unread 0)
	    "\u2706")
	  :face font-lock-warning-face)

	(spaceline-spacemacs-theme '(hangups-lighter)))
      ))
#+END_SRC

** erc
* Org and GTD                                                           :Org:

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
   (use-package org
     :ensure nil
     :mode ("\\.org\\'" . org-mode)
     :config
     <<org-config>>)
#+END_SRC

** basic setup
 #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
   (setq org-src-fontify-natively t
         org-src-window-setup 'current-window
         org-confirm-babel-evaluate nil
         org-startup-indented t)
 #+END_SRC

** Extend org-mode's easy templates

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (add-to-list 'org-structure-template-alist
               '("T" "#+TITLE:?\n#+AUTHOR:\n#+DATE:"))
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
  (add-to-list 'org-structure-template-alist
               '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))
#+END_SRC

** Extend babel support languages

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (ditaa . t)
     (dot . t)
     (js . t)
     (latex . t)
     (perl . t)
     (python . t)
     (ruby . t)
     (sh . t)
     (clojure . t)
     ))
#+END_SRC

** Capture and Agenda
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (setq org-agenda-window-setup 'current-window)
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)

  (setq org-directory "~/Dropbox/GTD")
  (setq org-default-notes-file (expand-file-name "notes.org" org-directory)
	org-default-ideas-file (expand-file-name "0.Tasks.org" org-directory))

  (setq org-capture-templates
	'(("t" "Todo" entry (file org-default-ideas-file)
	   "* TODO %?\n%T" :prepend t)
	  ("e" "Emacs" entry (file+headline org-default-notes-file "emacs")
	   "* TODO %?\n%T")
	  ("n" "Note" entry (file+headline org-default-notes-file "Notes")
	   "* %?\n%T")
	  ))

  (setq org-agenda-files (list org-default-notes-file
			       org-default-ideas-file))

  (setq org-refile-targets '((nil :maxlevel . 2)              ; refile to headings in the current buffer
			     (org-agenda-files :maxlevel . 1) ; refile to any of these files
			     ))

  (add-hook 'org-agenda-mode-hook
	    '(lambda ()
	       (local-set-key (kbd "C-g") 'org-agenda-exit)))

#+END_SRC

** keybinds
- =C-c '= 編輯原始碼
- =C-Return= 增加一個標題
- =C-c *= org-toggle-heading or table result
- =C-<left>/<right>= 對標題設定 TODO keywords
- =C-<up>/<down>= 對標題設定重要性
- =<TAB>= 循環展開一個標題 (含子標題)
- =S-<TAB>= 循環展開全檔的標題
- =C-c C-o= open url link
- =C-c C-c= 增加或修改 tags
- =C-c \= 展開本檔相對應 tag 的標題，可用 & | 串接，做邏輯性查詢

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (bind-key "C-c l" 'org-store-link)
  (bind-key "C-c c" 'org-capture)
  (bind-key "C-c a" 'org-agenda)
  (unbind-key "C-c [")
  (unbind-key "C-c ]")
#+END_SRC

** Pretty Bullets
ref: https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :init
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

** Present by reveal.js
1. ref: https://github.com/hakimel/reveal.js
2. ref: https://github.com/yjwen/org-reveal

#+BEGIN_QUOTE
Reveal.js is a tool for creating good-looking HTML presentations,
authored by Hakim El Hattab.

Org-Reveal exports your Org documents to reveal.js presentations.
With Org-reveal, you can create beautiful presentations with 3D
effects from simple but powerful Org contents.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :ensure htmlize
    :config
    (progn
      (setq org-reveal-root "file:///mnt/lvm-data/github/reveal.js")))
#+END_SRC

** pop up a new frame to do a capture

#+BEGIN_SRC sh
  $ emacsclient -ne "(make-capture-frame)"
#+END_SRC

press =C-x w= to close this frame

#+BEGIN_SRC emacs-lisp
  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))
#+END_SRC

** archive all the DONE/CNACELED tasks by one command
ref: http://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command

#+BEGIN_SRC emacs-lisp
  (defun org-archive-done-tasks ()
    (interactive)

    (dolist (status '("/DONE" "/CANCELED"))
      (org-map-entries (lambda ()
			 (org-archive-subtree)
			 (setq org-map-continue-from (outline-previous-heading)))
		       status 'file)))
#+END_SRC

* Python
Python 的 emacs 設定有太多的選擇，我的選擇是 =elpy= ，原因是單純，只要安裝好 =elpy= 就可。

ref: https://github.com/jorgenschaefer/elpy
ref: https://github.com/xiaohanyu/oh-my-emacs/blob/master/modules/ome-python.org

First, install =elpy= and =jedi= on OS

#+BEGIN_SRC sh
  pip install elpy jedi
#+END_SRC

然後，參考 oh-my-emacs 簡單設定一下就好。

ref: yasnippet http://longhorizon.org/blog/2013/03/31/improving-python-development-in-emacs-with-yasnippet/

#+BEGIN_SRC emacs-lisp
  (use-package elpy
    :ensure t
    :demand (flycheck company yasnippet)
    :diminish "☀"
    :config
    (progn
      (elpy-enable)
      (setq elpy-rpc-backend "jedi")

      (setq elpy-modules (delq 'elpy-module-highlight-indentation elpy-modules))
      (eval-after-load 'flycheck
        '(progn
           (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
           (add-hook 'elpy-mode-hook 'flycheck-mode)))

      (add-to-list 'elpy-modules 'elpy-module-company)
      (add-to-list 'elpy-modules 'elpy-module-yasnippet)

      (define-key python-mode-map (kbd "RET")
        'newline-and-indent)

      (add-hook 'python-mode-hook
                (lambda ()
                  (set (make-local-variable 'comment-inline-offset) 2)))
      ))
#+END_SRC

* Web mode
** web-mode

目前是為了 mako 使用的 web-mode，看起來還有一些問題需要微調，不知如何下手。

Homepage: http://web-mode.org/
Source: https://github.com/fxbois/web-mode

ref: http://cestlaz.github.io/posts/using-emacs-21-web-mode/#.WCy93XeZOuU

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :config
    (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode))
    (setq web-mode-engines-alist  '(("mako" . "\\.tmpl\\'")))
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

    (setq web-mode-ac-sources-alist
	  '(("css" . (ac-source-css-property))
	    ("html" . (ac-source-words-in-buffer ac-source-abbrev))))
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t)

    (defun my-web-mode-hook ()
      "Hooks for Web mode."

      (setq web-mode-markup-indent-offset 4)
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2))

    (add-hook 'web-mode-hook  'my-web-mode-hook))

#+END_SRC

** emmet-mode

類似 zencoding 的工具
用類似 css 的語法寫 html 檔

Homepage: http://emmet.io/
Source: https://github.com/smihica/emmet-mode

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :init
    (progn
      (add-hook 'sgml-mode-hook 'emmet-mode)
      (add-hook 'css-mode-hook  'emmet-mode)
      (add-hook 'emmet-mode-hook
                (lambda () (setq emmet-indentation 4)))))
#+END_SRC

** js2-mode

Source: https://github.com/mooz/js2-mode

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :ensure t
  :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
      (add-hook 'js2-mode-hook 'flycheck-mode)))
#+END_SRC

** json-mode

Source: https://github.com/joshwnj/json-mode

#+BEGIN_SRC emacs-lisp
(use-package json-mode
  :ensure t
  :init (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode)))
#+END_SRC

* Other Modes
** SQL

在 SQL 視窗中，自動轉行，能看到所有資料

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (toggle-truncate-lines nil)))
#+END_SRC

** Shell
** systemd-mode

會自動以 company 補全，不必再設定。

#+BEGIN_SRC emacs-lisp
  (use-package systemd)
#+END_SRC

*** keybindings

(define-key map (kbd "C-c C-d") 'systemd-doc-directives)
(define-key map (kbd "C-c C-o") 'systemd-doc-open)

** markdown-mode

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.markdown\\'" . gfm-mode))
      (add-to-list 'auto-mode-alist '("\\.md\\'" . gfm-mode))))
#+END_SRC

** ReStructure

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rst\\'" . rst-mode))
#+END_SRC

** Haskell

只是為了 xmonad 和 taffybar。

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :demand (flycheck flycheck-haskell)
    :mode "\\.hs$" "\\.l?hs$"
    :config
    (progn (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
           (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
           (add-hook 'haskell-mode-hook 'haskell-decl-scan-mode)

           (defun my-haskell-hook ()
             (setq mode-name " λ ")

             (turn-on-haskell-doc)
             (diminish 'haskell-doc-mode "")
             (capitalized-words-mode)

             (diminish 'capitalized-words-mode "")
             (turn-on-eldoc-mode)

             (diminish 'eldoc-mode "")
             (turn-on-haskell-decl-scan)
             (setq evil-auto-indent nil))

           ;;(setq haskell-font-lock-symbols 'unicode)
           ;;(setq haskell-literate-default 'tex)
           ;;(setq haskell-stylish-on-save t)
           ;;(setq haskell-tags-on-save t)
           (add-hook 'haskell-mode-hook 'my-haskell-hook)))
#+END_SRC

*** flycheck-haskell

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-haskell
    :config (add-hook 'flycheck-mode-hook #'flycheck-haskell-setup))
#+END_SRC

** nginx-mode

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode)
#+END_SRC

** sdcv

http://lifegoo.pluskid.org/wiki/EmacsStardict.html

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c d" 'kid-sdcv-to-buffer)

  (defun kid-sdcv-to-buffer ()
    (interactive)
    (let ((word (if mark-active
                    (buffer-substring-no-properties (region-beginning) (region-end))
		  (current-word nil t))))
      (setq word (read-string (format "Search the dictionary for (default %s): " word)
                              nil nil word))

      (set-buffer (get-buffer-create "*sdcv*"))
      (buffer-disable-undo)
      (erase-buffer)

      (let ((process (start-process-shell-command "sdcv" "*sdcv*" "sdcv" "-n" word)))
	(set-process-sentinel
	 process
	 (lambda (process signal)
           (when (memq (process-status process) '(exit signal))
             (unless (string= (buffer-name) "*sdcv*")
               (setq kid-sdcv-window-configuration (current-window-configuration))
               (switch-to-buffer-other-window "*sdcv*")
               (local-set-key (kbd "d") 'kid-sdcv-to-buffer)
               (local-set-key (kbd "q") (lambda ()
                                          (interactive)
                                          (bury-buffer)
                                          (unless (null (cdr (window-list))) ; only one window
                                            (delete-window)))))
             (goto-char (point-min))))))))
#+END_SRC
** moedict 萌典

#+BEGIN_SRC emacs-lisp :noweb no-export :export code
  (use-package moedict
    :load-path
    :ensure helm
    :ensure esqlite
    :bind ("C-c m" . moedict)
    :config
    <<moedict-config>>)
#+END_SRC

*** set browser program to google-chrome

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref moedict-config

  (setq browse-url-chromium-program "google-chrome-stable")

#+END_SRC

*** using moedict by ivy

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref moedict-config
  (defun counsel-moedict ()
    "moedict"

    (interactive)

    (let ((initial-input (word-at-point)))
      (ivy-read moedict-prompt
		'(lambda (x) (counsel-moedict-function x))
		:initial-input initial-input
		:dynamic-collection t
		:action #'moedict-lookup-and-show-in-buffer
		)))

  (defun counsel-moedict-function (&optional string)
    (if (null string)
	(setq string ""))
    (or (unless (string= "" string)
	  (moedict-get-candidates-list string))
	(list nil)))
#+END_SRC
** pdf-tools

如果出現「無安裝 epdfinfo」錯誤訊息，則執行一次 =M-x pdf-tools-install= 即可。
或uninstall 後 re-install.

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :bind (:map pdf-view-mode-map
		("j" . pdf-view-next-line-or-next-page)
		("k" . pdf-view-previous-line-or-previous-page)
		("H" . pdf-view-next-page)
		("L" . pdf-view-previous-page)
		("e" . pdf-view-scroll-down-or-previous-page)
            ("u" . pdf-view-scroll-down-or-previous-page)
		("d" . pdf-view-scroll-up-or-next-page)
		("=" . pdf-view-fit-width-to-window)
		("-" . pdf-view-shrink)
		("+" . pdf-view-enlarge))
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
      (setq pdf-view-continuous t)
      ))
#+END_SRC

* End of configuration
** diminish some mode

#+BEGIN_SRC emacs-lisp
  (diminish 'overwrite-mode)
  (diminish 'subword-mode)
  (eval-after-load 'org-indent
    '(diminish 'org-indent-mode))
  (diminish 'org-src-mode)
#+END_SRC

** Startup emacs as server
#+BEGIN_SRC emacs-lisp
(use-package server
:config
  (unless (server-running-p)
    (server-start)))
#+END_SRC

* The Final note

使用 emacs 會上癮，尤其是 lisp 這種語言，真的迷人，只是要花很多時間熟
悉這套工具。熟悉了這個工具，真的就不想用其它的編輯器，也不能用其它的編
輯器了。

因為，已經習慣自己一手打造出來，獨一無二，順手的工具。

* Reference

[1] https://github.com/coldnew/coldnew-emacs

[2] https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Bdistribution/spacemacs/packages.el

[3] https://github.com/tjarvstrand/config-files/blob/master/.emacs

[4] https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-spell.el

[5] https://github.com/zamansky/using-emacs/blob/master/myinit.org

[6] http://pages.sachachua.com/.emacs.d/Sacha.html

[7] https://github.com/itsjeyd/.emacs.d/blob/emacs24/init.el

[8] https://github.com/aculich/.emacs.d/blob/master/init.el

#+TITLE: Emacs Configuration
#+AUTHOR: Mario Long
#+EMAIL: mariolong5782@gmail.com
#+STARTUP: overview showstars
#+BABEL: :cache yes
#+OPTIONS: ^:nil toc:2
#+LANGUAGE: zh-TW
#+DATE: 2018-06-25 17:42:36 UTC+08:00
#+TODO: TODO(t) WAITING(w) MAYBE(m) BLOG(b) | DONE(d) CANCELED(c)

* Preface

‰ª• org-mode ÂØ´ emacs Ë®≠ÂÆöÊ™îÔºåÂΩ∑ÂΩøÂú®ÂØ´‰∏ÄÁØáËèØÈ∫óÁöÑÊñáÁ´†ÔºåÂú®Ë®¥Ë™™Ëëó‰∏ÄÂÄãÈÄêÊ≠•
ÊàêÈï∑ÁöÑÊïÖ‰∫ãÔºåÊØè‰∏ÄÊÆµÁ®ãÂºèÈÉΩÊòØ‰∏ÄÂÄãÊÑüÂãï„ÄÇ

* Testing this configuration

Âü∑Ë°å ~makeinit.sh~ Áî¢Áîü ~init.el~
#+BEGIN_SRC sh :tangle no
./makeinit.sh
#+END_SRC

* Initialization
** Use lexical binding

#+BEGIN_SRC emacs-lisp :padline no
  ;; -*- lexical-binding: t -*-
#+END_SRC

** load prefer newer

#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

** cleanup screen
*** no menu bar, no tool bar, no scroll bar

Press <F10> to show menu

#+begin_src emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

*** fullscreen

#+begin_src emacs-lisp
  (modify-all-frames-parameters '((fullscreen . maximized)))
#+end_src

*** inhibit startup message

#+begin_src emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message t)
#+end_src

*** clean message of redefinition

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

*** my scratch message

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message ";;‰ªäÂ§©ÂèàÊòØÁæéÂ•ΩÁöÑ‰∏ÄÂ§©\n")
#+END_SRC

** Font settings

ÁúºÁùõ‰∏çÂ•Ω‰∫ÜÔºåÊääÂ≠óÂûãÊîæÂ§ß‰∫õÔºåÊúÄÈáçË¶ÅÁöÑÊòØË®≠ÂÆö‰∏≠ÊñáÂ≠óÂûãÂíåË°®ÊÉÖÁ¨¶Ëôü„ÄÇ
123456789012345678901234567890123456789012345678901234567890

error: Fontset `tty' does not exist
solution: http://www.cnblogs.com/aqing1987/p/4464106.html

#+begin_src emacs-lisp
  (defun set-font-for-chinese ()
    (set-face-attribute 'default nil
                        :family "Source Code Pro" :height 180)
    (set-face-attribute 'variable-pitch nil
                        :family "Sans" :height 200 :weight 'regular)

    (dolist (charset '(kana han cjk-misc bopomofo))
      (set-fontset-font (frame-parameter nil 'font) charset
                        (font-spec :family "Source Han Sans" :size 28)))

    (set-fontset-font (frame-parameter nil 'font) 'symbol
                      (font-spec :family "Symbola" :size 32)))

  (add-to-list 'after-make-frame-functions
               (lambda (new-frame)
                 (select-frame new-frame)
                 (if window-system
                     (set-font-for-chinese))))

  (when window-system
    (set-font-for-chinese))
#+end_src

** Define user's directory variables

#+BEGIN_SRC emacs-lisp
  (defconst user-emacs-directory (file-name-directory (or load-file-name (buffer-file-name))))
  (defconst user-emacs-init-org (expand-file-name "emacs-init.org" user-emacs-directory))
  (defconst emacs-init-el (expand-file-name "init.el" user-emacs-directory))
  (defconst user-secret-file (expand-file-name "personal.el" user-emacs-directory))
  ;; (defconst org-gcal-file-schedule (expand-file-name "gschedule.org" user-emacs-directory))

  (defconst user-cache-directory
    (file-name-as-directory (expand-file-name ".cache" user-emacs-directory))
    "My emacs storage area for persistent files.")

  (setq org-directory "~/Dropbox/GTD")
  (setq org-default-notes-file (expand-file-name "myGTD.org" org-directory)
        org-default-inbox-file (expand-file-name "myGTD.org" org-directory)
        org-my-notes-file (expand-file-name "notes.org" org-directory)
        org-my-food-file (expand-file-name "food.org" org-directory)
        )
#+END_SRC

** Create temporary file directory if it is not exist

#+BEGIN_SRC emacs-lisp
  (set-default 'temporary-file-directory (expand-file-name "tmp" user-emacs-directory))
  (unless (file-exists-p temporary-file-directory)
    (make-directory temporary-file-directory))
#+END_SRC

** Add .emacs.d/lisp to load path

NOTE: Don't use like xxx.el as directory name.

#+BEGIN_SRC emacs-lisp
(let* ((lisp-dir '("lisp/" "themes/")))
  (dolist (lisp-path lisp-dir)
    (when (not (file-exists-p lisp-path))
      (make-directory (concat user-emacs-directory lisp-path) t))
    (let* ((load-dir (concat user-emacs-directory lisp-path))
	   (default-directory load-dir))
      (setq load-path
	    (append
	     (let ((load-path (copy-sequence load-path)))
	       (append
		(copy-sequence (normal-top-level-add-to-load-path '(".")))
		(normal-top-level-add-subdirs-to-load-path)))
	     load-path)))))
#+END_SRC

** Package Management
*** Initialize =package=

Áî® =package.el= Ë¶ÅÂÖàÂä†‰æÜÊ∫êÂ∫´„ÄÇ

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

  (package-initialize)
#+END_SRC

*** Install ~use-package~

Switch to use-package form req-package.

*error message: (error "Package ‚Äòdired-‚Äô is unavailable")*

Use =:ensure nil= to override =use-package-always-ensure=.
You need to do this for any non-package.el packag

#+BEGIN_SRC emacs-lisp
  (if (not (package-installed-p 'use-package))
      (progn
        (package-refresh-contents)
        (package-install 'use-package)))

  (require 'use-package)
  (setq use-package-always-defer t)
  (setq use-package-always-ensure t)
#+END_SRC

*** Install ~quelpa-use-package~

[[https://github.com/quelpa/quelpa-use-package][GitHub - quelpa/quelpa-use-package]]

#+BEGIN_SRC emacs-lisp
  (use-package quelpa-use-package
    :init
    (require 'quelpa-use-package))
#+END_SRC

*** Paradox

Project for modernizing Emacs' Package Menu.
With package ratings, usage statistics, customizability, and more.

[[https://github.com/Malabarba/paradox][GitHub - Malabarba/paradox: Project for modernizing Emacs' Package Menu.]]

#+BEGIN_SRC emacs-lisp
  (use-package paradox
    :config
      (setq paradox-execute-asynchronously t))
#+END_SRC

** Tangle init.org when it saved

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are tangled."
    (interactive)
    (require 'async)
    (let ((buffer-name "async-make-init.el"))
      (when (equal (buffer-file-name) user-emacs-init-org)
        (message "Begin re-generate init.el")
        (async-start-process buffer-name "sh"
                             '(lambda (result)
                                (message "Re-Generate init.el finish." result))
                             (expand-file-name "makeinit.sh" user-emacs-directory)))))

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

* Configurations
** Appearance
*** Theme

#+begin_src emacs-lisp
(use-package color-theme-sanityinc-tomorrow
    :init
      (load-theme 'sanityinc-tomorrow-night :no-confirm))
#+end_src

*** spaceline

[[https://github.com/TheBB/spaceline][GitHub - TheBB/spaceline: Powerline theme from Spacemacs]]

#+BEGIN_SRC emacs-lisp
  (use-package spaceline-config
    :ensure spaceline
    :commands spaceline-spacemacs-theme
    :init
    (setq-default powerline-default-separator 'wave
                  spaceline-minor-modes-separator ""
                  spaceline-workspace-numbers-unicode t
                  spaceline-window-numbers-unicode t)
    (spaceline-spacemacs-theme)
    )
#+END_SRC

*** Change cursor color according to mode

#+BEGIN_SRC emacs-lisp
  (defvar hcz-set-cursor-color-color "")
  (defvar hcz-set-cursor-color-buffer "")
  (defun hcz-set-cursor-color-according-to-mode ()
    "change cursor color according to some minor modes."
    ;; set-cursor-color is somewhat costly, so we only call it when needed:
    (let ((color
           (if buffer-read-only "white"
             (if overwrite-mode "#5599aa"
               "#f99157"))))
      (unless (and
               (string= color hcz-set-cursor-color-color)
               (string= (buffer-name) hcz-set-cursor-color-buffer))
        (set-cursor-color (setq hcz-set-cursor-color-color color))
        (setq hcz-set-cursor-color-buffer (buffer-name)))))

  (add-hook 'post-command-hook 'hcz-set-cursor-color-according-to-mode)
#+END_SRC

*** fringe

ÊîπÂæóÁ¥∞‰∏ÄÈªûÔºåÈ†êË®≠ÂÄºÊòØ 8 pixel

#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)
#+END_SRC

*** beacon

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :diminish ""
    :init
    (beacon-mode 1))
#+END_SRC

*** Line Numbers

from 26.1, using ~(setq display-line-numbers 'relative)~ to display line number.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook
            '(lambda ()
               (setq display-line-numbers 'relative)))
#+END_SRC

*** Highlight FIXME, TODO in program mode

#+BEGIN_SRC emacs-lisp
  (defun font-lock-comment-annotations ()
    "Highlight a bunch of well known comment annotations.
  This functions should be added to the hooks of major modes for programming."

    (font-lock-add-keywords
     nil
     '(("\\<\\(FIX\\(ME\\)?\\|BUG\\|HACK\\):" 1 font-lock-warning-face t)
       ("\\<\\(NOTE\\):" 1 'org-level-2 t)
       ("\\<\\(TODO\\):" 1 'org-todo t)
       ("\\<\\(DONE\\):" 1 'org-done t))
     ))

  (add-hook 'prog-mode-hook 'font-lock-comment-annotations)
#+END_SRC

*** Â∞áÊªëÈº†Ê∏∏Ê®ôÁßªËá≥Âè≥‰∏äËßí

#+BEGIN_SRC emacs-lisp
  (mouse-avoidance-mode 'banish)
#+END_SRC

*** Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
  (global-font-lock-mode t)
#+END_SRC

** Chinese setup
*** don't use input-method via C-\
#+BEGIN_SRC emacs-lisp
  (unbind-key "C-\\")
#+END_SRC

*** pangu-spacing

Ëá™ÂãïÂú®‰∏≠Ëã±ÊñáÂ≠óÈñìÂä†ÂÖ•Á©∫ÁôΩÔºå‰ª•Âà© 123 Èñ±ËÆÄ

#+BEGIN_SRC emacs-lisp
  (use-package pangu-spacing
    :diminish ""
    :init
    (global-pangu-spacing-mode 1)

    :config
    ;; disable pangu-space in some modes
    (dolist (mm '(wdired-mode dired-mode eww-mode elfeed-search-mode elfeed-show-mode))
      (add-to-list 'pangu-spacing-inhibit-mode-alist mm))

    ;; Always insert `real' space
    (dolist (mm '(markdown-mode-hook rst-mode-hook org-mode-hook))
      (add-hook mm '(lambda()
                      (set (make-local-variable 'pangu-spacing-real-insert-separtor) t)))))
#+END_SRC

*** fcitx

ÈÄ≤ÂÖ• normal mode ÊôÇÔºåËá™ÂãïÂàáÊèõËá≥Ëã±ÊñáËº∏ÂÖ•Ê®°Âºè

#+BEGIN_SRC emacs-lisp
  (use-package fcitx
    :init (fcitx-aggressive-setup))
#+END_SRC

** Basic settings
*** Set prefer coding to utf-8

#+BEGIN_SRC emacs-lisp
  (prefer-coding-system 'utf-8)
  (setq system-time-locale "en_US" )
#+END_SRC
*** use noflet no defer
#+BEGIN_SRC emacs-lisp
  (use-package noflet
    :defer 0)
#+END_SRC

*** Don't ask me when close emacs with process is running

#+BEGIN_SRC emacs-lisp
  (require 'noflet)
  (defadvice save-buffers-kill-emacs (around no-query-kill-emacs activate)
    "Prevent annoying \"Active processes exist\" query when you quit Emacs."
    (noflet ((process-list ())) ad-do-it))
#+END_SRC

*** Don't ask me when kill process buffer

#+BEGIN_SRC emacs-lisp
  (setq kill-buffer-query-functions
        (remq 'process-kill-buffer-query-function
              kill-buffer-query-functions))
#+END_SRC

*** Delete trailing whitespace before save buffer

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

*** set tab width

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
  (defvaralias 'c-basic-offset 'tab-width)
  (setq sh-basic-offset 4)
#+END_SRC

*** ethan-wspace

Takes care of trailing whitespaces (removal, highlighting)
[[https://github.com/glasserc/ethan-wspace][GitHub - glasserc/ethan-wspace: the definitive emacs customizations for people who are OCD about whitespace]]

#+BEGIN_SRC emacs-lisp
  (use-package ethan-wspace
    :diminish "üÑ£"
    :init
    (global-ethan-wspace-mode 1)
    :config
    (progn
      ;; Turn off `mode-require-final-newline' since ethan-wspace
      ;; supersedes `require-final-newline'.
      (setq mode-require-final-newline nil)

      ;; Prevent etha-wspace touch my TAB on makefile mode
      (add-hook 'makefile-mode-hook
                '(lambda()
                   (setq ethan-wspace-errors (remove 'tabs ethan-wspace-errors))))

      ;; Ignore no trailing newline error
      (setq-default ethan-wspace-errors (remove 'no-nl-eof ethan-wspace-errors))))
#+END_SRC

*** Default truncate lines
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

*** Bell off
#+BEGIN_SRC emacs-lisp
  (setq visible-bell t)
#+END_SRC

*** Shorten answer
#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Show keystrokes in progress
#+begin_src emacs-lisp
  (setq echo-keystrokes 0.1)
#+END_SRC

*** Remove text in active region if inserting text
#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

*** Subword mode

#+BEGIN_SRC emacs-lisp
  (global-subword-mode 1)
  (diminish 'subword-mode)
#+END_SRC

*** Clipboard

#+BEGIN_SRC emacs-lisp
  (setq select-enable-clipboard t
        select-enable-primary t)
#+END_SRC

*** Add the system clipboard to the Emacs kill-ring

http://pragmaticemacs.com/emacs/add-the-system-clipboard-to-the-emacs-kill-ring/

#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)
#+END_SRC

*** no backup file

#+begin_src emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+end_src

** Utilities
*** text scale adjust

~C-+~ ÈÄ≤ÂÖ•ÊñáÂ≠óÂ§ßÂ∞èË™øÊï¥Ê®°Âºè
Áî® +, -, 0 Ë™øÊï¥

#+BEGIN_SRC emacs-lisp
  (setq-default text-scale-mode-step 1.1)
  (bind-key "C-+" 'text-scale-adjust)
#+END_SRC

*** opencc-buffer

#+BEGIN_SRC emacs-lisp
  (defun opencc-buffer ()
    "Convert chinese from simplified to variants and phrases of Taiwan"
    (interactive)
    (set-buffer-file-coding-system 'utf-8-unix)

    (let ((opencc-conv-temp-file (temporary-file-name "opencc.tmp" )))
      (let ((str-for-opencc (buffer-substring-no-properties (point-max) 1)))
        (with-temp-file opencc-conv-temp-file
          (insert str-for-opencc "\n")))

      (let ((current-point (point))
            (result (shell-command-to-string
                     (concat "opencc -c s2twp.json -i " opencc-conv-temp-file))))

        (erase-buffer)
        (insert result)
        (goto-char current-point))))

  (bind-key "C-c fo" 'opencc-buffer)

#+END_SRC

*** TODO opencc-region

#+BEGIN_SRC emacs-lisp :tangle no
(defun opencc-region ())
#+END_SRC

*** TODO sdcv

*copyright issue*

ref: http://lifegoo.pluskid.org/wiki/EmacsStardict.html

#+BEGIN_SRC emacs-lisp :tangle no
  (bind-key "C-c s" 'kid-sdcv-to-buffer)

  (defun kid-sdcv-to-buffer ()
    (interactive)
    (let ((word (if mark-active
                    (buffer-substring-no-properties (region-beginning) (region-end))
		  (current-word nil t))))
      (setq word (read-string (format "Search the dictionary for (default %s): " word)
                              nil nil word))

      (set-buffer (get-buffer-create "*sdcv*"))
      (buffer-disable-undo)
      (erase-buffer)

      (let ((process (start-process-shell-command "sdcv" "*sdcv*" "sdcv" "-n" word)))
	(set-process-sentinel
	 process
	 (lambda (process signal)
           (when (memq (process-status process) '(exit signal))
             (unless (string= (buffer-name) "*sdcv*")
               (setq kid-sdcv-window-configuration (current-window-configuration))
               (switch-to-buffer-other-window "*sdcv*")
               (local-set-key (kbd "d") 'kid-sdcv-to-buffer)
               (local-set-key (kbd "q") (lambda ()
                                          (interactive)
                                          (bury-buffer)
                                          (unless (null (cdr (window-list))) ; only one window
                                            (delete-window)))))
             (goto-char (point-min))))))))
#+END_SRC

*** moedict ËêåÂÖ∏

#+BEGIN_SRC emacs-lisp
  (use-package moedict
    :quelpa (moedict :fetcher github :repo "kuanyui/moedict.el")
    :ensure helm
    :ensure esqlite
    :bind ("C-c m" . moedict)
    :config
    (setq browse-url-chromium-program "google-chrome-stable"))
#+END_SRC

**** TODO using moedict by ivy

#+BEGIN_SRC emacs-lisp :tangle no
:noweb-ref moedict-config
  (defun counsel-moedict ()
    "moedict"
(interactive)
(let ((initial-input (word-at-point)))
      (ivy-read moedict-prompt
		'(lambda (x) (counsel-moedict-function x))
		:initial-input initial-input
		:dynamic-collection t
		:action #'moedict-lookup-and-show-in-buffer
		)))

  (defun counsel-moedict-function (&optional string)
    (if (null string)
	(setq string ""))
    (or (unless (string= "" string)
	  (moedict-get-candidates-list string))
	(list nil)))
#+END_SRC

*** epub reader

[[https://github.com/wasamasa/nov.el][GitHub - wasamasa/nov.el: Major mode for reading EPUBs in Emacs]]

Open the EPUB file with C-x C-f ~/novels/novel.epub, scroll with ~SPC~
and switch chapters with ~n~ and ~p~. More keybinds can be looked up
with ~F1 m~.

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :mode "\\.epub\\'"
    :bind (:map nov-mode-map
                ("j" . next-line)
                ("k" . previous-line)
                ("d" . scroll-up-command)
                ("e" . scroll-down-command)
                ("u" . scroll-down-command)))
#+END_SRC

*** pdf-tools

- Â¶ÇÊûúÂá∫Áèæ„ÄåNo executable ‚Äòepdfinfo‚Äô found„ÄçÈåØË™§Ë®äÊÅØÔºåÂâáÂü∑Ë°å‰∏ÄÊ¨° =M-x pdf-tools-install= Âç≥ÂèØ„ÄÇ
- Â¶ÇÊûúÂá∫Áèæ„Äålib... not found„ÄçÔºåÂâá uninstall pdf-tools Âæå re-installÔºåÂÜçÂü∑Ë°å =M-x pdf-tools-install= „ÄÇ

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :bind (:map pdf-view-mode-map
		("j" . pdf-view-next-line-or-next-page)
		("k" . pdf-view-previous-line-or-previous-page)
		("e" . pdf-view-scroll-down-or-previous-page)
		("u" . pdf-view-scroll-down-or-previous-page)
		("d" . pdf-view-scroll-up-or-next-page)
		("H" . pdf-view-next-page)
		("L" . pdf-view-previous-page)
		("=" . pdf-view-fit-width-to-window)
		("-" . pdf-view-shrink)
		("+" . pdf-view-enlarge))
    :commands (pdf-view-mode)
    :init
    (progn
      (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))
      (setq pdf-view-continuous t)
      ))
#+END_SRC

*** TODO Send file to kindle by wpub
**** utility for async send file by wpub

#+BEGIN_SRC emacs-lisp
  (defun async-wpub (url &optional file-type opencc)
    (let* ((cmd-opencc (if opencc (if (y-or-n-p "Convert to Traditional Chinese?") "-o" "") ""))
	   (cmd-type (if file-type (format "-f %s" file-type) ""))
	   (cmd-wpub (if url (format "wpub %s %s '%s'" cmd-opencc cmd-type url) nil)))

      (if cmd-wpub
	  (progn
	    (message "%s" cmd-wpub)
	    (start-file-process-shell-command "async-wpub"
					      "*async-wpub*"
					      cmd-wpub)))))
#+END_SRC

**** send org-mode file to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun org-to-kindle ()
    "Send current buffer to kindle via wpub.py"

    (interactive)

    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (let ((wpub-temp-file (temporary-file-name (buffer-name)))
                (str (buffer-substring-no-properties (point-max) 1)))

            (with-temp-file wpub-temp-file
              (insert str "\n"))

            (async-wpub wpub-temp-file "org")))

      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

**** send html file to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun html-file-to-kindle (fname)
    (async-wpub fname "html" t))

#+END_SRC

**** send url to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun url-to-kindle (url)
    (if url
        (async-wpub url nil t)
      (message "url: %s" url)))
#+END_SRC

**** eww url to kindle via wpub

#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle ()
    "send the content of current url to kindle via wpub"

    (interactive)
    (url-to-kindle (eww-current-url))
    )
#+END_SRC

**** eww send current page kindle

#+BEGIN_SRC emacs-lisp
  (defun eww-to-kindle-directly ()
    (interactive)

    (let ((fname (eww-temp-file-name-html (eww-current-url))))
      (eww-make-temp-file-source fname)
      (html-file-to-kindle fname)))
#+END_SRC

***** write eww source to temp file

#+BEGIN_SRC emacs-lisp
  (defun eww-temp-file-name-html (fname)
    (temporary-file-name  (concat (md5 fname) ".html")))

  (defun eww-make-temp-file-source (temp-file-name)
    (let ((source (eww-current-source)))
      (with-temp-file temp-file-name
    (insert (string-as-multibyte source)))))
#+END_SRC

**** elfeed send page to kindle

#+BEGIN_SRC emacs-lisp

  (defun elfeed-search-to-kindle ()
    "send current content to kindle"

    (interactive)
    (url-to-kindle (get-elfeed-search-url)))

  (defun elfeed-show-to-kindle ()
    "send current content to kindle"

    (interactive)
    (url-to-kindle (get-elfeed-show-url)))

#+END_SRC

**** send url or org to kindle

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c ok" 'send-url-or-org-to-kindle)
  (require 'eww)
  (defun send-url-or-org-to-kindle ()
    "Send content of current buffer to kindle"
    (interactive)
    (cond
     ((not (eq (eww-current-url) nil)) (eww-to-kindle-directly))
     ((eq (current-buffer-mode) 'org-mode) (org-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-search-mode) (elfeed-search-to-kindle))
     ((eq (current-buffer-mode) 'elfeed-show-mode) (elfeed-show-to-kindle))
     (t (message "%s" "Can't send this page to kindle."))))
#+END_SRC

**** send url-at-point to kindle

#+BEGIN_SRC emacs-lisp
  (defun send-url-to-kindle-at-point ()
    "send contents in url-at-point to kindle"

    (interactive)

    (let ((url (get-text-property (point) 'shr-url)))
      (if url
          (url-to-kindle (get-text-property (point) 'shr-url))
        (message "%s" url)
        )))
#+END_SRC
*** TODO Using pandoc to convert org, markdown file
**** get major mode of current buffer

#+BEGIN_SRC emacs-lisp
  (defun current-buffer-mode ()
    "Return the major-mode associated with current buffer."

    (with-current-buffer (buffer-name)
      major-mode))
#+END_SRC

**** convert org-mode to pdf via pandoc
#+BEGIN_SRC emacs-lisp
  (bind-key "C-c op" 'org-to-pdf)

  (defun org-to-pdf ()
    "Conver org to pdf and open the pdf file."

    (interactive)
    (if (eq (current-buffer-mode) 'org-mode)
        (progn
          (let* ((pdf-name (concat (file-name-sans-extension buffer-file-name) ".pdf")))

            (message "convert to %s" (file-name-nondirectory pdf-name))

            (let* ((latex-engin "xelatex")
                   (template "/home/mario/.pandoc/default.latex")
                   (result (shell-command
                            (format "pandoc %s --latex-engine %s --template %s -s -o %s"
                                    buffer-file-name
                                    latex-engin
                                    template
                                    pdf-name
                                    ))))
              (if (eq result 0)
                  (find-file pdf-name)
                (message result)))
            ))
      (message "Current buffer must be 'org-mode'!")))
#+END_SRC

**** convert markdown to orgmode via pandoc

#+BEGIN_SRC emacs-lisp
  (defun md-to-org ()
    "Convert markdown to org for edit. Especially for evernote/geeknote."

    (interactive)
    (if (eq (current-buffer-mode) 'markdown-mode)
        (let* ((default-directory "/mnt/lvm-data/Documents/")
               (md-buffer-name (buffer-name))
               (md-file-name (buffer-file-name))
               (md-org-buffer (find-file (read-file-name "" default-directory)))
               (md-org-file-name (buffer-file-name)))

          (if (not (file-exists-p md-org-file-name))
              (progn
                (shell-command (format "pandoc -f markdown -t org -o %s %s"
                                       md-org-file-name
                                       md-file-name))
                (revert-buffer nil t)
                (goto-char (point-min))
                (insert "#+TITLE:\n")
                (save-buffer)
                (kill-buffer md-buffer-name))
            (message "%s is already exist." md-org-file-name)))
      (message "Current buffer must be 'markdown-mode'!")))
#+END_SRC

**** save buffer as org-mode and bind key as "C-c oo"

 bind key "C-c oo" to write current page of eww as orgmode
 or markdown to org.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c oo" 'write-buffer-as-orgmode)

  (defun write-buffer-as-orgmode ()
  (interactive)
    (cond
     ((eq (current-buffer-mode) 'markdown-mode) (md-to-org))
     ((eq (current-buffer-mode) 'eww-mode) (eww-to-org))
     (t (message "Current mode must be markdown or eww"))))
#+END_SRC
*** string/starts-with and ends-with

EmacsWiki: Elisp Cookbook
https://www.emacswiki.org/emacs/ElispCookbook

#+BEGIN_SRC emacs-lisp
  (defun string/starts-with (string prefix)
    "Return t if STRING starts with prefix."
    (and (string-match (rx-to-string `(: bos ,prefix) t)
               string)
     t))

  (defun string/ends-with (string suffix)
    "Return t if STRING ends with SUFFIX."
    (and (string-match (rx-to-string `(: ,suffix eos) t)
               string)
     t))
#+END_SRC

*** return temporary file name
#+BEGIN_SRC emacs-lisp
  (defun temporary-file-name (fname)
    (expand-file-name fname temporary-file-directory))
#+END_SRC
* Operation system
** File System Management
*** Dired: the most powerfull file management tool

Ref:
- https://github.com/lunaryorn/.emacs.d/blob/master/init.el
- http://kuanyui.github.io/2014/06/21/dired-tutorial-and-essential-configs/
- http://pragmaticemacs.com/category/dired/

We recently looked at replacing text in buffers.
Using dired, it is possible to do this in many files in a directory.
Start dired and mark files as described here.
Then use Q to run query-replace on all marked files.

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package dired
    :ensure nil
    :bind (:map dired-mode-map
		("s" . my/counsel-dired-sort)
		("f" . dired-find-name-in-current-directory)
		("\)" . dired-omit-and-remember))
    :config
    <<dired-config>>)
#+END_SRC
**** usefull keybinding

***** copy file name

- w selected file name
- M-0 w Áµ∂Â∞çË∑ØÂæë

**** Dired tries to guess a default target directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-dwim-target t)
#+END_SRC

**** Revert on re-visiting

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-auto-revert-buffer t)
#+END_SRC

**** -F marks links with @

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-ls-F-marks-symlinks t)
#+END_SRC

**** set dired listing switches

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  ;; dired-listing-switches "-alh"
  (setq dired-listing-switches "--group-directories-first -alh")
  ;; dired-listing-switches "-lFaGh1v --group-directories-first"
#+END_SRC

**** Don't ask me question when recursively copy/delete file(s)

always: Ë°®Á§∫Ê∞∏‰∏çË©¢Âïè„ÄÇ
top: Ë°®Á§∫Âêå‰∏ÄÊâπÊ™îÊ°àÂè™Ë©¢Âïè‰∏ÄÊ¨°„ÄÇ

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
  (setq dired-recursive-copies  'always
	dired-recursive-deletes 'top)
#+END_SRC

**** sorting current directoy

ÊúÉÂÖàÂïè‰Ω†Ë¶ÅÊ†πÊìö‰ªÄÈ∫ºÂ±¨ÊÄßÊéíÂ∫èÔºåËÄå‰∏îÁ¥ÄÈåÑ‰∏ãÊéíÂ∫èÁãÄÊÖãÔºå‰∏çÊúÉË∑® buffer Â∞±‰∏çË¶ã‰∫Ü„ÄÇ

#+BEGIN_SRC emacs-lisp
  (defconst sorting-action '(("name" "")
			     ("size" "S")
			     ("extension" "X")
			     ("access time" "ut")
			     ("modified time" "t")
			     ("status change time" "ct")))

  (defun sort-dir (sort-item)
    (dired-sort-other
     (concat dired-listing-switches
	     (car (cdr (assoc sort-item sorting-action))))))

  (defun my/counsel-dired-sort ()
    (interactive)

    (let ((sort-cmd (mapcar 'car sorting-action))
	  (sort-dir (lambda (sort-item)
		      (dired-sort-other
		       (concat dired-listing-switches
			       (car (cdr (assoc sort-item sorting-action))))))))

      (ivy-read "sort by" sort-cmd
		:preselect "name"
		:initial-input "^"
		:action #'sort-dir)))
#+END_SRC

**** dired omit mode enhancement

;; Dired Omit Âä†Âº∑:
;; Á∞°ÂñÆ‰æÜË™™ÔºåÈÄôÂÄãËÉΩÂ§†Á¥ÄÈåÑ‰∏ãÁõÆÂâçÁöÑ„ÄåÈö±ËóèÁãÄÊÖã„ÄçÔºåÊâÄ‰ª•Áï∂‰Ω†Êåâ
;; C-x M-o Èö±Ëóè‰ª•.ÁÇ∫ÈñãÈ†≠ÁöÑÊ™îÊ°àÂæåÔºåÂç≥‰ΩøÂà∞‰∫Ü‰∏çÂêåÁõÆÈåÑ‰∏ãÔºå‰ª•.ÈñãÈ†≠ÁöÑÊ™îÊ°à
;; ‰æùËàäÊòØËôïÊñºÈö±ËóèÁãÄÊÖãÔºåÁõ¥Âà∞‰Ω†ÈáçÊñ∞Êåâ C-x M-o ÁÇ∫Ê≠¢„ÄÇ

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
(setq dired-omit-files "^\\...+$")

(defvar v-dired-omit t
  "If dired-omit-mode enabled by default. Don't setq me.")

(defun dired-omit-and-remember ()
  "This function is a small enhancement for `dired-omit-mode', which will
        \"remember\" omit state across Dired buffers."

  (interactive)
  (setq v-dired-omit (not v-dired-omit))
  (dired-omit-auto-apply)
  (revert-buffer))

(defun dired-omit-auto-apply ()
  (setq dired-omit-mode v-dired-omit))

(add-hook 'dired-mode-hook 'dired-omit-auto-apply)
#+END_SRC

**** recursively find files under current directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref dired-config
(defun dired-find-name-in-current-directory ()
  (interactive)
  (find-name-dired default-directory
                   (format "*%s*" (read-from-minibuffer "Pattern: ")))
  (set-buffer-multibyte t))
(setq find-name-arg "-iname")
(setq find-ls-option '("-print0 | xargs -0 ls -ald" . ""))
#+END_SRC

**** TODO dired-rainbow

#+BEGIN_SRC emacs-lisp :tangle no
:noweb-ref dired-config
(use-package dired-rainbow
    :commands dired-rainbow-define dired-rainbow-define-chmod
    :init
    (dired-rainbow-define dotfiles "gray" "\\..*")

    (dired-rainbow-define web "#4e9a06" ("htm" "html" "xhtml" "xml" "xaml" "css" "js"
                                         "json" "asp" "aspx" "haml" "php" "jsp" "ts"
                                         "coffee" "scss" "less" "phtml"))
    (dired-rainbow-define prog "yellow3" ("el" "l" "ml" "py" "rb" "pl" "pm" "c"
                                          "cpp" "cxx" "c++" "h" "hpp" "hxx" "h++"
                                          "m" "cs" "mk" "make" "swift" "go" "java"
                                          "asm" "robot" "yml" "yaml" "rake" "lua"))
    (dired-rainbow-define sh "green yellow" ("sh" "bash" "zsh" "fish" "csh" "ksh"
                                             "awk" "ps1" "psm1" "psd1" "bat" "cmd"))
    (dired-rainbow-define text "yellow green" ("txt" "md" "org" "ini" "conf" "rc"
                                               "vim" "vimrc" "exrc"))
    (dired-rainbow-define doc "spring green" ("doc" "docx" "ppt" "pptx" "xls" "xlsx"
                                              "csv" "rtf" "wps" "pdf" "texi" "tex"
                                              "odt" "ott" "odp" "otp" "ods" "ots"
                                              "odg" "otg"))
    (dired-rainbow-define misc "gray50" ("DS_Store" "projectile" "cache" "elc"
                                         "dat" "meta"))
    (dired-rainbow-define media "#ce5c00" ("mp3" "mp4" "MP3" "MP4" "wav" "wma"
                                           "wmv" "mov" "3gp" "avi" "mpg" "mkv"
                                           "flv" "ogg" "rm" "rmvb"))
    (dired-rainbow-define picture "purple3" ("bmp" "jpg" "jpeg" "gif" "png" "tiff"
                                             "ico" "svg" "psd" "pcd" "raw" "exif"
                                             "BMP" "JPG" "PNG"))
    (dired-rainbow-define archive "saddle brown" ("zip" "tar" "gz" "tgz" "7z" "rar"
                                                  "gzip" "xz" "001" "ace" "bz2" "lz"
                                                  "lzma" "bzip2" "cab" "jar" "iso"))

    ;; boring regexp due to lack of imagination
    (dired-rainbow-define log (:inherit default :italic t) ".*\\.log")

    ;; highlight executable files, but not directories
    (dired-rainbow-define-chmod executable-unix "green" "-[rw-]+x.*"))
#+END_SRC

*** dired+

#+BEGIN_SRC sh
yaourt -S unzip unrar
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package highlight
    :quelpa (:fetcher url :url "https://www.emacswiki.org/emacs/download/highlight.el")
    )

  (use-package dired+
    :quelpa (:fetcher github :repo "emacsmirror/dired-plus")
    :init
    (diredp-toggle-find-file-reuse-dir 1)
    (setq dired-recursive-deletes 'always)

    (dolist (file `(("unrar x" "rar")
                    ("aegisub-3.2" "ass" "srt")
                    ("mediainfo"  "ogm" "avi" "mpg" "rmvb" "rm" "flv" "wmv" "mkv" "mp4" "m4v" "webm" "mp3")
                    ("mpv -playlist" "list" "pls")
                    ("kindlegen" "epub")
                    ("kmail" "mobi")
                    ("feh -F --auto-rotate *" "gif" "jpeg" "jpg" "tif" "png")
                    ("google-chrome-stable" "xml" "xhtml" "html" "htm" "mht")
                    ))
      (add-to-list 'dired-guess-shell-alist-default
                   (list (concat "\\." (regexp-opt (cdr file) t) "$")
                         (car file)))))
#+END_SRC

*** openwith

[[https://github.com/emacsmirror/openwith][GitHub - emacsmirror/openwith: Open files with external programs]]

#+BEGIN_SRC emacs-lisp
  (use-package openwith
    :init
    (openwith-mode t)
    (setq openwith-associations
          (list
           (list (openwith-make-extension-regexp '("flac" "mp3" "wav" "aiff" "m4a" "aac"))
                 "mpv" '(file))
           (list (openwith-make-extension-regexp '("avi" "flv" "mov" "mp4" "rmvb" "m2ts" "webm"
                                                   "mpeg" "mpg" "ogg" "wmv" "mkv"))
                 "mpv" '(file)))
          ))
#+END_SRC

*** dired-async

[[https://github.com/jwiegley/emacs-async][GitHub - jwiegley/emacs-async: Simple library for asynchronous processing in Emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package async
    :init
    (autoload 'dired-async-mode "dired-async.el" nil t)
    (dired-async-mode 1)
    (async-bytecomp-package-mode 1)
    (setq async-bytecomp-allowed-packages '(all)))
#+END_SRC

*** peep-dired

dired preview on other window

#+BEGIN_SRC emacs-lisp
  (use-package peep-dired
    :bind (:map dired-mode-map
                ("P" . peep-dired))
    :config
    (setq peep-dired-enable-on-directories t)
    (add-to-list 'peep-dired-ignored-extensions "m2ts"))
#+END_SRC

*** Making directories on the fly

SOURCE: http://mbork.pl/2016-07-25_Making_directories_on_the_fly

#+BEGIN_SRC emacs-lisp
  (defun make-parent-directory ()
    "Make sure the directory of `buffer-file-name' exists."
    (make-directory (file-name-directory buffer-file-name) t))

  (add-hook 'find-file-not-found-functions #'make-parent-directory)
#+END_SRC

*** narrow dired to match filter binding to "/"

SOURCE: http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/

/: enter filter mode
q: exit filter mode

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :bind (:map dired-mode-map
              ("/" . dired-narrow)))
#+END_SRC

*** Edit current buffer as root

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fR" 'edit-current-file-as-root)
  (defun edit-current-file-as-root ()
    "Edit the file that is associated with the current buffer as root"
    (interactive)
    (if (buffer-file-name)
        (progn
          (setq file (concat "/sudo:root@localhost:" (buffer-file-name)))
          (find-file file))
      (message "Current buffer does not have an associated file.")))
#+END_SRC

*** Delete current buffer file

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fD" 'delete-current-buffer-file)
  (defun delete-current-buffer-file ()
    "Removes file connected to current buffer and kills buffer."
    (interactive)
    (let ((filename (buffer-file-name))
          (buffer (current-buffer))
          (name (buffer-name)))
      (if (not (and filename (file-exists-p filename)))
          (ido-kill-buffer)
        (when (yes-or-no-p "Are you sure you want to remove this file? ")
          (delete-file filename)
          (kill-buffer buffer)
          (message "File '%s' successfully removed" filename)))))
#+END_SRC

*** Rename current Buffer and file

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fr"  'rename-current-buffer-file)
  (defun rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (error "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (if (get-buffer new-name)
              (error "A buffer named '%s' already exists!" new-name)
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil)
            (message "File '%s' successfully renamed to '%s'"
                     name (file-name-nondirectory new-name)))))))
#+END_SRC

*** Clone current Buffer and file

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fc"  'clone-file-and-open)
  (defun clone-file-and-open (filename)
    "Clone the current buffer writing it into FILENAME and open it"
    (interactive "FClone to file: ")
    (save-restriction
      (widen)
      (write-region (point-min) (point-max) filename nil nil nil 'confirm))
    (find-file filename))
#+END_SRC

*** Add executable attribute to file

Actually this command is the same as =chmod +x= but it doesn't use any shell
command, it use emacs's logior function to change file attribute.

I only make =owener= can has executable permission, not change it for gourp or
others user.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fx" 'set-file-executable)
  (defun set-file-executable()
    "Add executable permissions on current file."

    (interactive)
    (when (buffer-file-name)
      (set-file-modes buffer-file-name
                      (logior (file-modes buffer-file-name) #o100))
      (message (concat "Made " buffer-file-name " executable"))))
#+END_SRC

*** Open recent directory with dired by ivy

Use fasd to open directory in current window.

#+BEGIN_SRC emacs-lisp
  (defun counsel-goto-recent-directory ()
    "Open recent directory with dired"
    (interactive)
    (unless recentf-mode (recentf-mode 1))
    (let ((collection
           (delete-dups
            (append (mapcar 'file-name-directory recentf-list)
                    ;; fasd history
                    (if (executable-find "fasd")
                        (split-string (shell-command-to-string "fasd -ld") "\n" t))))))
      (ivy-read "directories:" collection :action 'dired)))

  (bind-key "C-x C-\\" 'counsel-goto-recent-directory)
#+END_SRC

*** Open recent directory with dired in other window

Use fasd to open directory in another window and switch cursor to new
window.

if there are two panel already, then don't open the other window.
Just switch to another window and open target directory.

#+BEGIN_SRC emacs-lisp
  (defun counsel-goto-recent-directory-other-window ()
    "goto recnet directory other window."
    (interactive)
    (let ((old-buffer-name (buffer-name))
          (new-directory-name (counsel-goto-recent-directory)))
      (message "open recent dir old:%s new:%s" old-buffer-name new-directory-name)
      (if (eq (count-windows) 1)
          (split-window-right))

      (switch-to-buffer old-buffer-name)
      (other-window 1)
      (find-file new-directory-name)))
#+END_SRC

*** open usually files by hotkey

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fs" 'switch-to-scratch-buffer)
  (bind-key "C-c fi" 'find-file-init-org)
  (bind-key "C-c fm" 'find-file-message)

  (defun find-file-message ()
    (interactive)
    (find-file-or-buffer "*Messages*"))

  (defun find-file-init-org ()
    (interactive)
    (find-file user-emacs-init-org))
#+END_SRC

*** find-file usually files by ivy

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c ff" 'find-file-usually-files)
  (defun find-file-usually-files ()
    "open usually using files."
    (interactive)
    ;; (require 'org)
    (require 'elfeed-org)
    (let ((usually-files (list user-emacs-init-org
                               org-default-inbox-file
                               ;; org-default-notes-file
                               "*Messages*"
                               "*scratch*")))

      (ivy-read "find file:" usually-files
                :action #'find-file-or-buffer)))

  (defun find-file-or-buffer (file-or-buffer-name)
    (cond
     ((string= file-or-buffer-name "*scratch*")
      (switch-to-scratch-buffer))
     ((get-buffer file-or-buffer-name)
      (switch-to-buffer file-or-buffer-name))
     ((file-exists-p file-or-buffer-name)
      (find-file file-or-buffer-name))
     (t
      (message "Not found %s" file-or-buffer-name))))
#+END_SRC

*** save-place

Ëá™ÂãïË®òÈåÑÊØè‰∏ÄÂÄãÊ™îÊ°àÔºåcursor ÊâÄÂú®ÁöÑ‰ΩçÁΩÆ„ÄÇ
‰∏ãÊ¨°ÂÜçÈñãÂïüÈÄôÂÄãÊ™îÊ°àÊôÇÔºåcursor ÊúÉËá™ÂãïÂõûÂà∞‰∏äÊ¨°ÁöÑÂú∞Êñπ„ÄÇ

#+BEGIN_SRC emacs-lisp
  (use-package saveplace
    :init
    (progn
      (setq save-place-file (expand-file-name "places" user-cache-directory))
      (save-place-mode 1)))
#+end_src

*** recentf

Recentf is a minor mode that builds a list of recently opened files.

#+BEGIN_SRC emacs-lisp
(use-package recentf
  :init
  (progn
    (setq recentf-save-file (expand-file-name "recentf" user-cache-directory))
    (recentf-mode 1)
  :config
    (setq recentf-max-saved-items 500
          recentf-max-menu-items 10)))
#+end_src

*** dired
**** TODO Dired bookmarks

are especially handy if you use Bookmark+
<2016-12-01 Thu 18:16>

**** TODO dired hacks                                            :READING:

ranger copy/paste files

https://github.com/Fuco1/dired-hacks
<2017-08-02 ‰∏â 09:51>

**** TODO ibuffer/dired binding consistent

<2017-08-11 Fri 20:26:37>

**** TODO dired color theme monika?

**** TODO Using Emacs 38 - dired http://cestlaz.github.io/posts/using-emacs-38-dired/

** Buffer Management                                                :buffer:
*** ibuffer

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package ibuffer
    :bind (("C-x C-b" . ibuffer)
           :map ibuffer-mode-map
           ("c" . kill-all-buffer-but-ibuffer))
    :config
    <<ibuffer-config>>)
#+END_SRC

**** turn off ibuffer-show-empty-filter-groups

ref: [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][Tips for using Emacs Ibuffer]]

Turning off ibuffer-show-empty-filter-groups is particularly useful,
because the empty filter groups can really clutter things up.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ibuffer-config
  (setq ibuffer-show-empty-filter-groups nil)
#+END_SRC

**** ibuffer-auto-mode

ref: [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][Tips for using Emacs Ibuffer]]

ibuffer-auto-mode is a minor mode that automatically keeps the buffer
list up to date. I turn it on in my ibuffer-mode-hook:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref ibuffer-config
  (add-hook 'ibuffer-mode-hook
            '(lambda ()
               (ibuffer-auto-mode 1)))
#+END_SRC

*** ibuffer-vc

[[https://github.com/purcell/ibuffer-vc][GitHub - purcell/ibuffer-vc: Let Emacs' ibuffer-mode group files by git project etc., and show file state]]

#+BEGIN_SRC emacs-lisp
  (use-package ibuffer-vc
    :init
    (add-hook 'ibuffer-hook
              (lambda ()
                (ibuffer-vc-set-filter-groups-by-vc-root)
                (unless (eq ibuffer-sorting-mode
                            'alphabetic)
                  (ibuffer-do-sort-by-alphabetic))))

    (setq ibuffer-formats
          '((mark modified read-only vc-status-mini " "
                  (name 18 18 :left :elide)
                  " "
                  (size 9 -1 :right)
                  " "
                  (mode 16 16 :left :elide)
                  " "
                  (vc-status 16 16 :left)
                  " "
                  filename-and-process))))
#+END_SRC

*** persistent-scratch

ref: [[http://pragmaticemacs.com/emacs/a-persistent-scratch-buffer/][A persistent scratch buffer | Pragmatic Emacs]]

#+BEGIN_SRC emacs-lisp
(use-package persistent-scratch
  :init
  (persistent-scratch-setup-default))
#+END_SRC

*** Show current buffer-file information

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fn" 'my/file-info)

  (defun my/file-info ()
    "Show current buffer information."
    (interactive)
    (if (buffer-file-name (current-buffer))
        (progn
          (let* ((file-name (buffer-file-name (current-buffer)))
                 (f-attr (file-attributes file-name))
                 (f-size (nth 7 f-attr))
                 (f-mode (nth 8 f-attr))
                 (mes1 (format "file path: %s\n" file-name))
                 (mes2 (format "file size: %s byte\n" f-size))
                 (mes3 (format "file type: %s\n" f-mode))
                 (mes4 (count-words--message "this file" (point-min) (point-max)))
                 (mess (concat mes1 mes2 mes3 mes4)))
            (message "%s" mess)))
      nil))
#+END_SRC

*** set buffer to utf-8-unix

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fu" 'buffer-to-utf-8-unix)

  (defun buffer-to-utf-8-unix()
    (interactive)
    (set-buffer-file-coding-system 'utf-8-unix))
#+END_SRC

*** cycle revert buffer decoding

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fa" 'my/cycle-revert-buffer-decoding)

  (defun my/cycle-revert-buffer-decoding ()
    (interactive)

    (let* ((decoders [utf-8 gb18030 big5 gbk])
	   (index-before
	    (if (get 'my/cycle-revert-buffer-decoding 'state)
		(get 'my/cycle-revert-buffer-decoding 'state)
	      0))
	   (index-after (% (+ index-before 1) (length decoders)))
	   (next-decoder (aref decoders index-after)))
      (message "%s %s" decoders next-decoder)
      (put 'my/cycle-revert-buffer-decoding 'state index-after)
      (revert-buffer-with-coding-system next-decoder)))
#+END_SRC

*** revert-buffer

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fv" 'revert-buffer)

  (global-auto-revert-mode 1)
  (setq global-auto-revert-non-file-buffers t)
  (setq auto-revert-verbose nil)
  (setq revert-without-query '(".*"))
#+END_SRC

*** set unique buffer name

Add parts of each file's directory to the buffer name if not unique

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :ensure nil
  :init
    (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

*** TODO Next/Previous User Buffer

http://ergoemacs.org/emacs/elisp_next_prev_user_buffer.html
<2016-06-19 Êó• 16:23>

**** TODO cycle switch buffer in current project/directory or user buffer.

<2017-02-04 ÂÖ≠ 18:10>
*** Switch to previous buffer

#+BEGIN_SRC emacs-lisp
  (bind-key "M-o" 'mode-line-other-buffer)
#+END_SRC

*** Save files and exit (current file or emacs)

#+begin_src emacs-lisp
  (bind-key "C-x k" 'kill-this-buffer)
  (bind-key "C-x C-c" 'save-buffers-kill-emacs)
#+END_SRC

*** Create and switch to *scratch*

#+BEGIN_SRC emacs-lisp
  (defun switch-to-scratch-buffer ()
    "switch buffer to scratch if not exist then create new one"
    (interactive)
    (unless (get-buffer "*scratch*")
      (with-current-buffer (get-buffer-create "*scratch*")
        (insert initial-scratch-message)
        (lisp-interaction-mode)))
    (switch-to-buffer "*scratch*"))
#+END_SRC

** Window Management                                                :window:
*** eyebrowse

default keybindings

+ M-x eyebrowse-mode  -- toggle eyebrowse mode
+ C-x C-w 0..9 -- switch to workspace 0..9
+ C-x C-w '    -- switch to last workspace
+ C-x C-w "    -- close current workspace
+ C-x C-w .    -- switch to workspace N via ivy
+ C-x C-w ,    -- rename workspace
+ C-x C-w </>  -- switch to previous/next workspace

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
:bind ("C-x C-w" . eyebrowse-mode))
#+END_SRC

*** winner-mode

Undo/redo window configuration with C-c <left>/<right>

#+BEGIN_SRC emacs-lisp
(use-package winner)
#+END_SRC

*** ace-window

[[https://github.com/abo-abo/ace-window][GitHub - abo-abo/ace-window: Quickly switch windows in Emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("C-x o" . ace-window)
    :init
    (custom-set-faces
       '(aw-leading-char-face
         ((t (:inherit ace-jump-face-foreground :height 2.0))))))
#+END_SRC

*** swap-windows

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x x" 'z/swap-windows)
  (defun z/swap-windows ()
    "swap windows"
    (interactive)
    (ace-swap-window)
    (aw-flip-window))
#+END_SRC

*** Minibuffer                                                 :minibuffer:

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package minibuffer
  :ensure nil
  :config
  <<minibuffer-config>>)
#+END_SRC

**** Make cursor in minibufer use bar shape

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (add-hook 'minibuffer-setup-hook '(lambda () (setq cursor-type 'bar)))
#+END_SRC

**** Some helper function to let me insert quick in minibuffer

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config

  (defun my/minibuffer-insert (p)
    (kill-line 0) (insert p))

  (defun my/minibuffer-switch-to-ramdisk ()
    "Insert ramdisk path according to system type"
    (interactive)
    (my/minibuffer-insert user-ramdisk-directory))

  (defun my/minibuffer-switch-to-home ()
    "Insert $HOME path."
    (interactive)
    (my/minibuffer-insert (file-name-as-directory (getenv "HOME"))))

  (defun my/minibuffer-switch-to-rootdir ()
    "Insert / path."
    (interactive)
    (my/minibuffer-insert "/"))

  (defun my/minibuffer-switch-to-tramp ()
    "Insert /ssh:."
    (interactive)
    (my/minibuffer-insert "/ssh:"))

  (defun my/minibuffer-switch-to-vm ()
    "Insert /ssh:vm:."
    (interactive)
    (my/minibuffer-insert "/ssh:vm:"))

  (defun my/minibuffer-switch-to-cluster ()
    "Insert /ssh:cluster:."
    (interactive)
    (my/minibuffer-insert "/ssh:cluster:"))
#+END_SRC

**** Save history of minibuffer :tangle no :noweb-ref minibuffer-config

When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.  When Savehist mode is enabled
for the first time in an Emacs session, it loads the previous
minibuffer history from ‚Äòsavehist-file‚Äô.

#+BEGIN_SRC emacs-lisp  :tangle no :noweb-ref minibuffer-config
  (use-package savehist
    :init
    (setq savehist-file (expand-file-name "savehist.dat" user-cache-directory))
    (savehist-mode 1))
#+END_SRC

**** Setup Keybindings                                        :keybinding:

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (bind-keys :map minibuffer-local-map
             ("C-w" . backward-kill-word)
             ("M-p" . previous-history-element)
             ("M-n" . next-history-element)
             ("C-g" . minibuffer-keyboard-quit)
             ("M-t" . my/minibuffer-switch-to-ramdisk)
             ("M-h" . my/minibuffer-switch-to-home)
             ("M-/" . my/minibuffer-switch-to-rootdir)
             ("M-s" . my/minibuffer-switch-to-tramp)
             ("M-v" . my/minibuffer-switch-to-vm)
             ("M-c" . my/minibuffer-switch-to-cluster))
#+END_SRC

**** Save minibuffer history

When Savehist mode is enabled, minibuffer history is saved
periodically and when exiting Emacs.

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref minibuffer-config
  (savehist-mode 1)
  (setq history-length 1000)
#+END_SRC

*** popwin

popwin for undo-tree and multi-term only

#+BEGIN_SRC emacs-lisp
  (use-package popwin
    ;; :init
    ;; (setq helm-popwin
    ;; '(("*Flycheck errors*" :height 10)
    ;; ("*Helm Find Files*" :height 0.3)
    ;; ("^\*helm.+\*$" :regexp t :height 15)))
    :config
    (popwin-mode 1)
    (push '(" *undo-tree*" :width 0.2 :position right) popwin:special-display-config))
#+END_SRC

** call external terminal

call external terminal and cd to working directory of current buffer.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x t" '(lambda()
                       (interactive)
                       (call-process "xterm" nil 0 nil
                                     "-e"
                                     "export SHELL=/usr/bin/fish; export XTERM_SHELL=$SHELL; fish")))
#+END_SRC

** reload emacs' "init.el"

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fR" 'reload-emacs)

  (defun reload-emacs ()
    "reload my emacs settings"
    (interactive)
    (load-file emacs-init-el)
    (delete-other-windows))
#+END_SRC

** Evaluate buffer until error occured

#+BEGIN_SRC emacs-lisp
  (defun eval-buffer-until-error ()
    "Evaluate emacs buffer until error occured."
    (interactive)
    (goto-char (point-min))
    (while t (eval (read (current-buffer)))))
#+END_SRC

** keybinding of delete frame

#+BEGIN_SRC emacs-lisp
  (bind-key "C-x w" 'delete-frame)
#+END_SRC

* Text editing
** Bindings

| key             | function                                     |
|-----------------+----------------------------------------------|
| C-k             | kill to end of line                          |
| C-<backspace>   | kill-line-backward                           |
| C-S-<backspace> | crux-kill-whole-line                         |
| <backspace>     | hungry-delete-backward                       |
| C-d, <del>      | hungry-delete-forward                        |
| M-d             | kill-word                                    |
| M-<del>         | backward-kill-word                           |
| M-k             | sp-backward-kill-sexp                        |
| C-M-k           | sp-kill-sexp                                 |
|-----------------+----------------------------------------------|
| C-c d           | duplicate-current-line-or-region             |
| C-c M-d         | duplicate-and-comment-current-line-or-region |
|-----------------+----------------------------------------------|
| <Home>, C-a     | begin-of-line                                |
| C-M-f           | sp-forword-sexp                              |
| C-M-b           | sp-backward-sexp                             |
| C-M-n           | sp-next-sexp                                 |
| C-M-p           | sp-previous-sexp                             |
| C-M-u           | backward-up-list                             |
| C-M-d           | forward-list                                 |
*** discover-my-major

[[https://github.com/steckerhalter/discover-my-major][discover-my-major]] make you discover key bindings and their meaning for the
current Emacs major mode.

GitHub: https://github.com/steckerhalter/discover-my-major

#+BEGIN_SRC emacs-lisp
  (use-package discover-my-major
    :bind (("C-h C-m" . discover-my-major)
           ("C-h M-m" . discover-my-mode)))
#+END_SRC
*** Which-key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :diminish ""
    :init
    (progn
      (setq which-key-idle-delay 0.5)
      (which-key-mode)
      (which-key-setup-side-window-bottom)
      (setq which-key-side-window-max-width 0.25)))
#+END_SRC
*** Unbind keys

#+BEGIN_SRC emacs-lisp
  (unbind-key "C-z")
  (unbind-key "C-x C-z")
  (unbind-key "C-x m")
#+END_SRC
** crux

[[https://github.com/bbatsov/crux#keybindings][GitHub - bbatsov/crux: A Collection of Ridiculously Useful eXtensions for Emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package crux
    :bind (("C-x 4 t" . crux-transpose-windows)
	   ("C-<backspace>" . crux-kill-line-backwards)
	   ("C-c d" . crux-duplicate-current-line-or-region)
	   ("C-c M-d" . crux-duplicate-and-comment-current-line-or-region)
	   ([remap move-beginning-of-line] . crux-move-beginning-of-line)
	   ([remap kill-whole-line] . crux-kill-whole-line)
	   ))
#+END_SRC

** binding of <del>

Á∏ΩÊòØË®ò‰∏ç‰ΩèÔºåC-delÔºåM-del ÁöÑÂçÄÂà•Ôºå‰πæËÑÜÁî®‰ΩçÂ≠êË®òÔºåctrl ÂêëÂ∑¶Âà™ÔºåAlt ÂêëÂè≥Âà™„ÄÇ

#+BEGIN_SRC emacs-lisp
  (bind-key "C-<delete>" 'backward-kill-word)
  (bind-key "M-<delete>" 'kill-word)
#+END_SRC

** Parentheses

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (setq show-paren-style 'parenthesis)
  (bind-key "C-S-d" 'delete-pair)
#+END_SRC

** smartparens

[[https://github.com/Fuco1/smartparens][GitHub - Fuco1/smartparens: Minor mode for Emacs that deals with parens pairs and tries to be smart about it.]]

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :diminish "‚í´"
    :init
    (require 'smartparens-config)
    (smartparens-global-mode 1))
#+END_SRC

** TODO copying lines without selecting them

[[http://emacs-fu.blogspot.com/2009/11/copying-lines-without-selecting-them.html?m=1][emacs-fu: copying lines without selecting them]]

** turn on electric-pair-mode

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)

  (defmacro epm/add-mode-pairs (hook pairs)
    `(add-hook ,hook
               (lambda ()
                 (setq-local electric-pair-pairs (append electric-pair-pairs ,pairs))
                 (setq-local electric-pair-text-pairs electric-pair-pairs))))

  (epm/add-mode-pairs 'python-mode-hook '((?\' . ?\')))
  (epm/add-mode-pairs 'web-mode-hook '((?\' . ?\')))
  (epm/add-mode-pairs 'org-mode-hook '((?/ . ?/) (?= . ?=) (?~ . ?~) (?* . ?*) (?+ . ?+) (?_ . ?_)))
#+END_SRC

** turn off electric-quote-~ in emacs 25.1 and newer

#+BEGIN_SRC emacs-lisp
  (electric-quote-mode -1)
#+END_SRC

** hungry-delete

#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :diminish ""
    :init
    (global-hungry-delete-mode 1))
#+END_SRC

** move-text

Áî® M-up, M-down ÁßªÂãïÁï∂Ë°åÊàñ region

[[https://github.com/emacsfodder/move-text][GitHub - emacsfodder/move-text: move current line or region up or down]]

#+BEGIN_SRC emacs-lisp
  (use-package move-text
    :commands (move-text-default-bindings)
    :init
    (move-text-default-bindings))
#+END_SRC

** shift region left/right

ref: http://stackoverflow.com/questions/3156450/shift-a-region-or-line-in-emacs

#+BEGIN_SRC emacs-lisp
  (defun shift-text (distance)
    (if (use-region-p)
	(let ((mark (mark)))
          (save-excursion
            (indent-rigidly (region-beginning)
                            (region-end)
                            distance)
            (push-mark mark t t)
            (setq deactivate-mark nil)))
      (indent-rigidly (line-beginning-position)
		      (line-end-position)
		      distance)))

  (defun shift-right (count)
    "Shift text or region right."

    (interactive "p")
    (shift-text count))

  (defun shift-left (count)
    "shift text or region left."

    (interactive "p")
    (shift-text (- count)))

  (bind-key "C-x r <right>" 'shift-right)
  (bind-key "C-x r <left>" 'shift-left)
#+END_SRC

** undo-tree

Áî® M-x undo-tree-visualize (C-x u) Áúã undo-treeÔºåÂæàÁõ¥Ë¶∫„ÄÇ

- undo-tree: ~C-x u~
- undo: ~C-_~
- redo: ~C-?~

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :init
      (global-undo-tree-mode)
    :config
      (setq undo-tree-history-directory-alist
	    `(("." . ,(file-name-as-directory (expand-file-name "undo-tree" user-cache-directory)))))
      (setq undo-tree-auto-save-history t))
#+END_SRC

** expand-region

+ M-= Êì¥ÂÖÖ
+ ‰ª• =, -, 0 Ë™øÊï¥Â§ßÂ∞è
+ =M-SPC= Ë®≠ÂÆö mark

[[https://github.com/magnars/expand-region.el][GitHub - magnars/expand-region.el: Emacs extension to increase selected region by semantic units.]]

#+BEGIN_SRC emacs-lisp
  (bind-key "M-SPC" 'set-mark-command)
  (use-package expand-region
    :bind ("M-=" . er/expand-region))
#+END_SRC

** narrow or widen dwim

ref: [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Emacs narrow-or-widen-dwim ¬∑ Endless Parentheses]]

#+BEGIN_SRC emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
         ((ignore-errors (org-narrow-to-block) t))
         (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  ;; (define-key endless/toggle-map "n"
  ;; #'narrow-or-widen-dwim)
  ;; This line actually replaces Emacs' entire narrowing
  ;; keymap, that's how much I like this command. Only
  ;; copy it if that's what you want.
  (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
  (add-hook 'LaTeX-mode-hook
            (lambda ()
              (define-key LaTeX-mode-map "\C-xn"
        nil)))
#+END_SRC

** iedit

[[https://github.com/victorhge/iedit][iedit]] let you edit multiple regions in the same way simultaneously.

Normal scenario of Iedit mode is like:

1) Highlight certain contents - by press C-; (The default key binding)
   All occurrences of a symbol, string or a rectangle in the buffer or
   a region may be highlighted corresponding to current mark, point and
   prefix argument.  Refer to the document of `iedit-mode‚Äô for
   details.

2) Edit one of the occurrences The change is applied to other
   occurrences simultaneously.

3) Finish - by pressing C-; again

co-work with 'narrow or widen dwim' as above.

important keybindings:
- M-;       :: toggle selection
- C-'       :: toggle unmatched lines visible
- Tab/S-Tab :: goto next/prev occurrence
- M-R       :: replace
- M-H       :: narrow down to function
- M-I       :: narrow down to line
- M-{/}     :: expands the search region upwards/downwards by line
- C-h b     :: help keybindings

#+BEGIN_QUOTE
  =:demand== Prevent deferred loading in all cases.
  Make sure the package is loaded at startup
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (use-package iedit
    :defer 0
    :init
    (custom-set-faces
     '(iedit-occurrence ((t (:inherit isearch))))))
#+END_SRC

** multi-cursor

ref: http://emacsrocks.com/e13.html

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :bind (("C-S-c C-S-c" . mc/edit-lines)
           ("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C-<" . mc/mark-all-like-this)
           ))
#+END_SRC

** ivy

ÁúãËµ∑‰æÜÊØî helm Â•ΩÁúã‰∫õÔºåËºïÈáè‰∏îÂø´ÈÄü„ÄÇ

useful keybindings:

+ M-i :: ivy-insert-current
+ M-j :: ivy-yank-word (word)
+ M-n :: ivy-next-history-element (symbol)
+ M-. :: ivy-next-history-element on ivy-minibuffer-map
+ C-M-n/p :: ‰∏ä‰∏ãÁßªÂãïÈÅ∏ÂñÆ‰∏≠ÁöÑÈÅäÊ®ôÔºåÊ™îÊ°àÂÖßÂÆπÊúÉË∑≥Âà∞Áõ∏Â∞çÊáâÁöÑ‰ΩçÁΩÆ„ÄÇ

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :diminish ""
    :bind
    (("C-c C-r" . ivy-resume)
     :map ivy-minibuffer-map
     ("M-." . ivy-next-history-element))
    :init
    (progn
      (ivy-mode 1)
    :config
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (setq completion-in-region-function 'ivy-completion-in-region)))
#+END_SRC

** swiper

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :bind ("C-s" . swiper))
#+END_SRC

** counsel

‰ΩøÁî®‰ª•‰∏ãÊµÅÁ®ãÔºåÂèØ‰ª•ÂêåÊôÇ‰øÆÊîπ project ‰∏≠ÔºåÂ§öÂÄãÊ™îÊ°àÁöÑÁõ∏ÂêåÊñáÂ≠ó„ÄÇ

1. C-x g   : counsel-rg
2. C-c C-o : counsel-occur
3. C-x C-q : edit buffer with wgrep
4. iedit   : multi edit
5. C-c C-c : exit wgrep

ÂÖàÂÆâË£ù ripgrep

#+BEGIN_SRC sh
yaourt -S ripgrep
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure
    :ensure wgrep
    :ensure rg
    :bind (("M-y" . counsel-yank-pop)
           ("M-x" . counsel-M-x)
           ("C-x f" . counsel-recentf)
           ("C-x l" . counsel-locate)
           ("C-x g" . counsel-rg)
           ("C-:" . counsel-company)
           ("C-x C-\\" . counsel-goto-recent-directory)
           ("C-x \\" . counsel-goto-recent-directory-other-window)
           :map ivy-minibuffer-map
           ("M-y" . ivy-next-line))
    :config
    (setq counsel-grep-base-command "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

#+END_SRC

** Company mode

#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish " ‚ìê"
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    ;; (global-company-mode t)
    :config
    (progn
      (setq company-idle-delay 0.1)
      (setq company-tooltip-limit 10)
      (setq company-minimum-prefix-length 2)
      (setq company-echo-delay 0)

      (add-to-list 'company-backends 'company-ispell t)))
#+END_SRC

*** Add quickhelp in company-mode

ref: https://github.com/expez/company-quickhelp

#+BEGIN_SRC emacs-lisp
  (use-package company-quickhelp
    :ensure
    :commands company-quickhelp-mode
    :init (company-quickhelp-mode 1))
#+END_SRC

*** keybindings

When the completion candidates are shown,
- <f1> to display the documentation for the selected candidate,
- C-w  to see its source. Not all back-ends support this.
- M-n/p select up/down
- <return> to complete
- <Tab> complete the common part
- C-s
- C-r
- C-o
- <f1> to dispaly the documentation
- <C-w> to see its source

** TODO Spell checking
*** Ispell

if want to use "hunspell", then must install hunspell and hunspell_en in OS.

#+BEGIN_SRC emacs-lisp
  (use-package ispell
    :config
    (progn
      (cond
       ((executable-find "aspell")
	(setq ispell-program-name "aspell")
	(setq ispell-extra-args   '("--sug-mode=slow"
                                    "--lang=en_US"
                                    "--ignore=2"
                                    "--ignore-case"
                                    "--run-together"
                                    "--run-together-limit=5"
                                    "--run-together-min=2")))
       ;; how to fire 'hunspell'?
       ((executable-find "hunspell")
	(setq ispell-program-name "hunspell")
	(setq ispell-extra-args   '("-d en_US"))
	(setq ispell-local-dictionary-alist
              '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)
		("zh_TW" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8)))))

      (setq ispell-local-dictionary "en_US")
      (setq ispell-silently-savep t)))
#+END_SRC

*** TODO flyspell

=C-.= corrects word at point.
=C-,‚Äã= to jump to next misspelled word.
=M-$= correct word at point

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flyspell
    :ensure ispell
    :diminish " ‚ìà"
    :init
    (progn
      (add-hook 'prog-mode-hook #'turn-on-flyspell)
      (add-hook 'text-mode-hook #'turn-on-flyspell)

      (dolist (hook '(elfeed-search-mode-hook change-log-mode-hook log-edit-mode-hook))
	(add-hook hook (lambda () (flyspell-mode -1)))))

    :config (unbind-key "C-;" flyspell-mode-map))
#+END_SRC

*** flyspell-correct-ivy

#+BEGIN_SRC emacs-lisp
  (use-package flyspell-correct-ivy
    :ensure flyspell
    :ensure flyspell-correct
    :ensure ivy
    :bind (:map flyspell-mode-map
                ("M-$" . flyspell-correct-word-generic))
    :init
    (progn
      (setq flyspell-correct-interface 'flyspell-correct-ivy)
      ;; (bind-keys :map flyspell-mode-map
      ;; ("M-$" . flyspell-correct-word-generic))
      ;; bind flyspell-correct-word-generic
      ;; (define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-word-generic)
      ;; (define-key flyspell-mode-map (kbd "C-;") #'flyspell-correct-previous-word-generic)
      ))
#+END_SRC

*** Make spell-checking tool ignore some org-mode section

see: http://emacs.stackexchange.com/questions/450/intelligent-spell-checking-in-org-mode

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ispell
    '(progn
       (add-to-list 'ispell-skip-region-alist '(":\\(PROPERTIES\\|LOGBOOK\\):" . ":END:"))
       (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
       ))
#+END_SRC

** avy keybindings

[[https://github.com/abo-abo/avy][GitHub - abo-abo/avy: Jump to things in Emacs tree-style]]

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-g c" . avy-goto-char)
           ("M-g l" . avy-goto-line)
           ("M-g w" . avy-goto-word-1)))
#+END_SRC

** ace-pinyin

[[https://github.com/cute-jumper/ace-pinyin][GitHub - cute-jumper/ace-pinyin: Jump to Chinese character by pinyin with `avy' or `ace-jump-mode`]]

#+BEGIN_SRC emacs-lisp
  (use-package ace-pinyin
    :ensure
    :ensure avy
    :diminish ""
    :commands ace-pinyin-global-mode
    :init
    (setq ace-pinyin-simplified-chinese-only-p nil)
    (ace-pinyin-global-mode 1))
#+END_SRC

** link-hint

[[https://github.com/noctuid/link-hint.el][GitHub - noctuid/link-hint.el: Pentadactyl-like Link Hinting in Emacs with Avy]]

#+BEGIN_SRC emacs-lisp
  (use-package link-hint
    :bind ("C-c ol" . link-hint-open-link)
    :init
    (dolist (map (list help-mode-map Info-mode-map))
	(bind-key "f" 'link-hint-open-link map)))
#+END_SRC

** begin-end-buffer

ÁßªÂãï cursor Âà∞ÁõÆÂâç buffer ÂêàÁêÜÁöÑÈ¶ñ/Â∞æ„ÄÇ
Ëá≥Â∞ëÊîØÊè¥ ibuffer, dired, elfeed-search.

[[https://github.com/DamienCassou/beginend][GitHub - DamienCassou/beginend: Emacs package to redefine M-< and M-> for some modes]]

ref: [[https://emacs.cafe/emacs/package/2017/08/01/beginend.html][beginend.el]]

#+BEGIN_SRC emacs-lisp
  (use-package beginend
    :diminish beginend-global-mode
    :diminish beginend-prog-mode
    :diminish beginend-elfeed-search-mode
    :diminish beginend-dired-mode
    :diminish beginend-ibuffer-mode
    :init
    (setq beginend-global-mode t)
    (beginend-global-mode))
#+END_SRC

** edit very large file

[[https://github.com/m00natic/vlfi][GitHub - m00natic/vlfi: View Large Files in Emacs]]

~C-c C-v~

#+BEGIN_SRC emacs-lisp
  (use-package vlf
    :init
    (require 'vlf-setup)
    )
#+END_SRC

** unfill

#+BEGIN_SRC emacs-lisp
  (use-package unfill)
#+END_SRC
* Programming
** comment/uncomment a line or region

- With positive prefix, apply to N lines including current one.
- With negative prefix, apply to -N lines above."

#+BEGIN_SRC emacs-lisp
  (bind-key "M-;" #'comment-line)
#+END_SRC

** aggressive-indent

ÈùûÊñáÂ≠óÊ®°ÂºèÂèä python-mode ‰∏ãÔºåËá™ÂãïÁ∏ÆÊéí„ÄÇ
ref: [[http://endlessparentheses.com/permanent-auto-indentation.html][Aggressive Auto-indentation with Emacs ¬∑ Endless Parentheses]]

#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :diminish " ‚íæ"
    :init
    (global-aggressive-indent-mode 1)
    :config
    (dolist (mm '(haskell-mode haskell-cabal-mode haskell-interactive-mode
                               python-mode
                               pug-mode stylus-mode))
      (add-to-list 'aggressive-indent-excluded-modes mm)))
#+END_SRC

** rainbow-mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
	:diminish rainbow-mode
    :hook (prog-mode css-mode))
#+END_SRC

** rainbow-delimiters

ref: https://github.com/Fanael/rainbow-delimiters

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :hook ((prog-mode text-mode) . rainbow-delimiters-mode))
#+END_SRC

** highlight-parentheses

highlight surrounding parentheses
https://github.com/tsdh/highlight-parentheses.el

#+BEGIN_SRC emacs-lisp
  (use-package  highlight-parentheses
    :diminish ""
    :hook (prog-mode . highlight-parentheses-mode)
    :init
    (setq hl-paren-colors '("Springgreen3"
                            "IndianRed1"
                            "IndianRed3"
                            "IndianRed4")))
#+END_SRC

** Highlight numbers on program mode

ref: [[https://github.com/Fanael/highlight-numbers]]

#+BEGIN_SRC emacs-lisp
  (use-package highlight-numbers
    :init
    (add-hook 'prog-mode-hook '(lambda()
                                 (if (not (derived-mode-p 'json-mode))
                                     (highlight-numbers-mode)))))
#+END_SRC

** TODO Flycheck

http://codewinds.com/blog/2015-04-02-emacs-flycheck-eslint-jsx.html

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :diminish (flycheck-mode . " ‚ì¢")
    :init
    (add-hook 'after-init-hook #'global-flycheck-mode)
    (setq flycheck-keymap-prefix (kbd "C-c v"))

    :config
    (progn
      ;; disable jshint since we prefer eslint checking
      (setq-default flycheck-disabled-checkers
		    (append flycheck-disabled-checkers '(javascript-jshint)))

      ;; disable json-jsonlist checking for json files
      (setq-default flycheck-disabled-checkers
		    (append flycheck-disabled-checkers
			    '(json-jsonlist)))

      (flycheck-add-mode 'javascript-eslint 'web-mode)
      ;; customize flycheck temp file prefix
      (setq-default flycheck-temp-prefix ".flycheck")

      ;; use local eslint from node_modules before global
      ;; http://emacs.stackexchange.com/questions/21205/flycheck-with-file-relative-eslint-executable
      (defun my/use-eslint-from-node-modules ()
	(let* ((root (locate-dominating-file
		      (or (buffer-file-name) default-directory)
		      "node_modules"))
	       (eslint (and root
			    (expand-file-name "node_modules/eslint/bin/eslint.js"
					      root))))
	  (when (and eslint (file-executable-p eslint))
	    (setq-local flycheck-javascript-eslint-executable eslint))))
      (add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)

      (setq flycheck-indication-mode 'right-fringe)
      (define-key flycheck-mode-map flycheck-keymap-prefix nil)

      (define-key flycheck-mode-map flycheck-keymap-prefix flycheck-command-map)))
#+END_SRC

** Magit (setup)

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :init
    (progn
      (setq magit-last-seen-setup-instructions "1.4.0")
      (setq magit-auto-revert-mode nil)
      (setq magit-save-some-buffers nil)
      (setq magit-set-upstream-on-push t)
      (setq magit-diff-refine-hunk t)
      (setq magit-completing-read-function 'ivy-completing-read)
      (setq magit-default-tracking-name-function 'magit-default-tracking-name-branch-only))
    :bind ("C-c g" . magit-status))
#+END_SRC

** magit-filenotify

#+BEGIN_SRC emacs-lisp
    (use-package magit-filenotify
      :hook ('magit-status-mode . magit-filenotify-mode))
#+END_SRC

** meld

Using =call-meld= to find the differences of current buffer from last commit.

#+BEGIN_SRC emacs-lisp
  (bind-key "C-c fd" 'call-meld)

  (defun call-meld ()
    "Find the differences of current buffer from last commit."
    (interactive)
    (save-excursion
      (shell-command (format "meld %s" (buffer-file-name))))
    )
#+END_SRC

** TODO ediff

#+BEGIN_SRC emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq ediff-split-window-function 'split-window-vertically)
  (setq ediff-merge-split-window-function 'split-window-vertically)
  (add-hook 'ediff-after-quit-hook-internal 'winner-undo)
#+END_SRC

** diff-hl

[[https://github.com/dgutov/diff-hl][GitHub - dgutov/diff-hl: Emacs package for highlighting uncommitted changes]]

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :init
    (progn (global-diff-hl-mode +1)
           (diff-hl-dired-mode 1)))
#+END_SRC

*** keybinds to navigate

- C-x v =  diff-hl-diff-goto-hunk :: Run VC diff command and go to the line corresponding to the current.
- C-x v n  diff-hl-revert-hunk    :: Revert the diff hunk with changes at or above the point.
- C-x v [  diff-hl-previous-hunk  :: Go to the beginning of the previous hunk in the current buffer.
- C-x v ]  diff-hl-next-hunk      :: Go to the beginning of the next hunk in the current buffer.

** projectile

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :diminish ""
    :init
    (progn (projectile-global-mode)
           (setq projectile-completion-system 'ivy)))
#+END_SRC

** TODO yasnippet

ref: yasnippet http://longhorizon.org/blog/2013/03/31/improving-python-development-in-emacs-with-yasnippet/

** Python (elpy)

emacs ‰∏≠ Python ÁöÑË®≠ÂÆöÊúâÂ§™Â§öÁöÑÈÅ∏ÊìáÔºåÊàëÁöÑÈÅ∏ÊìáÊòØ =elpy= ÔºåÂéüÂõ†ÊòØÂè™Ë¶ÅÂÆâË£ùÂ•Ω =elpy= Â∞±ÂèØÁî®„ÄÇ

ref: https://github.com/jorgenschaefer/elpy

1) install ~elpy~ and ~jedi~ and ~virtualenv~ on OS

   #+BEGIN_SRC sh
     pip install elpy jedi virtualenv
   #+END_SRC

2) ÂèÉËÄÉ oh-my-emacs Á∞°ÂñÆË®≠ÂÆö‰∏Ä‰∏ãÂ∞±Â•Ω„ÄÇ

   ref: https://github.com/xiaohanyu/oh-my-emacs/blob/master/modules/ome-python.org


3) Â¶ÇÊûú pip Êõ¥Êñ∞ jedi ÁöÑË©±ÔºåË¶ÅÂü∑Ë°å ~jedi M-x jedi:install-server~ ÔºåÈáçÊñ∞Ë®≠ÂÆö emacs ‰∏≠ÁöÑ jedi„ÄÇ

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package elpy
    :diminish "‚òÄ"
    :ensure
    :ensure flycheck
    :bind ("M-*" . pop-tag-mark)
    :commands elpy-enable
    :init
    (elpy-enable)
    :config
    <<elpy-config>>)
#+END_SRC

*** set elpy backend and module

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (setq elpy-rpc-backend "jedi")

  (setq elpy-modules (delq 'elpy-module-highlight-indentation elpy-modules))
  (setq elpy-modules (delq 'elpy-module-django elpy-modules))

  (add-to-list 'elpy-modules 'elpy-module-company)
  (add-to-list 'elpy-modules 'elpy-module-yasnippet)
#+END_SRC

*** setup flycheck with elpy
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
  (add-hook 'elpy-mode-hook 'flycheck-mode)
#+END_SRC

*** binding newline-and-indent to <RET>
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (define-key python-mode-map (kbd "RET")
    'newline-and-indent)
#+END_SRC

*** set comment-inline-offset
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elpy-config
  (add-hook 'python-mode-hook
            (lambda ()
              (set (make-local-variable 'comment-inline-offset) 2)))
#+END_SRC
** TODO web-mode

ÁõÆÂâçÊòØÁÇ∫‰∫Ü mako ‰ΩøÁî®ÁöÑ web-modeÔºåÁúãËµ∑‰æÜÈÇÑÊúâ‰∏Ä‰∫õÂïèÈ°åÈúÄË¶ÅÂæÆË™øÔºå‰∏çÁü•Â¶Ç‰Ωï‰∏ãÊâã„ÄÇ

Homepage: [[http://web-mode.org/][web-mode.el - html template editing for emacs]]
Source: https://github.com/fxbois/web-mode

ref: http://cestlaz.github.io/posts/using-emacs-21-web-mode/#.WCy93XeZOuU

useful keybindings

- C-c C-n :: jumping to opening/closing tags
- C-c C-f :: HTML folding
- C-c C-s :: snippet insertion
- M-q :: filling
- C-c C-w ::
- C-c C-m ::
- C-c C-i :: indent entire buffer

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :mode "\\.tmpl\\'" "\\.html?\\'" "\\.mako\\'"
    :init
    ;; (add-to-list 'auto-mode-alist '("\\.tmpl\\'" . web-mode))
    (setq web-mode-engines-alist  '(("mako" . "\\.tmpl\\'")))
    ;; (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))

    (setq web-mode-ac-sources-alist
      '(("css" . (ac-source-css-property))
        ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

    (setq web-mode-enable-current-element-highlight t)
    (setq web-mode-enable-auto-closing t)
    (setq web-mode-enable-auto-quoting t)

    (defun my-web-mode-hook ()
      "Hooks for Web mode."

      (setq web-mode-markup-indent-offset 4)
      (setq web-mode-code-indent-offset 4)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-style-padding 4)
      (setq web-mode-script-padding 4))

    (add-hook 'web-mode-hook  'my-web-mode-hook))

#+END_SRC

** css-mode
#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :init (setq css-indent-offset 2))
#+END_SRC

** js2-mode

ref: https://github.com/mooz/js2-mode

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :mode "\\.js$"
    :init
    (progn
      ;; (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
      (add-hook 'js2-mode-hook
        (lambda () (setq js2-basic-offset 4)))
      (add-hook 'js2-mode-hook 'flycheck-mode)))
#+END_SRC
** company-tern

#+BEGIN_SRC emacs-lisp
(use-package company-tern
:demand company
:demand tern
:commands company-backends
:init
(add-to-list 'company-backends 'company-tern))
#+END_SRC

** json-mode

ref: https://github.com/joshwnj/json-mode

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'")
    ;; :init (add-to-list 'auto-mode-alist '("\\.json\\'" . json-mode)))
#+END_SRC

** hexo mode

https://github.com/kuanyui/hexo.el

#+BEGIN_SRC emacs-lisp
(use-package hexo)
#+END_SRC

** pug mode

[[https://github.com/hlissner/emacs-pug-mode][GitHub - hlissner/emacs-pug-mode: Pug support for Emacs, based on slim-mode.]]

must install pug-cli first.

#+BEGIN_SRC sh
sudo npm install pug-cli -g
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package pug-mode
    :config
    (defun pug-compile-saved-file()
      (when (and (stringp buffer-file-name)
                 (string-match "\\.pug\\'" buffer-file-name))
        (pug-compile)))
    (add-hook 'after-save-hook 'pug-compile-saved-file))
#+END_SRC

** stylus mode

[[https://github.com/vladh/stylus-mode][GitHub - vladh/stylus-mode: Stylus support for Emacs, based on pug-mode.]]

#+BEGIN_SRC emacs-lisp
  (use-package stylus-mode
    :quelpa (:fetcher github :repo "vladh/stylus-mode"))
#+END_SRC

** haskell-mode

~C-c C-,~: haskell-mode can also sort and align your import sections nicely.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs$" "\\.l?hs$"
    :bind (:map haskell-mode-map
                ([f5] . my/haskell-stack-build)
                ("M-g i" . haskell-navigate-imports)
                ("M-g M-i" . haskell-navigate-imports))
    :init
    (defun my/haskell-stack-build ()
      (interactive)
      (compile "stack build --fast"))

    (defun my/haskell-hook ()
      (setq mode-name "Œª")
      (turn-on-haskell-doc-mode)
      (turn-on-haskell-indent)
      (turn-on-eldoc-mode))

    (add-hook 'haskell-mode-hook 'my/haskell-hook))
#+END_SRC

** intero-mode

http://commercialhaskell.github.io/intero/

#+BEGIN_SRC emacs-lisp
  (use-package intero
    :requires (haskell-mode)
    :hook (haskell-mode . intero-mode)
    ;; :init
    ;; (add-hook 'haskell-mode-hook 'intero-mode)
    :config
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    :diminish "Œª")
#+END_SRC

** stylish-haskell

#+BEGIN_SRC sh
cabal update
cabal install happy alex
cabal install stylish-haskell
#+END_SRC

~M-x haskell-mode-stylish-buffer~

** flycheck-haskell

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-haskell
    :hook (flycheck-mode . flycheck-haskell-setup))
#+END_SRC

** hindent

~M-q~ : reformat the current declaration.

#+BEGIN_SRC sh
stack install hindent
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (when (executable-find "hindent")
    (use-package hindent
      :diminish hindent-mode " ‚Üπ"
      :hook (haskell-mode . hindent-mode)
      :config
      (setq hindent-reformat-buffer-on-save t)))
#+END_SRC

** haskell-snippets
#+BEGIN_SRC emacs-lisp
   (use-package haskell-snippets)
#+END_SRC

** TODO hlint-refactor

#+BEGIN_SRC emacs-lisp :tangle no
   (use-package hlint-refactor
   :hook (haskell-mode . hlint-refactor-mode)
   :diminish "")
#+END_SRC

** yaml mode

[[https://github.com/yoshiki/yaml-mode][GitHub - yoshiki/yaml-mode: The emacs major mode for editing files in the YAML data serialization format.]]

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.yaml\\'" "\\.yml\\'"
    :config
    (add-hook 'yaml-mode-hook
              '(lambda ()
                 (define-key yaml-mode-map "\C-m" 'newline-and-indent))))
#+END_SRC

** systemd-mode

ÊúÉËá™Âãï‰ª• company Ë£úÂÖ®Ôºå‰∏çÂøÖÂÜçË®≠ÂÆö„ÄÇ

#+BEGIN_SRC emacs-lisp
  (use-package systemd)
#+END_SRC

*** keybindings

(define-key map (kbd "C-c C-d") 'systemd-doc-directives)
(define-key map (kbd "C-c C-o") 'systemd-doc-open)
** ReStructure

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.rst\\'" . rst-mode))
#+END_SRC

** markdown-mode

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.markdown\\'" "\\.md\\'")
#+END_SRC

** nginx-mode

#+BEGIN_SRC emacs-lisp
  (use-package nginx-mode)
#+END_SRC

** fish-mode

[[https://github.com/wwwjfy/emacs-fish][GitHub - wwwjfy/emacs-fish: fish-mode for emacs]]

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode ("\\.fish\\'" . fish-mode)
    :config
    (add-hook 'fish-mode-hook
              (lambda ()
                (add-hook 'before-save-hook 'fish_indent-before-save))))
#+END_SRC

** TODO edbi for database management

[[https://github.com/kiwanami/emacs-edbi][GitHub - kiwanami/emacs-edbi: Database Interface for Emacs Lisp]]

must install following packages from CLI firstly.

#+BEGIN_SRC sh
  sudo cpan RPC::EPC::Service DBI DBD::SQLite DBD::mysql AnyEvent
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package edbi
    :ensure deferred
    :ensure epc
    :ensure ctable
    :ensure concurrent
    :ensure e2wm
    :init
    (autoload 'e2wm:dp-edbi "e2wm-edbi.el" nil t))
#+END_SRC

*** key binding

#+BEGIN_SRC ditaa :file edbi-keybings.png :cmdline -E
       move cursor: hjklnpfbae
     q                         q
    +--------+                +-------+
    |        |                |       |
    | Tables |      SPC       | table |
    | viewer | -------------> | define|
    |        |                |       |
    +--+-+---+   M-n/p        +--+-+--+
       | |       C-c q           | |
       | |c      C-c C-c        c| |
       | |      +----------+     | |
       | +----->|   SQL    |<----+ |
       |        +----------+       |
       | RET    |  query   |    V  |
       +------->|  data    |<------+
                +----------+
                 SPC
#+END_SRC

#+RESULTS:
[[file:edbi-keybings.png]]

*** company-edbi

[[https://github.com/proofit404/company-edbi][GitHub - proofit404/company-edbi: Edbi backend for company-mode.]]

#+BEGIN_SRC emacs-lisp
  (use-package company-edbi
    :commands company-backends
    :init
    (setq edbi:completion-tool nil)
    (add-to-list 'company-backends 'company-edbi))
#+END_SRC

*** edbi mysql

for stock project to use mySQL.

#+BEGIN_SRC emacs-lisp
  (defun opened-edbi-frame-p ()
    (dolist (f (frame-list))
      (if (e2wm:managed-p f)
          (return t))))

  (defun edbi-open-stock-mysql ()
    (interactive)
    (if (opened-edbi-frame-p)
        (message "edbi already open")
      (progn
        (make-frame)
        (let* ((uri "dbi:mysql:stock:localhost")
               (data-source (edbi:data-source uri "stock" "stock"))
               (conn (edbi:start)))
          (edbi:connect conn data-source)
          (edbi:dbview-open conn))
        (e2wm:dp-edbi))))

  (defun edbi-close-stock-mysql ()
    (interactive)
    (if (e2wm:managed-p)
        (progn
          (e2wm:stop-management)
          (delete-frame)
          (kill-edbi-buffers))
      (message "%s" "Please switch to edbi frame!")))

  (bind-key "C-c so" 'edbi-open-stock-mysql)
  (bind-key "C-c sk" 'edbi-close-stock-mysql)
#+END_SRC

*** edbi-sqlite

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package edbi-sqlite
    :bind (("C-x BB" . stock-db-stock-open)
	   ("C-x BQ" . stock-db-stock-close))
    :init
<<edbi-sqlite-config>>
)
#+END_SRC

**** create edbi workspace

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defvar edbi-eyebrowse-mode-prev nil)
  (defvar edbi-eyebrowse-slot nil)

  (defun switch-to-edbi-workspace ()
    (setq edbi-eyebrowse-mode-prev eyebrowse-mode)

    (unless eyebrowse-mode
      (eyebrowse-mode))

    (if edbi-eyebrowse-slot
        (eyebrowse-switch-to-window-config edbi-eyebrowse-slot)
      (progn
        (eyebrowse-create-window-config)
        (setq edbi-eyebrowse-slot (eyebrowse--get 'current-slot))
        (eyebrowse-rename-window-config edbi-eyebrowse-slot "stock")
        )))
#+END_SRC

**** open stock database

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defun stock-db-stock-open()
    "open and manage my stock db."
    (interactive)
    (if edbi-eyebrowse-slot
        (eyebrowse-switch-to-window-config edbi-eyebrowse-slot)
      (progn
        (switch-to-edbi-workspace)
        (edbi-sqlite "/mnt/lvm-data/Programing/stock4/db/stock2.db")
        (e2wm:dp-edbi))))

#+END_SRC

**** close stock database

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defun stock-db-stock-close ()
    "close my stock db"
    (interactive)
    (e2wm:stop-management)
    (when edbi-eyebrowse-slot
      (progn
        (eyebrowse-switch-to-window-config edbi-eyebrowse-slot)
        (setq edbi-eyebrowse-slot nil)
        (kill-edbi-buffers)
        (eyebrowse-close-window-config)
        )))
#+END_SRC

***** kill edbi buffers

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref edbi-sqlite-config
  (defun kill-buffer-edbi (buffer-or-name)
    (when (or (string/starts-with buffer-or-name "*edbi")
              (string/starts-with buffer-or-name "*epc"))
      (kill-buffer buffer-or-name)))


  ;; (cond
  ;; ((string/starts-with buffer-or-name "*edbi")
  ;; (kill-buffer buffer-or-name))
  ;; ((string/starts-with buffer-or-name "*epc")
  ;; (kill-buffer buffer-or-name))
  ;; (t nil)))


  (defun kill-edbi-buffers ()
    (interactive)
    (mapc 'kill-buffer-edbi (mapcar (function buffer-name) (buffer-list))))
#+END_SRC

*** flycheck for edbi

[[https://github.com/purcell/sqlint][GitHub - purcell/sqlint: Simple SQL linter]]
[[https://emacs.stackexchange.com/questions/20273/setting-up-flycheck-in-pair-with-different-mode-is-not-working][Setting up flycheck in pair with different mode is not working - Emacs Stack Exchange]]

1. install ruby for sqlint
   #+BEGIN_SRC sh
     yaourt -S ruby
     gem install sqlint
   #+END_SRC

2. add hook to flycheck

   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'flycheck
       '(progn
          (flycheck-add-mode 'sql-sqlint 'edbi:sql-mode)))
   #+END_SRC
* Internet navigation
** eww (Emacs Web broWser)

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package eww
    :bind (("C-c b" . browse-at-point))
    :config
    <<eww-config>>)
#+END_SRC

*** keybindings

- F :: (eww-toggle-fonts) can be used to toggle whether to use variable-pitch fonts or not.
- R :: (eww-readable) will try do identify the main textual parts of a web page and display only that,
       leaving menus and the like off the page.
- S :: will list all eww buffers, and allow managing them.
- C-c ok :: send current page to kindle
- C-c oo :: write current page as org-mode file

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (bind-keys :map eww-mode-map
             ("f" . link-hint-open-link)
             ("j" . next-line)
             ("k" . previous-line)
             ("l" . forward-char)
             ("h" . backward-char)
             ("d" . scroll-up-command)
             ("e" . scroll-down-command)
             ("B" . eww-browse-with-external-browser)
             ("m" . endless/toggle-image-display)
             ("q" . eww-quit-reset-image-flag)
             ("H" . eww-back-url)
             ("L" . eww-forward-url)
             ("c" . eww-copy-title-url-org-capture)
             ("ok" . eww-to-kindle-directly)
             ("oK" . send-url-to-kindle-at-point)
             ("oo" . eww-to-org)
             ("yy" . eww-copy-page-url)
             ("yt" . eww-copy-current-title)
             ("yo" . eww-copy-title-url-org)
             ("yu" . eww-copy-title-url))
#+END_SRC

*** Using google chrome as generic browser

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (setq browse-url-browser-function 'eww-browse-url)

  (setq browse-url-generic-program (executable-find "google-chrome-stable")
        shr-external-browser 'browse-url-generic)
#+END_SRC

*** using google search

ref: http://emacs.stackexchange.com/questions/2955/how-to-customize-background-color-for-some-web-pages-opened-with-eww

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (setq eww-search-prefix "https://www.google.com/search?q=")
  (setq shr-color-visible-luminance-min 70)
#+END_SRC

*** truncate lines

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (add-hook 'eww-mode-hook '(lambda ()
                              (toggle-truncate-lines nil)))
#+END_SRC

*** toggle image display

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config

  (defun eww-quit-reset-image-flag ()
    "reset image-flag"

    (interactive)
    (setq endless/display-images t)
    ;; (quit-window)
    (kill-buffer "*eww*"))

  (defvar-local endless/display-images t)

  (defun endless/toggle-image-display ()
    "Toggle images display on current buffer."
    (interactive)
    (setq endless/display-images (null endless/display-images))
    (endless/backup-display-property endless/display-images))

  (defun endless/backup-display-property (invert &optional object)
    "Move the 'display property at POS to 'display-backup.
  Only applies if display property is an image.
  If INVERT is non-nil, move from 'display-backup to 'display
  instead.
  Optional OBJECT specifies the string or buffer. Nil means current
  buffer."
    (let* ((inhibit-read-only t)
           (from (if invert 'display-backup 'display))
           (to (if invert 'display 'display-backup))
           (pos (point-min))
           left prop)
      (while (and pos (/= pos (point-max)))
	(if (get-text-property pos from object)
            (setq left pos)
          (setq left (next-single-property-change pos from object)))
          (if (or (null left) (= left (point-max)))
            (setq pos nil)
          (setq prop (get-text-property left from object))
          (setq pos (or (next-single-property-change left from object)
			(point-max)))
          (when (eq (car prop) 'image)
            (add-text-properties left pos (list from nil to prop) object))))))

#+END_SRC

*** eww browse at point

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (defun browse-at-point (arg)
    "browse at point: selected region or url or single word.
   if cursor at whitespace then call eww wait for input some thing."
    (interactive "P")

    (if (consp arg)
        (call-interactively 'eww)
      (if (string= "link" (car (org-thing-at-point)))
          (org-open-at-point)
        (unless (setq-local thing (thing-at-point 'url))
          (unless (setq-local thing (thing-at-point 'symbol))
            (call-interactively 'eww)))
        (eww thing))))
#+END_SRC

*** get current data/title/source on EWW buffer for EMACS 25+

#+BEGIN_SRC emacs-lisp emacs-lisp :tangle no :noweb-ref eww-config
  (defun eww-current-title nil
    "Return title of the Web page the current EWW buffer is visiting."
    (plist-get eww-data :title))

  (defun eww-current-source ()
    "Return source of the Web page the current EWW buffer is visiting."
    (plist-get eww-data :source))
#+END_SRC

*** eww copy current title and url to kill-ring

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref eww-config
  (defun eww-copy-current-title ()
    (interactive)
    (yank-url-or-title (eww-current-title)))

  (defun eww-copy-title-url ()
    (interactive)
    (yank-url-or-title (concat (eww-current-title) "\n" (eww-current-url))))

  (defun eww-copy-title-url-org ()
    (interactive)
    (yank-url-or-title (org-make-link-string (eww-current-url) (eww-current-title))))

  (defun eww-copy-current-source ()
    (interactive)
    (yank-url-or-title (eww-current-source)))
#+END_SRC

*** capture idea to GTD system

#+BEGIN_SRC emacs-lisp
(defun eww-copy-title-url-org-capture ()
(interactive)
  (eww-copy-title-url-org)
  (org-capture :goto "t")
  (yank))
#+END_SRC

*** org-eww-mode

using org-eww to save current web page to org-mode in eww-mode

#+BEGIN_SRC emacs-lisp emacs-lisp :tangle no :noweb-ref eww-config
  (defun eww-to-org ()
    "Save eww current page to an org file"
    (interactive)
    (require 'org-eww)

    (let* ((eww-org-default-directory "/mnt/lvm-data/Documents/eww/")
           (org-file-name (expand-file-name (concat
                                             (replace-regexp-in-string "\[ :„ÄÄ/\]" "-" (eww-current-title))
                                             ".org")
                                            eww-org-default-directory)))
      (org-eww-copy-for-org-mode)
      (switch-to-buffer (get-buffer-create org-file-name))
      (yank)
      (goto-char (point-min))
      (insert "#+TITLE:\n#+AUTHOR:\n#+DATE:\n\n")
      (write-file org-file-name)
      ))
#+END_SRC

** elfeed

[[https://github.com/skeeto/elfeed][GitHub - skeeto/elfeed: An Emacs web feeds client]]

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package elfeed
    :ensure eww
    :bind ("C-c e" . elfeed)
    :config
    <<elfeed-config>>)
#+END_SRC

*** keybindings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (unbind-key "y" elfeed-search-mode-map)
  (bind-keys :map elfeed-search-mode-map
             ("m" . elfeed-toggle-star)
             ("j" . next-line)
             ("k" . previous-line)
             ("l" . forward-char)
             ("h" . backward-char)
             ("f" . avy-goto-line)
             ("d" . scroll-up-command)
             ("e" . scroll-down-command)
             ("g" . elfeed-update)
             ("a" . my/cycle-elfeed-search-filter)
             ("R" . elfeed-search-mark-all-read-next-filter)
             ("B" . elfeed-search-external-browser)
             ("C-<return>" . elfeed-search-browse-url)
             ("c" . copy-elfeed-search-org-capture)
             ("w" . copy-elfeed-search-url)
             ("yy" . copy-elfeed-search-url)
             ("yt" . copy-elfeed-search-title)
             ("yu" . copy-elfeed-search-title-url)
             ("yo" . copy-elfeed-search-org)
             ("ok" . elfeed-search-to-kindle)
             ("oK" . send-url-to-kindle-at-point))

  (unbind-key "y" elfeed-show-mode-map)
  (bind-keys :map elfeed-show-mode-map
             ("j" . next-line)
             ("k" . previous-line)
             ("l" . forward-char)
             ("h" . backward-char)
             ("f" . link-hint-open-link)
             ("d" . scroll-up-command)
             ("e" . scroll-down-command)
             ("B" . elfeed-show-external-browser)
             ("C-<return>" . elfeed-show-visit)
             ("c" . copy-elfeed-show-org-capture)
             ("w" . copy-elfeed-show-url)
             ("yy" . copy-elfeed-show-url)
             ("yt" . copy-elfeed-show-title)
             ("yu" . copy-elfeed-show-title-url)
             ("yo" . copy-elfeed-show-org)
             ("ok" . elfeed-show-to-kindle)
             ("oK" . send-url-to-kindle-at-point))
#+END_SRC

*** set faces
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (custom-set-faces
   '(elfeed-search-unread-title-face ((t :inherit default)))
   '(elfeed-search-title-face ((t :inherit font-lock-comment-face)))
   '(elfeed-search-date-face ((t (:inherit font-lock-string-face))))
   '(elfeed-search-feed-face ((t (:inherit font-lock-doc-face))))
   '(elfeed-search-tag-face ((t (:inherit font-lock-constant-face))))
   )

  (defface elfeed-search-starred-title-face
    '((t :foreground "#cc6666"))
    "Marks a starred Elfeed entry.")

  (defface elfeed-search-mustread-title-face
    '((t :foreground "#cc6666"))
    "Marks a mustread Elfeed entry.")

  (defface elfeed-search-it-title-face
    '((t :foreground "#b5bd68"))
    "Marks a news Elfeed entry.")

  (defface elfeed-search-finace-title-face
    '((t :foreground "#8abeb7"))
    "Marks a finace news Elfeed entry.")

  (defface elfeed-search-read-title-face
    '((t :inherit font-lock-comment-face))
    "Marks a finace news Elfeed entry.")

  (defface elfeed-search-junk-title-face
    '((t :inherit font-lock-comment-face))
    "Marks a junk Elfeed entry.")

  (push '(starred elfeed-search-starred-title-face) elfeed-search-face-alist)
  (push '(star elfeed-search-starred-title-face) elfeed-search-face-alist)
  (push '(mustread elfeed-search-mustread-title-face) elfeed-search-face-alist)
#+END_SRC

*** using curl to get feeds
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (setq elfeed-use-curl t)
#+END_SRC

*** remove tag 'unread' if news was 1 week ago
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (add-hook 'elfeed-new-entry-hook
            '(lambda() (progn
                         (elfeed-make-tagger :before "1 week ago"
                                             :remove 'unread))))
#+END_SRC

*** set default search-filter
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defconst elfeed-search-filter-default "@1-weeks-ago +unread")
  (setq elfeed-search-filter elfeed-search-filter-default)
#+END_SRC

*** reset to default filter
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-reset-to-default-filter ()
    "elfeed reset to default filter"
    (interactive)
    (elfeed-search-set-filter elfeed-search-filter-default))
#+END_SRC

*** update feeds when enter elfeed first time
#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (add-hook 'elfeed-search-mode-hook
            '(lambda() (progn
                         (elfeed-update))))
#+END_SRC

*** refresh buffer when show elfeed entry

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defadvice elfeed-show-entry
      (after switch-buffer activate)
    "after elfeed show entry then refresh buffer"
    (elfeed-show-refresh))
#+END_SRC

*** elfeed-search mark current buffer all read

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-mark-all-read ()
    "mark all feed as read in elfeed search mode"
    (interactive)
    (call-interactively 'mark-whole-buffer)
    (elfeed-search-untag-all-unread))

  (defun elfeed-search-mark-all-read-next-filter ()
    "mark all feed as read and switch to next filter"
    (interactive)
    (call-interactively 'elfeed-search-mark-all-read)
    (my/cycle-elfeed-search-filter)
    )
#+END_SRC

*** elfeed toggle star

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defalias 'elfeed-toggle-star
    (elfeed-expose #'elfeed-search-toggle-all 'starred))
#+END_SRC

*** switch to next filter that has unread feeds

#+BEGIN_SRC emacs-lisp
  (defun my/cycle-elfeed-search-filter ()
    "Switch next filter has unread feeds."
    (interactive)
    (cl-loop for index-feed = (my/cycle-elfeed-search-filter-1)
             ;; do (message "%s %s" index-feed (elfeed-search-has-unread))
             until (or (= 0 index-feed)
                       (elfeed-search-has-unread))))
#+END_SRC

**** switch to next tag circularly

Ëø¥ÂúàÂàáÊèõÁõÆÂâçÊúâÁöÑ tags. tags ‰æÜÊ∫êÊòØ (elfeed-db-get-all-tags).
ÁõÆÁöÑÁÇ∫ÈõÜ‰∏≠Ê≥®ÊÑèÂäõÂú®Âêå‰∏ÄÈ°ûË≥áË®ä„ÄÇ

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun my/cycle-elfeed-search-filter-1 ()
    "switch to next tag circularly."
    ;;(interactive)
    (let* ((filters (vconcat (cons "" (mapcar (lambda (x) (format "+%s" x))
                                              (seq-remove (lambda (x) (eq x 'unread))
                                                          (elfeed-db-get-all-tags))))))
           (index-before
            (if (get 'my/cycle-elfeed-search-filter 'filter-index)
                (get 'my/cycle-elfeed-search-filter 'filter-index)
              0))
           (index-after
            (% (+ index-before 1) (length filters)))
           (next-filter (format "@1-week-ago %s +unread"
                                (aref filters index-after))))

      (put 'my/cycle-elfeed-search-filter 'filter-index index-after)
      (elfeed-search-set-filter next-filter)
      (beginning-of-buffer)
      index-after))
#+END_SRC

**** there are unread feeds on current filter

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-has-unread ()
    (if (and elfeed-search-filter-active elfeed-search-filter-overflowing)
        (return nil)
      (cl-loop with feeds = (make-hash-table :test 'equal)
               for entry in elfeed-search-entries
               count (elfeed-tagged-p 'unread entry) into unread-count
               until (> unread-count 0)
               finally
               (cl-return (> unread-count 0)))))
#+END_SRC

*** yank url and/or title
**** get url and/or title
***** get url and/or title from elfeed entry

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-entry-url (entry)
    (and entry (elfeed-entry-link entry)))

  (defun elfeed-link-title (entry)
    (and entry (elfeed-entry-title entry)))

  (defun elfeed-entry-title-url (entry)
    (concat (elfeed-link-title entry) "\n" (elfeed-entry-url entry)))

  (defun elfeed-entry-link-org (entry)
    "get link string as org-mode link format"
    (concat "[[" (elfeed-entry-url entry) "][" (elfeed-link-title entry) "]]"))
#+END_SRC

***** get current url and/or title in elfeed-search

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun get-elfeed-search-url ()
    (elfeed-entry-url (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-title ()
    (elfeed-link-title (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-title-url ()
    (elfeed-entry-title-url (elfeed-search-selected :ignore-region)))

  (defun get-elfeed-search-org ()
    (elfeed-entry-link-org (elfeed-search-selected :ignore-region)))
#+END_SRC

***** get current url and/or title in elfeed-show

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun get-elfeed-show-url ()
    (elfeed-entry-url elfeed-show-entry))

  (defun get-elfeed-show-title ()
    (elfeed-link-title elfeed-show-entry))

  (defun get-elfeed-show-title-url ()
    (elfeed-entry-title-url elfeed-show-entry))

  (defun get-elfeed-show-org ()
    (elfeed-entry-link-org elfeed-show-entry))

#+END_SRC

**** yank url and/or title in elfeed search mode

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun yank-url-or-title (url-or-title)
    (message "%s" url-or-title)
    (kill-new url-or-title))

  (defun copy-elfeed-search-url ()
    "copy url to clipboard"
    (interactive)
    (yank-url-or-title (get-elfeed-search-url)))

  (defun copy-elfeed-search-title ()
    "copy title to clipboard"
    (interactive)
    (yank-url-or-title (get-elfeed-search-title)))

  (defun copy-elfeed-search-title-url ()
    "copy title and url to clipboard"
    (interactive)
    (yank-url-or-title (get-elfeed-search-title-url)))

  (defun copy-elfeed-search-org ()
    "copy url to clipboard as org-mode formate"
    (interactive)
    (yank-url-or-title (get-elfeed-search-org)))
#+END_SRC

**** yank url and/or title in elfeed show mode

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config

  (defun copy-elfeed-show-url ()
    "copy url to clipboard."
    (interactive)
    (yank-url-or-title (get-elfeed-show-url)))

  (defun copy-elfeed-show-title ()
    "copy title to clipboard."
    (interactive)
    (yank-url-or-title (get-elfeed-show-title)))

  (defun copy-elfeed-show-title-url ()
    "copy title and url to clipboard as title url."
    (interactive)
    (yank-url-or-title (get-elfeed-show-title-url)))

  (defun copy-elfeed-show-org ()
    "copy title and url to clipboard as org-mode link format"
    (interactive)
    (yank-url-or-title (get-elfeed-show-org)))

#+END_SRC

*** open current page by external browser

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
  (defun elfeed-search-external-browser ()
    "open current url via extenal browser"
    (interactive)
    (elfeed-search-browse-url t))

  (defun elfeed-show-external-browser ()
    "open current url via extenal browser"
    (interactive)
    (elfeed-show-visit t))
#+END_SRC

*** elfeed dead feeds

ref: [[https://github.com/skeeto/.emacs.d/blob/master/etc/feed-setup.el][.emacs.d/feed-setup.el at master ¬∑ skeeto/.emacs.d ¬∑ GitHub]]

there is no new post for a long time.

#+BEGIN_SRC emacs-lisp  :tangle no :noweb-ref elfeed-config
(cl-defun elfeed-dead-feeds (&optional (years 1.0))
   "Return a list of feeds that haven't posted en entry in YEARS years."
   (let* ((living-feeds (make-hash-table :test 'equal))
   (seconds (* years 365.0 24 60 60))
   (threshold (- (float-time) seconds)))
   (with-elfeed-db-visit (entry feed)
   (let ((date (elfeed-entry-date entry)))
   (when (> date threshold)
   (setf (gethash (elfeed-feed-url feed) living-feeds) t))))
   (cl-loop for url in (elfeed-feed-list)
   unless (gethash url living-feeds)
   collect url)))
#+END_SRC

*** capture idea to GTD system

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref elfeed-config
(defun copy-elfeed-search-org-capture ()
  (interactive)
  (copy-elfeed-search-org)
  (org-capture :goto "t")
  (yank))

(defun copy-elfeed-show-org-capture ()
  (interactive)
  (copy-elfeed-show-org)
  (org-capture :goto "t")
  (yank))
#+END_SRC

*** TODO elfeed-show/search: binding "oo" to converting to org-mode
must know the content
<2017-08-29 ‰∫å 11:47>

** elfeed-goodies

[[https://github.com/algernon/elfeed-goodies][GitHub - algernon/elfeed-goodies: Various goodies for Elfeed]]

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-goodies
    :ensure elfeed
    :commands elfeed-goodies/setup
    :init
    (setq elfeed-goodies/entry-pane-size 0.618)
    (elfeed-goodies/setup))
#+END_SRC

** elfeed-org

[[https://github.com/remyhonig/elfeed-org][GitHub - remyhonig/elfeed-org: Configure the Elfeed RSS reader with an Orgmode file]]

#+BEGIN_SRC emacs-lisp
  (use-package elfeed-org
    :demand elfeed
    :demand org
    :commands elfeed-org
    :init
    (progn
      ;; (expand-file-name "emacs-init.org" user-emacs-directory)
      (setq rmh-elfeed-org-files (list "~/.elfeed.org"))
      (elfeed-org)))
#+END_SRC
* Blog
** nikola new post

#+BEGIN_SRC emacs-lisp
  (defun nikola-new-post ()
    "Create a new post or open an old post for nikola."

    (interactive)
    (let ((default-directory "/mnt/lvm-data/Documents/blog-2018/posts/"))
      (call-interactively 'find-file)
      (when (= 0 (buffer-size))
        (insert (car (cdr (assoc "N" org-structure-template-alist))))
        (goto-char (point-min)))))

  (bind-key "C-c nn" 'nikola-new-post)
#+END_SRC

** nikola build/deploy blogger site from emacs

#+BEGIN_SRC emacs-lisp
  (defun nikola-build ()
    "build blogger site by nikola build"

    (interactive)
    (message "nikola build")
    (async-shell-command "nikola build"))

  (defun nikola-deploy ()
    "deploy to github by nikola github_deploy"

    (interactive)
    (message "nikola deploy")
    (async-shell-command "nikola github_deploy"))

  (bind-key "C-c nb" 'nikola-build)
  (bind-key "C-c nd" 'nikola-deploy)
#+END_SRC
** insert current date time

for nikola blogger generator

#+BEGIN_SRC emacs-lisp
  (defun current-date-time-nikola ()
    (format-time-string "%Y-%m-%d %H:%M:%S UTC+08:00"))

  (defun insert-current-date-time ()
    "insert current date time at point"
    (interactive)
    (insert (current-date-time-nikola)))
#+END_SRC

* Org and GTD system
** Org

#+BEGIN_SRC emacs-lisp :noweb no-export :exports code
  (use-package org
    :mode ("\\.org\\'" . org-mode)
    :diminish org-src-mode
    :bind (("C-c l" . org-store-link)
           ("C-c c" . org-capture)
           ("C-c a" . org-agenda)
           (:map org-mode-map
                 ("C-c ok" . org-kindle-export-to-html)))
    :config
    <<org-config>>)
#+END_SRC

*** basic setup
 #+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
   (setq org-src-fontify-natively t
         org-src-window-setup 'current-window
         org-confirm-babel-evaluate nil
         org-list-indent-offset 0
         org-blank-before-new-entry '((heading . t)
					(plain-list-item . t))
         org-startup-indented t)
 #+END_SRC

*** Extend org-mode's easy templates

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (add-to-list 'org-structure-template-alist
               '("E" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist
               '("S" "#+BEGIN_SRC sh\n?\n#+END_SRC"))

  (add-to-list 'org-structure-template-alist
               (list "T" (concat "#+TITLE:?\n#+AUTHOR:\n#+DATE: "
                             (current-date-time-nikola)
                             "\n#+UID: mario-long-epub-uid-for-kindle")))

  (add-to-list 'org-structure-template-alist
               (list "N" (concat "#+BEGIN_COMMENT\n"
                                 ".. title:\n"
                                 ".. slug:\n"
                                 ".. date: " (current-date-time-nikola) "\n"
                                 ".. status: draft\n"      ;;published | draft
                                 ".. tags:\n"
                                 ".. category:\n"
                                 ".. link:\n"
                                 ".. description:\n"
                                 ".. type: text\n"         ;;text | micro
                                 "#+END_COMMENT\n"
                                 "#+OPTIONS: toc:nil ^:{}\n"
                                 "#+LANGUAGE: zh-TW\n"
                                 )))
#+END_SRC

*** Extend babel support languages

ref: https://orgmode.org/worg/org-contrib/babel/languages.html

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (require 'ob-shell)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (ditaa . t)
     (dot . t)
     ))
#+END_SRC

*** ÂéªÈô§ Org-mode Ëº∏Âá∫ HTML ÊôÇÂ§öÈ§òÁöÑÁ©∫Ê†º

Â∞ç pandoc ÁÑ°Êïà„ÄÇ

SOURCE: https://github.com/emacs-china/emacs-china.github.io/blob/master/blog/FengShu/org-remove-useless-space-between-chinese.org

#+BEGIN_SRC emacs-lisp :tangle no :exports no
(require 'ox-html)
  (defun eh-org-clean-space (text backend info)
    "Âú® export ÁÇ∫ HTML ÊôÇÔºåÂà™Èô§‰∏≠Êñá‰πãÈñì‰∏çÂøÖË¶ÅÁöÑÁ©∫Ê†º"
    (when (org-export-derived-backend-p backend 'html)
      (let ((regexp "[[:multibyte:]]")
            (string text))
        ;; org È†êË®≠Â∞á‰∏ÄÂÄãÊèõË°åÁ¨¶ËΩâÊèõÁÇ∫Á©∫Ê†ºÔºå‰ΩÜ‰∏≠Êñá‰∏çÈúÄË¶ÅÈÄôÂÄãÁ©∫Ê†ºÔºåÂà™Èô§„ÄÇ
        (setq string
              (replace-regexp-in-string
               (format "\\(%s\\) *\n *\\(%s\\)" regexp regexp)
               "\\1\\2" string))
        ;; Âà™Èô§Á≤óÈ´î‰πãÂâçÁöÑÁ©∫Ê†º
        (setq string
              (replace-regexp-in-string
               (format "\\(%s\\) +\\(<\\)" regexp)
               "\\1\\2" string))
        ;; Âà™Èô§Á≤óÈ´î‰πãÂæåÁöÑÁ©∫Ê†º
        (setq string
              (replace-regexp-in-string
               (format "\\(>\\) +\\(%s\\)" regexp)
               "\\1\\2" string))
        string)))

  (add-to-list 'org-export-filter-paragraph-functions
               'eh-org-clean-space)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
;; https://coldnew.github.io/a1ed40e3/
(defadvice org-html-paragraph (before org-html-paragraph-advice
                                      (paragraph contents info) activate)
  "Join consecutive Chinese lines into a single long line without
unwanted space when exporting org-mode to html."
  (let* ((origin-contents (ad-get-arg 1))
         (fix-regexp "[[:multibyte:]]")
         (fixed-contents
          (replace-regexp-in-string
           (concat
            "\\(" fix-regexp "\\) *\n *\\(" fix-regexp "\\)") "\\1\\2" origin-contents)))
	(ad-set-arg 1 fixed-contents)))
#+END_SRC

*** Convert inline verbatim to kbd when HTML export

ref: https://emacs-china.org/t/org-mode/1165

change =verbatim= to =kbd=
~code~

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'ox-html
    '(setq org-html-text-markup-alist
           '((bold . "<b>%s</b>")
             (code . "<code>%s</code>")
             (italic . "<i>%s</i>")
             (strike-through . "<del>%s</del>")
             (underline . "<span class=\"underline\">%s</span>")
             (verbatim . "<kbd>%s</kbd>"))))
#+END_SRC

*** ‰∏≠Êñá*Âä†Âº∑*Ë™ûÊ≥ïÔºåÊàñ+Âà™Èô§+‰∏ÄÂè•Ë©±Ôºå‰∏çÁî®Âä†‰∏äÁ©∫ÁôΩ

the _quick_ *fox* jumped over a brown +lazy+ dog.

dir/subdir/
dir /subdir/
an*emphasis*word
an *emphasis* word

#+BEGIN_SRC emacs-lisp
  (setcar org-emphasis-regexp-components (concat " \t('\"{[:multibyte:]"))
  (setcar (nthcdr 1 org-emphasis-regexp-components) (concat "[:multibyte:]- \t.,:!?;'\")}\\"))
  (org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

*** TODO add new markup to org-mode HTML export
ref: [[https://emacs.stackexchange.com/questions/7323/how-to-add-new-markup-to-org-mode-html-export][How to add new markup to org-mode HTML export? - Emacs Stack Exchange]]
ref: [[http://endlessparentheses.com/use-org-mode-links-for-absolutely-anything.html][Use Org-Mode Links for Absolutely Anything ¬∑ Endless Parentheses]]

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
#+END_SRC

*** keybinds

- =C-Return= Â¢ûÂä†‰∏ÄÂÄãÊ®ôÈ°å
- =C-S-Return= Â¢ûÂä†‰∏ÄÂÄã TODO Ê®ôÈ°å
- =C-<left>/<right>= Â∞çÊ®ôÈ°åË®≠ÂÆö TODO keywords
- =C-<up>/<down>= Â∞çÊ®ôÈ°åË®≠ÂÆöÈáçË¶ÅÊÄß
- =S-M-Return= Â¢ûÂä†‰∏ÄÂÄã checkbox Â∞àÊ°à

- =M-<left>/<right>= Ê®ôÈ°å‰∏ä/‰∏ãÊé®‰∏ÄÈöé
- =S-<left>/<right>= :: Cycle the thing at point or in the current line, depending on context.

  Depending on context, this does one of the following:
  + switch a timestamp at point one day into the future
  + on a headline, switch to the next TODO keyword.
  + on an item, switch entire list to the next bullet type
  + on a property line, switch to the next allowed value
  + on a clocktable definition line, move time block into the future

- =<TAB>= Ëø¥ÂúàÂ±ïÈñã‰∏ÄÂÄãÊ®ôÈ°å (Âê´Â≠êÊ®ôÈ°å)
- =S-<TAB>= Ëø¥ÂúàÂ±ïÈñãÂÖ®Ê™îÁöÑÊ®ôÈ°å

- =C-c C-c= Â¢ûÂä†Êàñ‰øÆÊîπ tags
- =C-c \= Â±ïÈñãÊú¨Ê™îÁõ∏Â∞çÊáâ tag ÁöÑÊ®ôÈ°åÔºåÂèØÁî® & | ‰∏≤Êé•ÔºåÂÅöÈÇèËºØÊÄßÊü•Ë©¢
- =C-c '= Á∑®ËºØÂéüÂßãÁ¢º

- =C-c C-o= open url/internal link
- =C-c &= back to previous position

- =C-c *= org-toggle-heading or table result

- =C-c [= Â∞áÁõÆÂâçÊ™îÊ°àÂä†ÂÖ• agenda file list ‰∏≠
- =C-c ]= Â∞áÁõÆÂâçÊ™îÊ°àÂæû agenda file list ‰∏≠ÁßªÂá∫

** Capture and Agenda

**** basic settings

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (setq org-agenda-window-setup 'current-window)
  (add-hook 'org-agenda-mode-hook 'hl-line-mode)
#+END_SRC

**** binding

***** capture

- C-c C-c: save eand exit
- C-c C-q: tagged
- C-c C-s: schedule
- C-c C-d: deadline

***** agenda

- s: save all files of agenda

**** files for agenda/inbox/gtd

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (setq org-capture-templates
        '(("t" "Todo" entry (file org-default-inbox-file)
           "* TODO %?\n%T")
          ("e" "Emacs" entry (file+headline org-default-inbox-file "emacs")
           "* TODO %?\n%T")
          ("n" "Note" entry (file org-my-notes-file)
           "* %?\n%T")
          ))

  (setq org-agenda-files (list org-default-inbox-file
                               org-my-notes-file
                               user-emacs-init-org
                               ))

  ;; (setq org-agenda-current-span 'day)
  ;; (setq org-agenda--span 2)

  (setq org-refile-targets '((nil :maxlevel . 2)  ; refile to headings in the current buffer
                             (org-agenda-files :level . 1)
                             ))

  (add-hook 'org-agenda-mode-hook
            '(lambda ()
               (local-set-key (kbd "C-g") 'org-agenda-exit)))
#+END_SRC

**** show dropbox status of GTD directory

#+BEGIN_SRC emacs-lisp :tangle no :noweb-ref org-config
  (bind-key "C-c fg" 'my/GTD-dropbox-status)
  (defun my/GTD-dropbox-status ()
    (interactive)
    (message "%s" (shell-command-to-string "cd ~/Dropbox/GTD&&dropbox-cli filestatus")))
#+END_SRC

**** pop up a new frame to do a capture

#+BEGIN_SRC sh
  $ emacsclient -ne "(make-capture-frame)"
#+END_SRC

press =C-x w= to close this frame

#+BEGIN_SRC emacs-lisp
  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defadvice org-capture-destroy
      (after delete-capture-frame activate)
    "Advise capture-destroy to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
	(delete-frame)))

  (defun make-capture-frame ()
    "Create a new frame and run org-capture."
    (interactive)
    (make-frame '((name . "capture")))
    (select-frame-by-name "capture")
    (delete-other-windows)
    (noflet ((switch-to-buffer-other-window (buf) (switch-to-buffer buf)))
      (org-capture)))
#+END_SRC

**** archive all the DONE/CNACELED tasks by one command

ref: http://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command

#+BEGIN_SRC emacs-lisp
  (defun org-archive-done-tasks ()
    "archive all the DONE/CNACELED tasks "
    (interactive)
    (dolist (status '("/DONE" "/CANCELED"))
      (org-map-entries (lambda ()
             (org-archive-subtree)
             (setq org-map-continue-from (outline-previous-heading)))
               status 'file)))
#+END_SRC

** TODO Org sync with Google Calendar

ref: https://github.com/myuhe/org-gcal.el
ref: [[http://cestlaz.github.io/posts/using-emacs-26-gcal/#.WaQM4nUjHRY][Using Emacs - 26 - Google Calendar, Org Agenda | C'est la Z]]
ref: [[http://www.iperiusbackup.net/en/how-to-enable-google-drive-api-and-get-client-credentials/][How to enable Google Drive API and get client credentials]]

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-gcal
    :ensure
    :ensure request
    :ensure alert
    :config

    (when (file-exists-p user-secret-file)
      (load-file user-secret-file))

    (add-to-list 'org-agenda-files (cdr(car org-gcal-file-alist)))
    ;; don‚Äôt use org-gcal-sync because ‰∫ÇÁ¢º
    (add-hook 'org-agenda-mode-hook (lambda () (org-gcal-refresh-token) (org-gcal-fetch)))
    (add-hook 'org-capture-after-finalize-hook (lambda () (org-gcal-refresh-token) (org-gcal-fetch)))
    )

#+END_SRC

** TODO super-agneda

[[https://github.com/alphapapa/org-super-agenda][GitHub - alphapapa/org-super-agenda: Supercharge your Org daily/weekly agenda by grouping items]]

#+BEGIN_SRC emacs-lisp
  (use-package org-super-agenda
    :config
    (org-super-agenda-mode)
    (let ((org-super-agenda-groups
           '(;; Each group has an implicit boolean OR operator between its selectors.
             (:name "Today"  ; Optionally specify section name
                    :time-grid t  ; Items that appear on the time grid
                    :todo "TODAY")  ; Items that have this TODO keyword
             (:name "Important"
                    ;; Single arguments given alone
                    :tag "bills"
                    :priority "A")
             ;; Set order of multiple groups at once
             (:order-multi (2 (:name "Shopping in town"
                                     ;; Boolean AND group matches items that match all subgroups
                                     :and (:tag "shopping" :tag "@town"))
                              (:name "Food-related"
                                     ;; Multiple args given in list with implicit OR
                                     :tag ("food" "dinner"))
                              (:name "Personal"
                                     :habit t
                                     :tag "personal")
                              (:name "Space-related (non-moon-or-planet-related)"
                                     ;; Regexps match case-insensitively on the entire entry
                                     :and (:regexp ("space" "NASA")
                                                   ;; Boolean NOT also has implicit OR between selectors
                                                   :not (:regexp "moon" :tag "planet")))))
             ;; Groups supply their own section names when none are given
             (:todo "WAITING" :order 8)  ; Set order of this section
             (:todo ("SOMEDAY" "TO-READ" "CHECK" "TO-WATCH" "WATCHING")
                    ;; Show this group at the end of the agenda (since it has the
                    ;; highest number). If you specified this group last, items
                    ;; with these todo keywords that e.g. have priority A would be
                    ;; displayed in that group instead, because items are grouped
                    ;; out in the order the groups are listed.
                    :order 9)
             (:priority<= "B"
                          ;; Show this section after "Today" and "Important", because
                          ;; their order is unspecified, defaulting to 0. Sections
                          ;; are displayed lowest-number-first.
                          :order 1)
             ;; After the last group, the agenda will display items that didn't
             ;; match any of these groups, with the default order position of 99
             )))
      (org-agenda nil "a")))
#+END_SRC

** Pretty Bullets
ref: https://github.com/sabof/org-bullets

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode))
#+END_SRC

** org-kindle

push file.org to my kindle via htmlize, pandoc, kindlegen, kmail

#+BEGIN_SRC emacs-lisp
  (defun org-kindle-export-as-html ()
    (interactive)

    (setq-local org-html-doctype "html5")
    (setq-local org-export-default-language "zh_TW")
    (setq-local org-html-head-include-default-style nil)
    (setq-local org-html-postamble nil)
    (setq-local org-html-head-include-scripts nil)
    (org-html-export-as-html))

  (defun org-kindle-export-to-html ()
    (interactive)

    (let* ((fname (buffer-file-name))
           (fn-html (temporary-file-name (concat fname ".html")))
           (fn-epub (temporary-file-name (concat fname ".epub")))
           (fn-mobi (temporary-file-name (concat fname ".mobi"))))

      (save-window-excursion
        (org-kindle-export-as-html)
        (write-file fn-html)
        (kill-buffer)

        (shell-command (concat "pandoc -f html -o " fn-epub " -i " fn-html))
        (shell-command (concat "kindlegen " fn-epub))
        (async-shell-command (concat "kmail " fn-mobi)))))

  (bind-key "C-c ok" #'org-kindle-export-to-html org-mode-map)

#+END_SRC

*** stylesheet.css for pandoc to export epub

edit ~~/.pandoc/epub.css~

** TODO Present by reveal.js
1. ref: https://github.com/hakimel/reveal.js
2. ref: https://github.com/yjwen/org-reveal

#+BEGIN_QUOTE
Reveal.js is a tool for creating good-looking HTML presentations,
authored by Hakim El Hattab.

Org-Reveal exports your Org documents to reveal.js presentations.
With Org-reveal, you can create beautiful presentations with 3D
effects from simple but powerful Org contents.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ox-reveal
    :ensure htmlize
    :config
    (progn
      (setq org-reveal-root "file:///mnt/lvm-data/github/reveal.js")))
#+END_SRC

** TODO PlantUML mode
[[http://archive.3zso.com/archives/plantuml-quickstart.html][‰ΩøÁî® Emacs Êï≤Âá∫ UMLÔºåPlantUML Âø´ÈÄüÊåáÂçó]]
https://github.com/skuro/plantuml-mode

** TODO graphviz

** TODO ditaa

http://www.cnblogs.com/chenfanyu/archive/2013/01/27/2878845.html

* Finalization
** diminish some mode

#+BEGIN_SRC emacs-lisp
  (diminish 'overwrite-mode)

  (eval-after-load 'org-indent
    '(diminish 'org-indent-mode))
#+END_SRC

* Difficulties

** ~C-M-p~ don't work

ÂéüÂõ†Ôºöfcitx ÊåâÈçµË°ùÁ™Å
Ëß£Ê≥ïÔºöhttp://sudodev.cn/emacs-backward-list-shortcut/

„ÄåÈÖçÁΩÆ Fcitx„ÄçÈÄô‰∏ÄÈ†ÖÔºåÈªûÈÅ∏ÂΩàÂá∫Ëº∏ÂÖ•Ê≥ïÈÖçÁΩÆË¶ñÁ™óÔºåÈªûÈñã„ÄåÂÖ®ÂüüÊÄßË®≠ÂÆö„ÄçÈ†ÅÁ±§Ôºå
ÂãæÈÅ∏Â∫ï‰∏ãÁöÑ„ÄåÈ°ØÁ§∫È´òÈöéÈÅ∏È†Ö„Äç‰πãÂæåÂ§öÂá∫‰æÜ‰∏Ä‰∫õÂÖßÂÆπÔºåÂæÄ‰∏ãÊìºÔºåÊâæÂà∞Ë®≠ÂÆöÊúâ
„ÄåCtrl+Alt+P„ÄçÈÄô‰∏ÄÈ†ÖÁöÑË®≠ÂÆöÔºåÈªûÈÄôÂÄãÊåâÈàïÔºåÂõûËªäÔºåÂ∞±ÁΩÆÁÇ∫Á©∫‰∫Ü„ÄÇ

** install ditaa

Ê≠•È©üÔºö
1. linux ‰∏≠ÂÆâË£ù ditaa, ‰πüÊúÉÂÖàÂÆâË£ù java
2. Âª∫Á´ãÁõÆÈåÑÔºö=~/.emacs.d/elpa/contrib/scripts=
3. Áî® ~find /. -name "ditaa*"~ Êâæ ditaa.jar Âú®Âì™Ôºü
4. Âª∫ ~ditaa.jar~ ÁöÑÈÄ£ÁµêÂà∞ =~/.emacs.d/elpa/contrib/scripts= ‰∏≠

#+BEGIN_SRC sh
yaourt -S ditaa
mkdir -p ~/.emacs.d/elpa/contrib/scripts
find /. -name "ditaa*"
ln -s /usr/share/java/ditaa/ditaa-0_10.jar ditaa.jar
#+END_SRC

* The Final note

‰ΩøÁî® emacs ÊúÉ‰∏äÁôÆÔºåÂ∞§ÂÖ∂ÊòØ lisp ÈÄôÁ®ÆË™ûË®ÄÔºåÁúüÁöÑËø∑‰∫∫„ÄÇ

Âè™Ë¶ÅËä±ÊôÇÈñìÁÜüÊÇâÈÄôÂ•óÂ∑•ÂÖ∑„ÄÅË™ûË®ÄÔºåÁúüÁöÑÂ∞±‰∏çÊÉ≥Áî®ÂÖ∂ÂÆÉÁöÑÁ∑®ËºØÂô®Ôºå‰πüÁÑ°Ê≥ïÁî®ÂÖ∂ÂÆÉÁöÑÁ∑®ËºØÂô®‰∫Ü„ÄÇ

Âõ†ÁÇ∫ÔºåÂ∑≤Á∂ìÁøíÊÖ£Ëá™Â∑±‰∏ÄÊâãÊâìÈÄ†Âá∫‰æÜÔºåÁç®‰∏ÄÁÑ°‰∫åÔºåÈ†ÜÊâãÁöÑÂ∑•ÂÖ∑„ÄÇ

* Maybe or reading
** TODO oremacs/README.md at github ¬∑ abo-abo/oremacs             :READING:

https://github.com/abo-abo/oremacs/blob/github/README.md

** TODO zamansky/emacs.dz: Awesome emacs config files              :READING:

https://github.com/zamansky/emacs.dz

** TODO aculich/.emacs.d                                           :READING:

https://github.com/aculich/.emacs.d

** TODO skeeto/.emacs.d: My personal .emacs.d                      :READING:

https://github.com/skeeto/.emacs.d

** TODO lunaryorn/old-emacs-configuration                          :READING:

https://github.com/lunaryorn/old-emacs-configuration?files=1

** TODO .emacs.d/setup-diff.el at master ¬∑ kaushalmodi/.emacs.d  :READING:

https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-diff.el

** TODO emacs-init.org refector [75%]

- [ ] cleanup no export code block
- [ ] review all
- [X] rearrange headings
- [X] add todo keywork for wanted functions
- [X] move to do itme to emacs-init.org
** TODO add IRC using ERC

#gentoo
irc.freenode.net
<2016-12-16 Fri 16:07>

** MAYBE toggle dot to space in string

<2016-12-07 Wed 10:42>

** MAYBE my-viewer-key-map

<2016-12-26 ‰∏Ä 11:14>

** MAYBE Hirerachy of mode

http://emacs.stackexchange.com/questions/2655/hierarchy-of-modes

** TODO web-mode settings: change the face of matched tag(for nikola)

current is black background is not easy to read.

** MAYBE Emacs-BPR (Background Process Runner)                     :READING:

ilya-babanov/emacs-bpr
https://github.com/ilya-babanov/emacs-bpr

** TODO study abo-abo all respo of emacs
** TODO hydra                                                     :READING:

https://github.com/abo-abo/hydra/blob/master/README.md

** TODO diff/ediff/meld @dired/@ibuffer

<2017-08-20 Êó• 16:15>

** TODO DTrace : debugger for elisp

http://nullprogram.com/blog/2018/01/17/

** TODO Debugging Elfeed with DTrace http://irreal.org/blog/?p=6912
** TODO [[http://irreal.org/blog/?p=7198][Irreal: Emacs Tools for Writers]]

<2018-05-16 Wed 09:52>

** TODO meld in dired.....Dired: marking, copying, moving and deleting files | Pragmatic Emacs

http://pragmaticemacs.com/emacs/dired-marking-copying-moving-and-deleting-files/

** TODO emacs-haskell-tutorial/tutorial.md at master ¬∑ serras/emacs-haskell-tutorial

https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md#interactive-commands

** TODO emacs & hoogle

2.4 Emacs Integration
haskell-mode from versions 2.4 onwards have the function haskell-hoogle, which will hoogle the identifier at point. Setup:

(require 'haskell-mode)
(define-key haskell-mode-map "\C-ch" 'haskell-hoogle)
;(setq haskell-hoogle-command "hoogle")
You will need a web browser configured for best results. Here's an example setup for Safari:

(setq browse-url-browser-function 'browse-url-safari)
(defun browse-url-safari (url &optional new-window)
 "Open URL in a new Safari window."
 (interactive (browse-url-interactive-arg "URL: "))
 (unless
     (string= ""
              (shell-command-to-string
               (concat "open -a Safari " url)))
   (message "Starting Safari...")
   (start-process (concat "open -a Safari " url) nil "open -a Safari " url)
   (message "Starting Safari... done")))
Alternately, you can build the command-line hoogle (darcs repo below) and uncomment the third line above, then results will appear in a buffer.
<2018-06-12 ‰∫å 20:50>

** TODO company-web/README.md at master ¬∑ osv/company-web

https://github.com/osv/company-web/blob/master/README.md
** TODO Org ad hoc code, quick hacks and workarounds               :READING:

http://thomasf.github.io/solarized-css/test/org-hacks.html#sec-1-4
<2017-01-13 Fri 19:16>

** TODO Org-Mode As a Rabbit Hole: Agenda Tasks Piling Up          :READING:

http://karl-voit.at/2017/08/12/org-rabbit-hole/

** TODO setup sop for clock-in/out todo item

effort time
analysis
<2016-12-26 ‰∏Ä 10:19>

** TODO Kanban in Emacs Org-Mode to Get More Work Done             :READING:

http://jr0cket.co.uk/2016/09/Kanban-board-Emacs-Org-mode-to-get-work-done.html

what's theme

** TODO gmail -> todo list -> orgmode

<2017-01-13 Fri 19:49>

** TODO Maximize the org-capture buffer

https://fuco1.github.io/2017-09-02-Maximize-the-org-capture-buffer.html

emacsclient "%u"¬†

** TODO org-capture-extension/README.md at master ¬∑ sprig/org-capture-extension

https://github.com/sprig/org-capture-extension/blob/master/README.md

** TODO org-recent-headings/README.org at master ¬∑ alphapapa/org-recent-headings

https://github.com/alphapapa/org-recent-headings/blob/master/README.org

** TODO org-super-agenda/README.org at master ¬∑ alphapapa/org-super-agenda

https://github.com/alphapapa/org-super-agenda/blob/master/README.org

** TODO org-web-tools/README.org at master ¬∑ alphapapa/org-web-tools

https://github.com/alphapapa/org-web-tools/blob/master/README.org

** TODO alphapapa/org-protocol-capture-html: Capture HTML from the browser selection into Emacs as org-mode content

https://github.com/alphapapa/org-protocol-capture-html

** TODO org examples and cookbook                                  :READING:

http://ehneilsen.net/notebook/orgExamples/org-examples.html

** TODO org-super-agenda/README.org at master ¬∑ alphapapa/org-super-agenda ¬∑ GitHub

https://github.com/alphapapa/org-super-agenda/blob/master/README.org

** TODO Reddit - orgmode - Do you use Pandoc? What would be your wishes regarding Pandoc and Org-mode? :READING:

https://www.reddit.comundefined/

** TODO org-super-agenda/README.org at master ¬∑ alphapapa/org-super-agenda ¬∑ GitHub

https://github.com/alphapapa/org-super-agenda/blob/master/README.org

** TODO Amazon.com Message. html format

https://www.amazon.com/gp/feature.html?ie=UTF8&docId=1000765211

** MAYBE [[https://coldnew.github.io/4e70786/][Âú®‰ªª‰Ωï mode ‰∏ãÈÉΩÂèØ‰ª•‰ΩøÁî®ÂÉè org-mode ÁöÑ easy-template ÈÄ≤Ë°åË£úÂÖ® | coldnew's blog]]

** MAYBE latex ‰∏≠ÊñáÂ≠óÂΩ¢ÔºåËß£Ê±∫§∏î
** TODO Á∞°ÁπÅ‰∫íÊèõ in eww buffer

#+BEGIN_SRC emacs-lisp emacs-lisp :tangle no :noweb-ref eww-config

#+END_SRC

** TODO hangups

ref: https://github.com/jtamagnan/hangups.el

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package hangups
    ;;:load-path
    :ensure adaptive-wrap
    :bind (("C-c h" . hangups-open-conversation-small-p)
	   :map hangups-conv-mode-map
	   ("j" . next-line)
	   ("k" . previous-line)
	   ("l" . forward-char)
	   ("h" . backward-char)
	   ("d" . scroll-up-command)
	   ("e" . scroll-down-command)
	   ("o" . browse-at-point))
    :config
    (progn
      (defun hangups-open-conversation-small-p ()
	"Open conversation to small-p."
	(interactive)

	(hangups)
	(let ((name "Â∞è p_Ëëâ"))
	  (switch-to-buffer (get-buffer-create (hangups/buffer-name name)))
	  (hangups-conv-mode)
	  (hangups-conversation name hangups-messages))

	(add-hook 'hangups-list-mode-hook
		  (lambda () (run-with-timer 120 (* 1 60) 'hangups-list-refresh)))

	(spaceline-define-segment hangups-lighter
	  "hangups conversations"
	  (when (> hangups/convs-unread 0)
	    "\u2706")
	  :face font-lock-warning-face)

	(spaceline-spacemacs-theme '(hangups-lighter)))
      ))
#+END_SRC

** TODO erc
** TODO Insert stock ids at point in elfeed.org

Insert stock ids to '.elfeed.org' and read their RSS

#+BEGIN_SRC emacs-lisp :tangle no
  (use-package esqlite
    :config
    (progn
      (defun insert-stock-id-at-point ()
        "Insert stock ids at point."

        (interactive)

        (if (string= ".elfeed.org" (buffer-name))
            (let* ((db-name "/mnt/lvm-data/Programing/stock4/db/stock2.db")
                   (sql-fetch-stock-ids "select s.sid, i.name from summary as s, stock_info as i where s.sid=i.sid and s.userid=\"mariolong\""))

              (dolist (rec (esqlite-read db-name sql-fetch-stock-ids))
                (insert (format "*** [[http://news.wearn.com/rss/%s][%s-%s]]\n"
                                (s-trim (car rec))
                                (s-trim (car rec))
                                (s-trim (second rec))))))

          (message "%s" "Must in '.elfeed.org'")))

      (bind-key "C-c fi" 'insert-stock-id-at-point)
      ))
#+END_SRC

** TODO GitHub - bmag/emacs-purpose: Manage Windows and Buffers According to Purposes

https://github.com/bmag/emacs-purpose
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package window-purpose
    :init
    (purpose-mode))

#+END_SRC

** TODO auto revert ibuffer

[[https://emacs.stackexchange.com/questions/2177/how-can-i-make-ibuffer-auto-refresh-the-list-of-buffers][ref: How can I make ibuffer auto-refresh the list of buffers? - Emacs Stack Exchange]]

#+BEGIN_SRC emacs-lisp :tangle no
 :noweb-ref ibuffer-config
  (setq auto-revert-verbose nil)

  (defun my-ibuffer-stale-p (&optional noconfirm)
    (frame-or-buffer-changed-p 'ibuffer-auto-buffers-changed))

  (defun my-ibuffer-auto-revert-setup ()
    (set (make-local-variable 'buffer-stale-function)
         'my-ibuffer-stale-p)
    (set (make-local-variable 'auto-revert-verbose) nil)
    (auto-revert-mode 1))

  (add-hook 'ibuffer-mode-hook 'my-ibuffer-auto-revert-setup)
#+END_SRC
